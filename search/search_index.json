{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyTVPaint \ud83d\udc0d \u2192 \ud83e\udd8b","text":"<p>PyTVPaint lets you script for TVPaint in Python instead of  George. It offers a  high level object-oriented API as well as low-level George commands in a fully type-hinted library.</p> <p>PyTVPaint communicates through WebSocket to a custom C++ plugin running in an open TVPaint instance.</p> <p></p> <p>Warning</p> <p>PyTVPaint only works on Windows for now (because of the C++ plugin, the python code is agnostic to the platform but hasn't yet been tested on other OSes). Support for Linux and MacOS can be added later. If you're interested, please submit an issue or a pull request !</p>"},{"location":"#why-use-pytvpaint","title":"Why use PyTVPaint?","text":"<ul> <li> <p>Coding in George is not optimal - it produces hard to maintain code, has bugs and poor support in IDEs (except syntax highlighting in IDEs, for example VSCode).</p> </li> <li> <p>Fully documented - all modules are fully documented and the george docstring is up-to-date, clearer and fixes many of the errors in the official George documentation.</p> </li> <li> <p>Fully type-hinted and tested API - the library uses MyPy to strictly check the Python code, Ruff to lint and detect errors and Pytest and is almost fully unit tested.</p> </li> <li> <p>Seamless coding experience - no need to manually connect or disconnect to the WebSocket server, you can start coding directly and PyTVPaint will do everything for you! Just code in your favourite language (Python) and it will work!</p> </li> <li> <p>Fully extensible - a George function wasn't implemented? You can either submit an issue on the repository or code it yourself! We provide tools to directly speak in George with TVPaint and parse the resulting values.</p> </li> <li> <p>Used in production - PyTVPaint was born from the frustration of coding in George which made our codebase really hard to maintain here at BRUNCH Studio. It's now used in production to support our pipeline.</p> </li> </ul>"},{"location":"#pytvpaint-examples","title":"PyTVPaint examples","text":"<p>Get the name of all the layers in the current clip:</p> <pre><code>from pytvpaint.clip import Clip\n\nclip = Clip.current_clip()\n\nfor layer in clip.layers:\n    print(layer.name)\n</code></pre> <p>Creating a new project:</p> <pre><code>from pytvpaint import Project\n\nnew_project = Project.new(\n    \"./project.tvpp\",\n    width=500,\n    height=800,\n    frame_rate=25,\n    start_frame=10,\n)\n\nnew_project.save()\n</code></pre> <p>Render all the clips in the project:</p> <pre><code>from pathlib import Path\n\nfrom pytvpaint import Project\n\nproject = Project.current_project()\n\nfor clip in project.clips:\n    out_clip = Path.cwd() / clip.name / f\"{clip.name}.#.jpg\"\n    clip.render(out_clip)\n</code></pre> <p>Iterate through the layer instances:</p> <pre><code>from pytvpaint import Layer\n\nfor instance in Layer.current_layer().instances:\n    print(instance.start, instance.name)\n</code></pre>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>PyTVPaint is a project created at BRUNCH Studio to facilitate our development experience with George. The API is targeted at experienced developers and is by no means a replacement for TVPaint or George but simply builds on it.</p> <p>We are not affiliated with the TVPaint development team and therefore can't fix any bugs in the software or the George API.</p> <p>Please direct your issues appropriately; any issues with PyTVPaint should be submitted as an issue in this repository or the C++ plugin's repository, any issues with TVPaint the software should be addressed to the tvp support team.</p> <p>For any questions on the limitations of our API, please head to this page.</p>"},{"location":"credits/","title":"Credits","text":""},{"location":"credits/#brunch-dev-team","title":"Brunch Dev Team","text":"<ul> <li> Radouane Lahmidi</li> <li> Joseph Henry</li> <li> Chloe Oternaud</li> <li> Alexis Prayez</li> </ul>"},{"location":"credits/#special-thanks","title":"Special Thanks","text":""},{"location":"credits/#brunch-studio-for-supporting-the-project","title":"Brunch Studio for supporting the project","text":"<ul> <li> Fabien Cellier : Head of Studio</li> <li> Jean-Charles Kerninon : Head of CG</li> <li> Emilie Revert : Head of 2D Productions</li> </ul>"},{"location":"credits/#other-contributors","title":"Other Contributors:","text":"<ul> <li>The C++ plugin was inspired from existing codebase of Ynput's OpenPype TVPaint plugin.</li> <li>Also thanks to Jakub Trllo from Ynput who helped with the C++ implementation on their Discord server.</li> <li>The TVPaint dev team for their patience and help with our questions and the George commands documentation from TVPaint.</li> </ul>"},{"location":"credits/#logo","title":"Logo","text":"<p>The official PyTVPaint logo was made by Juliette Danesi (   ) at BRUNCH Studio. </p>"},{"location":"credits/#brunch-gems","title":"Brunch gems","text":"<p>A special thanks also to our wonderful artists at the studio who also submitted some very interesting logos for the project.</p> <p>These were obviously made as a joke, and do not represent the true skills of these talented individuals </p> <ul> <li> Milo Pottier</li> </ul> <p></p> <ul> <li> Alph\u00e9e Note</li> </ul> <p></p> <ul> <li> Pierre Yves Vauzelle</li> </ul> <p></p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#tvpaint-plugin-installation","title":"TVPaint plugin installation","text":"<p>PyTVPaint works by sending George commands to a custom C++ plugin running a WebSocket server in TVPaint.</p> <p>You need to manually place it in your TVPaint installation folder.</p>"},{"location":"installation/#windows","title":"Windows","text":"<ul> <li>Download the latest <code>tvpaint-rpc.dll</code> file from the GitHub releases.</li> <li>Copy it in your TVPaint <code>plugins</code> folder:</li> </ul> <pre><code>C:/Program Files/TVPaint Developpement/TVPaint Animation &lt;version&gt; Pro (64bits)/plugins\n</code></pre> <p>Note</p> <p>You may need Administrator rights to copy the DLL file.</p>"},{"location":"installation/#pytvpaint-package","title":"PyTVPaint package","text":"<p>Simply install it with Pip:</p> <pre><code>\u276f pip install pytvpaint\n</code></pre> <p>or use Poetry:</p> <pre><code>\u276f poetry add pytvpaint\n</code></pre> <p>Success</p> <p>You are now ready to start coding in Python for TVPaint!</p>"},{"location":"limitations/","title":"Limitations","text":"<p>This page list all the current limitations of PyTVPaint in its current state.</p>"},{"location":"limitations/#windows-only","title":"Windows only","text":"<p>As stated on the homepage, the <code>tvpaint-rpc</code> C++ plugin is currently compiled for Windows only.</p> <p>We are interested in making it available for Linux and MacOS, but being a Windows Studio we have not needed nor had  time to do so yet. If you want to contribute on this, please open an issue or a pull request on the plugin repository.</p>"},{"location":"limitations/#tvpaint-115","title":"TVPaint 11.5+","text":"<p>TVPaint 11.5 is minimum supported version simply because we currently do not have an older version of TVPaint. The TVPaint  SDK is what really limits the compatibility, but we suspect PyTVPaint is also compatible with TVPaint 11 since the SDK  hasn't changed in a while. If you have a version of TVPaint prior to 11.5 and want to test the API, please let us  know if it works and we will update the minimum requirements for the plugin and API. </p>"},{"location":"limitations/#control-characters-in-george-results","title":"Control characters in George results","text":"<p>This issue has been reported to TVPaint and is related to how the C++ SDK function <code>TVSendCmd</code> returns and encodes control character values.</p> <p>If we use the George command <code>tv_projectheadernotes</code> for instance and the project notes text has some line breaks (<code>\\n</code>), then the characters in the result buffer are not encoded properly.</p> <p>For example:</p> <p>In the project notes:</p> <pre><code>aa\nbb\ncc\n</code></pre> <p>The result from <code>TVSendCmd</code>:</p> <pre><code>['a', 'a', '\\', 'n', 'b', 'b', '\\', 'n', 'c', 'c' ]\n</code></pre> <p>This C++ code was used to print it:</p> <pre><code>char george_result[2048];\nint executionStatus = TVSendCmd(iFilter, payload.command.c_str(), george_result);\n\nstd::stringstream ss;\nss &lt;&lt; \"[\";\n\nint i = 0;\nwhile (george_result[i]) {\n    ss &lt;&lt; \"'\" &lt;&lt; george_result[i] &lt;&lt; \"', \";\n    i += 1;\n}\n\nss &lt;&lt; \"]\";\n\nspdlog::info(ss.str());\n</code></pre> <p>So we suppose that control characters are not properly encoded.</p> <p>Therefore, it is currently impossible to determine if it's actually a backslash <code>\\</code> followed by <code>n</code> or simply the line  break character. SO PyTVPaint leaves these characters as is.</p> <p>Info</p> <p>The TVPaint dev team have been made aware of the issue, and we are hopeful that it will be fixed in the future.</p>"},{"location":"limitations/#george-official-documentation-and-naming-convention-issues","title":"George Official Documentation and Naming Convention Issues","text":"<p>Many functions in the official George documentation are poorly described or have the wrong description all together,  many are overly complex and some don't work at all. Some functions also have misleading names, with some  \"layer\" functions actually impacting the clip and not the layer for instance. </p> <p>We tried to fix as many of these issues as we could when wrapping functions, putting the functions in the appropriate  module when possible. We advise using our documentation for all wrapped functions instead of the official one as  PyTVPaint's documentation is usually more accurate.</p>"},{"location":"limitations/#misbehaving-george-functions","title":"Misbehaving George functions","text":"<p>We will try to keep a list of the bugs/inconsistencies we encountered with any George commands, and describe the  issues in the table below:</p> Method Description <code>tv_Ratio</code> Always returns an empty string (<code>\"\"</code>) <code>tv_InstanceName</code> Crashes if we provided with an invalid <code>layer_id</code> <code>tv_CameraPath</code> Confusing arguments and seemingly incorrect results (see this) <code>tv_SoundClipReload</code> Doesn't accept a proper clip id, only <code>0</code> seems to work for the current clip <code>tv_LayerSelectInfo</code> Does not select frames as stated in the documentation and will also return non selected frames if attribute <code>full</code> is set to True"},{"location":"api/utils/","title":"Utilities","text":"<p>Utility functions and classes which are not specific to anything else in the codebase.</p>"},{"location":"api/utils/#pytvpaint.utils.RefreshedProperty","title":"<code>RefreshedProperty</code>","text":"<p>             Bases: <code>property</code></p> <p>Custom property that calls .refresh() before getting the actual value.</p>"},{"location":"api/utils/#pytvpaint.utils.Refreshable","title":"<code>Refreshable()</code>","text":"<p>             Bases: <code>abc.ABC</code></p> <p>Abstract class that denotes an object that have data that can be refreshed (a TVPaint project for example).</p> Source code in <code>pytvpaint/utils.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.refresh_on_call = True\n</code></pre>"},{"location":"api/utils/#pytvpaint.utils.Refreshable.refresh","title":"<code>refresh() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Refreshes the object data.</p> Source code in <code>pytvpaint/utils.py</code> <pre><code>@abstractmethod\ndef refresh(self) -&gt; None:\n    \"\"\"Refreshes the object data.\"\"\"\n    raise NotImplementedError(\"Function refresh() needs to be implemented\")\n</code></pre>"},{"location":"api/utils/#pytvpaint.utils.Removable","title":"<code>Removable()</code>","text":"<p>             Bases: <code>pytvpaint.utils.Refreshable</code></p> <p>Abstract class that denotes an object that can be removed from TVPaint (a Layer for example).</p> Source code in <code>pytvpaint/utils.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self._is_removed: bool = False\n</code></pre>"},{"location":"api/utils/#pytvpaint.utils.Removable.is_removed","title":"<code>is_removed: bool</code>  <code>property</code>","text":"<p>Checks if the object is removed by trying to refresh its data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether if it was removed or not</p>"},{"location":"api/utils/#pytvpaint.utils.Removable.refresh","title":"<code>refresh() -&gt; None</code>","text":"<p>Does a refresh of the object data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the object has been mark removed</p> Source code in <code>pytvpaint/utils.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Does a refresh of the object data.\n\n    Raises:\n        ValueError: if the object has been mark removed\n    \"\"\"\n    if self._is_removed:\n        raise ValueError(f\"{self.__class__.__name__} has been removed!\")\n</code></pre>"},{"location":"api/utils/#pytvpaint.utils.Removable.remove","title":"<code>remove() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Removes the object in TVPaint.</p> Source code in <code>pytvpaint/utils.py</code> <pre><code>@abstractmethod\ndef remove(self) -&gt; None:\n    \"\"\"Removes the object in TVPaint.\"\"\"\n    raise NotImplementedError(\"Function refresh() needs to be implemented\")\n</code></pre>"},{"location":"api/utils/#pytvpaint.utils.Removable.mark_removed","title":"<code>mark_removed() -&gt; None</code>","text":"<p>Marks the object as removed and is therefor not usable.</p> Source code in <code>pytvpaint/utils.py</code> <pre><code>def mark_removed(self) -&gt; None:\n    \"\"\"Marks the object as removed and is therefor not usable.\"\"\"\n    self._is_removed = True\n</code></pre>"},{"location":"api/utils/#pytvpaint.utils.Renderable","title":"<code>Renderable()</code>","text":"<p>             Bases: <code>abc.ABC</code></p> <p>Abstract class that denotes an object that can be removed from TVPaint (a Layer for example).</p> Source code in <code>pytvpaint/utils.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n</code></pre>"},{"location":"api/utils/#pytvpaint.utils.Renderable.current_frame","title":"<code>current_frame: int</code>  <code>abstractmethod</code> <code>property</code> <code>writable</code>","text":"<p>Gives the current frame.</p>"},{"location":"api/utils/#pytvpaint.utils.CanMakeCurrent","title":"<code>CanMakeCurrent</code>","text":"<p>             Bases: <code>typing_extensions.Protocol</code></p> <p>Describes an object that can do <code>make_current</code> and has an id.</p>"},{"location":"api/utils/#pytvpaint.utils.HasCurrentFrame","title":"<code>HasCurrentFrame</code>","text":"<p>             Bases: <code>typing_extensions.Protocol</code></p> <p>Class that has a current frame property.</p>"},{"location":"api/utils/#pytvpaint.utils.HasCurrentFrame.current_frame","title":"<code>current_frame: int</code>  <code>property</code> <code>writable</code>","text":"<p>The current frame, clip or project.</p>"},{"location":"api/utils/#pytvpaint.utils.get_unique_name","title":"<code>get_unique_name(names: Iterable[str], stub: str) -&gt; str</code>","text":"<p>Get a unique name from a list of names and a stub prefix. It does auto increment it.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>collections.abc.Iterable[str]</code> <p>existing names</p> required <code>stub</code> <code>str</code> <p>the base name</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the stub is empty</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>a unique name with the stub prefix</p> Source code in <code>pytvpaint/utils.py</code> <pre><code>def get_unique_name(names: Iterable[str], stub: str) -&gt; str:\n    \"\"\"Get a unique name from a list of names and a stub prefix. It does auto increment it.\n\n    Args:\n        names (Iterable[str]): existing names\n        stub (str): the base name\n\n    Raises:\n        ValueError: if the stub is empty\n\n    Returns:\n        str: a unique name with the stub prefix\n    \"\"\"\n    if not stub:\n        raise ValueError(\"Stub is empty\")\n\n    number_re = re.compile(r\"(?P&lt;number&gt;\\d+)$\", re.I)\n\n    stub_without_number = number_re.sub(\"\", stub)\n    max_number = 0\n    padding_length = 1\n\n    for name in names:\n        without_number = number_re.sub(\"\", name)\n\n        if without_number != stub_without_number:\n            continue\n\n        res = number_re.search(name)\n        number = res.group(\"number\") if res else \"1\"\n\n        padding_length = max(padding_length, len(number))\n        max_number = max(max_number, int(number))\n\n    if max_number == 0:\n        return stub\n\n    next_number = max_number + 1\n    return f\"{stub_without_number}{next_number:0{padding_length}}\"\n</code></pre>"},{"location":"api/utils/#pytvpaint.utils.position_generator","title":"<code>position_generator(fn: Callable[[int], T], stop_when: type[GeorgeError] = GeorgeError) -&gt; Iterator[T]</code>","text":"<p>Utility generator that yields the result of a function according to a position.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>typing.Callable[[int], pytvpaint.utils.T]</code> <p>the function to run at each iteration</p> required <code>stop_when</code> <code>Type[pytvpaint.george.exceptions.GeorgeError]</code> <p>exception at which we stop. Defaults to GeorgeError.</p> <code>pytvpaint.george.exceptions.GeorgeError</code> <p>Yields:</p> Type Description <code>pytvpaint.utils.T</code> <p>Iterator[T]: an generator of the resulting values</p> Source code in <code>pytvpaint/utils.py</code> <pre><code>def position_generator(\n    fn: Callable[[int], T],\n    stop_when: type[GeorgeError] = GeorgeError,\n) -&gt; Iterator[T]:\n    \"\"\"Utility generator that yields the result of a function according to a position.\n\n    Args:\n        fn (Callable[[int], T]): the function to run at each iteration\n        stop_when (Type[GeorgeError], optional): exception at which we stop. Defaults to GeorgeError.\n\n    Yields:\n        Iterator[T]: an generator of the resulting values\n    \"\"\"\n    pos = 0\n\n    while True:\n        try:\n            yield fn(pos)\n        except stop_when:\n            break\n        pos += 1\n</code></pre>"},{"location":"api/utils/#pytvpaint.utils.set_as_current","title":"<code>set_as_current(func: Callable[Params, ReturnType]) -&gt; Callable[Params, ReturnType]</code>","text":"<p>Decorator to apply on object methods.</p> <p>Sets the current TVPaint object as 'current'. Useful when George functions only apply on the current project, clip, layer or scene.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>typing.Callable[pytvpaint.utils.Params, pytvpaint.utils.ReturnType]</code> <p>the method apply on</p> required <p>Returns:</p> Type Description <code>typing.Callable[pytvpaint.utils.Params, pytvpaint.utils.ReturnType]</code> <p>Callable[Params, ReturnType]: the wrapped method</p> Source code in <code>pytvpaint/utils.py</code> <pre><code>def set_as_current(func: Callable[Params, ReturnType]) -&gt; Callable[Params, ReturnType]:\n    \"\"\"Decorator to apply on object methods.\n\n    Sets the current TVPaint object as 'current'.\n    Useful when George functions only apply on the current project, clip, layer or scene.\n\n    Args:\n        func (Callable[Params, ReturnType]): the method apply on\n\n    Returns:\n        Callable[Params, ReturnType]: the wrapped method\n    \"\"\"\n\n    def wrapper(*args: Params.args, **kwargs: Params.kwargs) -&gt; ReturnType:\n        self = cast(CanMakeCurrent, args[0])\n        self.make_current()\n        return func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/utils/#pytvpaint.utils.render_context","title":"<code>render_context(alpha_mode: george.AlphaSaveMode | None = None, background_mode: george.BackgroundMode | None = None, save_format: george.SaveFormat | None = None, format_opts: list[str] | None = None, layer_selection: list[Layer] | None = None) -&gt; Generator[None, None, None]</code>","text":"<p>Context used to do renders in TVPaint.</p> <p>It does the following things:</p> <ul> <li>Set the alpha mode and save format (with custom options)</li> <li>Hide / Show the given layers (some render functions only render by visibility)</li> <li>Restore the previous values after rendering</li> </ul> <p>Parameters:</p> Name Type Description Default <code>alpha_mode</code> <code>pytvpaint.george.AlphaSaveMode | None</code> <p>the render alpha save mode</p> <code>None</code> <code>save_format</code> <code>pytvpaint.george.SaveFormat | None</code> <p>the render format to use. Defaults to None.</p> <code>None</code> <code>background_mode</code> <code>pytvpaint.george.BackgroundMode | None</code> <p>the render background mode</p> <code>None</code> <code>format_opts</code> <code>list[str] | None</code> <p>the custom format options as strings. Defaults to None.</p> <code>None</code> <code>layer_selection</code> <code>list[pytvpaint.layer.Layer] | None</code> <p>the layers to render. Defaults to None.</p> <code>None</code> Source code in <code>pytvpaint/utils.py</code> <pre><code>@contextlib.contextmanager\ndef render_context(\n    alpha_mode: george.AlphaSaveMode | None = None,\n    background_mode: george.BackgroundMode | None = None,\n    save_format: george.SaveFormat | None = None,\n    format_opts: list[str] | None = None,\n    layer_selection: list[Layer] | None = None,\n) -&gt; Generator[None, None, None]:\n    \"\"\"Context used to do renders in TVPaint.\n\n    It does the following things:\n\n    - Set the alpha mode and save format (with custom options)\n    - Hide / Show the given layers (some render functions only render by visibility)\n    - Restore the previous values after rendering\n\n    Args:\n        alpha_mode: the render alpha save mode\n        save_format: the render format to use. Defaults to None.\n        background_mode: the render background mode\n        format_opts: the custom format options as strings. Defaults to None.\n        layer_selection: the layers to render. Defaults to None.\n    \"\"\"\n    from pytvpaint.clip import Clip\n\n    # Save the current state\n    pre_alpha_save_mode = george.tv_alpha_save_mode_get()\n    pre_save_format, pre_save_args = george.tv_save_mode_get()\n    pre_background_mode, pre_background_colors = george.tv_background_get()\n\n    # Set the save mode values\n    if alpha_mode:\n        george.tv_alpha_save_mode_set(alpha_mode)\n    if background_mode:\n        george.tv_background_set(background_mode)\n    if save_format:\n        george.tv_save_mode_set(save_format, *(format_opts or []))\n\n    layers_visibility = []\n    if layer_selection:\n        clip = Clip.current_clip()\n        layers_visibility = [(layer, layer.is_visible) for layer in clip.layers]\n        # Show and hide the clip layers to render\n        for layer, _ in layers_visibility:\n            should_be_visible = not layer_selection or layer in layer_selection\n            layer.is_visible = should_be_visible\n\n    # Do the render\n    yield\n\n    # Restore the previous values\n    if alpha_mode:\n        george.tv_alpha_save_mode_set(pre_alpha_save_mode)\n    if save_format:\n        george.tv_save_mode_set(pre_save_format, *pre_save_args)\n    if background_mode:\n        george.tv_background_set(pre_background_mode, pre_background_colors)\n\n    # Restore the layer visibility\n    if layers_visibility:\n        for layer, was_visible in layers_visibility:\n            layer.is_visible = was_visible\n</code></pre>"},{"location":"api/utils/#pytvpaint.utils.restore_current_frame","title":"<code>restore_current_frame(tvp_element: HasCurrentFrame, frame: int) -&gt; Generator[None, None, None]</code>","text":"<p>Context that temporarily changes the current frame to the one provided and restores it when done.</p> <p>Parameters:</p> Name Type Description Default <code>tvp_element</code> <code>pytvpaint.utils.HasCurrentFrame</code> <p>clip to change</p> required <code>frame</code> <code>int</code> <p>frame to set. Defaults to None.</p> required Source code in <code>pytvpaint/utils.py</code> <pre><code>@contextlib.contextmanager\ndef restore_current_frame(\n    tvp_element: HasCurrentFrame, frame: int\n) -&gt; Generator[None, None, None]:\n    \"\"\"Context that temporarily changes the current frame to the one provided and restores it when done.\n\n    Args:\n        tvp_element: clip to change\n        frame: frame to set. Defaults to None.\n    \"\"\"\n    previous_frame = tvp_element.current_frame\n\n    if frame != previous_frame:\n        tvp_element.current_frame = frame\n\n    yield\n\n    if tvp_element.current_frame != previous_frame:\n        tvp_element.current_frame = previous_frame\n</code></pre>"},{"location":"api/utils/#pytvpaint.utils.get_tvp_element","title":"<code>get_tvp_element(tvp_elements: Iterator[TVPElementType], by_id: int | str | None = None, by_name: str | None = None, by_path: str | Path | None = None) -&gt; TVPElementType | None</code>","text":"<p>Search for a TVPaint element by attributes.</p> <p>Parameters:</p> Name Type Description Default <code>tvp_elements</code> <code>collections.abc.Iterator[pytvpaint.utils.TVPElementType]</code> <p>a collection of TVPaint objects</p> required <code>by_id</code> <code>int | str | None</code> <p>search by id. Defaults to None.</p> <code>None</code> <code>by_name</code> <code>str | None</code> <p>search by name, search is case-insensitive. Defaults to None.</p> <code>None</code> <code>by_path</code> <code>str | pathlib.Path | None</code> <p>search by path. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if bad arguments were given</p> <p>Returns:</p> Type Description <code>pytvpaint.utils.TVPElementType | None</code> <p>TVPElementType | None: the found element</p> Source code in <code>pytvpaint/utils.py</code> <pre><code>def get_tvp_element(\n    tvp_elements: Iterator[TVPElementType],\n    by_id: int | str | None = None,\n    by_name: str | None = None,\n    by_path: str | Path | None = None,\n) -&gt; TVPElementType | None:\n    \"\"\"Search for a TVPaint element by attributes.\n\n    Args:\n        tvp_elements: a collection of TVPaint objects\n        by_id: search by id. Defaults to None.\n        by_name: search by name, search is case-insensitive. Defaults to None.\n        by_path: search by path. Defaults to None.\n\n    Raises:\n        ValueError: if bad arguments were given\n\n    Returns:\n        TVPElementType | None: the found element\n    \"\"\"\n    if by_id is None and by_name is None:\n        raise ValueError(\n            \"At least one of the values (id or name) must be provided, none found !\"\n        )\n\n    for element in tvp_elements:\n        if by_id is not None and element.id != by_id:\n            continue\n        if by_name is not None and element.name.lower() != by_name.lower():\n            continue\n        if by_path is not None and getattr(element, \"path\") != Path(by_path):\n            continue\n        return element\n\n    return None\n</code></pre>"},{"location":"api/utils/#pytvpaint.utils.handle_output_range","title":"<code>handle_output_range(output_path: Path | str | FileSequence, default_start: int, default_end: int, start: int | None = None, end: int | None = None) -&gt; tuple[FileSequence, int, int, bool, bool]</code>","text":"<p>Handle the different options for output paths and range.</p> <p>Whether the user provides a range (start-end) or a filesequence with a range or not, this functions ensures we always end up with a valid range to render</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>pathlib.Path | str | fileseq.filesequence.FileSequence</code> <p>user provided output path</p> required <code>default_start</code> <code>int</code> <p>the default start to use if none provided or found in the file sequence object</p> required <code>default_end</code> <code>int</code> <p>the default end to use if none provided or found in the file sequence object</p> required <code>start</code> <code>int | None</code> <p>user provided start frame or None</p> <code>None</code> <code>end</code> <code>int | None</code> <p>user provided end frame or None</p> <code>None</code> <p>Returns:</p> Name Type Description <code>file_sequence</code> <code>fileseq.filesequence.FileSequence</code> <p>output path as a FileSequence object</p> <code>start</code> <code>int</code> <p>computed start frame</p> <code>end</code> <code>int</code> <p>computed end frame</p> <code>is_sequence</code> <code>bool</code> <p>whether the output is a sequence or not</p> <code>is_image</code> <code>bool</code> <p>whether the output is an image or not (a movie)</p> Source code in <code>pytvpaint/utils.py</code> <pre><code>def handle_output_range(\n    output_path: Path | str | FileSequence,\n    default_start: int,\n    default_end: int,\n    start: int | None = None,\n    end: int | None = None,\n) -&gt; tuple[FileSequence, int, int, bool, bool]:\n    \"\"\"Handle the different options for output paths and range.\n\n    Whether the user provides a range (start-end) or a filesequence with a range or not, this functions ensures we\n    always end up with a valid range to render\n\n    Args:\n        output_path: user provided output path\n        default_start: the default start to use if none provided or found in the file sequence object\n        default_end: the default end to use if none provided or found in the file sequence object\n        start: user provided start frame or None\n        end: user provided end frame or None\n\n    Returns:\n        file_sequence: output path as a FileSequence object\n        start: computed start frame\n        end: computed end frame\n        is_sequence: whether the output is a sequence or not\n        is_image: whether the output is an image or not (a movie)\n    \"\"\"\n    # we handle all outputs as a FileSequence, makes it a bit easier to handle ranges and padding\n    if not isinstance(output_path, FileSequence):\n        file_sequence = FileSequence(Path(output_path).as_posix())\n    else:\n        file_sequence = output_path\n\n    frame_set = file_sequence.frameSet()\n    is_image = george.SaveFormat.is_image(file_sequence.extension())\n\n    # if the provided sequence has a range, and we don't, use the sequence range\n    if frame_set and len(frame_set) &gt;= 1 and is_image:\n        start = start or file_sequence.start()\n        end = end or file_sequence.end()\n\n    # check characteristics of file sequence\n    fseq_has_range = frame_set and len(frame_set) &gt; 1\n    fseq_is_single_image = frame_set and len(frame_set) == 1\n    fseq_no_range_padding = not frame_set and file_sequence.padding()\n    range_is_seq = start is not None and end is not None and start != end\n    range_is_single_image = start is not None and end is not None and start == end\n\n    is_single_image = bool(\n        is_image and (fseq_is_single_image or not frame_set) and range_is_single_image\n    )\n    is_sequence = bool(\n        is_image and (fseq_has_range or fseq_no_range_padding or range_is_seq)\n    )\n\n    # if no range provided, use clip mark in/out, if none, use clip start/end\n    if start is None:\n        start = default_start\n    if is_single_image and not end:\n        end = start\n    else:\n        if end is None:\n            end = default_end\n\n    frame_set = FrameSet(f\"{start}-{end}\")\n\n    if not file_sequence.padding() and is_image and len(frame_set) &gt; 1:\n        file_sequence.setPadding(\"#\")\n\n    # we should have a range by now, set it in the sequence\n    if (is_image and not is_single_image) or file_sequence.padding():\n        file_sequence.setFrameSet(frame_set)\n\n    return file_sequence, start, end, is_sequence, is_image\n</code></pre>"},{"location":"api/client/communication/","title":"Communication","text":"<p>This modules handles the WebSocket client and automatically connect to the server running in TVPaint.</p> <p>It also has crucial functions like <code>send_cmd</code> that send George commands and get the result.</p>"},{"location":"api/client/communication/#pytvpaint.george.client.try_cmd","title":"<code>try_cmd(raise_exc: type[Exception] = GeorgeError, catch_exc: type[Exception] = GeorgeError, exception_msg: str | None = None) -&gt; Callable[[T], T]</code>","text":"<p>Decorator that does a try/except with GeorgeError by default.</p> <p>It raises the error with the custom exception message provided.</p> <p>Parameters:</p> Name Type Description Default <code>raise_exc</code> <code>type[Exception]</code> <p>the exception to raise. Defaults to GeorgeError.</p> <code>pytvpaint.george.exceptions.GeorgeError</code> <code>catch_exc</code> <code>type[Exception]</code> <p>the exception to catch. Defaults to GeorgeError.</p> <code>pytvpaint.george.exceptions.GeorgeError</code> <code>exception_msg</code> <code>str | None</code> <p>Custom exception message. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>typing.Callable[[pytvpaint.george.client.T], pytvpaint.george.client.T]</code> <p>the decorated function</p> Source code in <code>pytvpaint/george/client/__init__.py</code> <pre><code>def try_cmd(\n    raise_exc: type[Exception] = GeorgeError,\n    catch_exc: type[Exception] = GeorgeError,\n    exception_msg: str | None = None,\n) -&gt; Callable[[T], T]:\n    \"\"\"Decorator that does a try/except with GeorgeError by default.\n\n    It raises the error with the custom exception message provided.\n\n    Args:\n        raise_exc: the exception to raise. Defaults to GeorgeError.\n        catch_exc: the exception to catch. Defaults to GeorgeError.\n        exception_msg: Custom exception message. Defaults to None.\n\n    Returns:\n        the decorated function\n    \"\"\"\n\n    def decorate(func: T) -&gt; T:\n        @functools.wraps(func)\n        def applicator(*args: Any, **kwargs: Any) -&gt; Any:\n            try:\n                return func(*args, **kwargs)\n            except catch_exc as e:\n                raise raise_exc(exception_msg or e)\n\n        return cast(T, applicator)\n\n    return decorate\n</code></pre>"},{"location":"api/client/communication/#pytvpaint.george.client.send_cmd","title":"<code>send_cmd(command: str, *args: Any, error_values: list[Any] | None = None, handle_string: bool = True) -&gt; str</code>","text":"<p>Send a George command with the provided arguments to TVPaint.</p> <p>Catch basic <code>ERROR XX</code> errors returned from George, but you can provide your own error values.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>the George command to send</p> required <code>*args</code> <code>typing.Any</code> <p>pass any arguments you want to that function</p> <code>()</code> <code>error_values</code> <code>list[typing.Any] | None</code> <p>a list of error values to catch from George. Defaults to None.</p> <code>None</code> <code>handle_string</code> <code>bool</code> <p>control the quote wrapping of string with spaces. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if we received <code>ERROR XX</code> or any of the custom error codes</p> <p>Returns:</p> Type Description <code>str</code> <p>the George return string</p> Source code in <code>pytvpaint/george/client/__init__.py</code> <pre><code>def send_cmd(\n    command: str,\n    *args: Any,\n    error_values: list[Any] | None = None,\n    handle_string: bool = True,\n) -&gt; str:\n    \"\"\"Send a George command with the provided arguments to TVPaint.\n\n    Catch basic `ERROR XX` errors returned from George, but you can provide your own error values.\n\n    Args:\n        command: the George command to send\n        *args: pass any arguments you want to that function\n        error_values: a list of error values to catch from George. Defaults to None.\n        handle_string: control the quote wrapping of string with spaces. Defaults to True.\n\n    Raises:\n        GeorgeError: if we received `ERROR XX` or any of the custom error codes\n\n    Returns:\n        the George return string\n    \"\"\"\n    tv_args = [\n        tv_handle_string(arg) if handle_string and isinstance(arg, str) else arg\n        for arg in args\n    ]\n    cmd_str = \" \".join([str(arg) for arg in [command, *tv_args]])\n\n    is_undo_stack = command in [\n        \"tv_UndoOpenStack\",\n        \"tv_UpdateUndo\",\n        \"tv_UndoCloseStack\",\n    ]\n\n    if not is_undo_stack:\n        log.debug(f\"[RPC] &gt;&gt; {cmd_str}\")\n\n    response = rpc_client.execute_remote(\"execute_george\", [cmd_str])\n    result = response[\"result\"]\n\n    if not is_undo_stack:\n        log.debug(f\"[RPC] &lt;&lt; {result}\")\n\n    # Test for basic ERROR X values and user provided custom errors\n    res_in_error_values = error_values and result in list(map(str, error_values))\n    if res_in_error_values or re.match(r\"ERROR -?\\d+\", result, re.IGNORECASE):\n        msg = f\"Received value: '{result}' considered as an error\"\n        raise GeorgeError(msg, error_value=result)\n\n    return result\n</code></pre>"},{"location":"api/client/communication/#pytvpaint.george.client.run_script","title":"<code>run_script(script: Path | str) -&gt; None</code>","text":"<p>Execute a George script from a .grg file.</p> <p>Parameters:</p> Name Type Description Default <code>script</code> <code>pathlib.Path | str</code> <p>the path to the script</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the script was not found</p> Source code in <code>pytvpaint/george/client/__init__.py</code> <pre><code>def run_script(script: Path | str) -&gt; None:\n    \"\"\"Execute a George script from a .grg file.\n\n    Args:\n        script: the path to the script\n\n    Raises:\n        ValueError: if the script was not found\n    \"\"\"\n    script = Path(script)\n    if not script.exists():\n        raise ValueError(f\"Script not found at : {script.as_posix()}\")\n    send_cmd(\"tv_RunScript\", script.as_posix())\n</code></pre>"},{"location":"api/client/parsing/","title":"George parsing utilities","text":"<p>Parsing functions used to handle data coming from TVPaint and also preparing arguments for them to be sent.</p> <p>The two main functions are <code>tv_parse_dict</code> and <code>tv_parse_list</code> which handle the return values of George functions.</p> <p>George can either return a list of values or a list of key/value pairs which are consecutive.</p>"},{"location":"api/client/parsing/#pytvpaint.george.client.parse.DataclassInstance","title":"<code>DataclassInstance</code>","text":"<p>             Bases: <code>typing_extensions.Protocol</code></p> <p>Protocol that describes a Dataclass instance.</p>"},{"location":"api/client/parsing/#pytvpaint.george.client.parse.tv_handle_string","title":"<code>tv_handle_string(s: str) -&gt; str</code>","text":"<p>String handling for George arguments. It wraps the string into quotes if it has spaces.</p> <p>See an example here: https://www.tvpaint.com/doc/tvpaint-animation-11/george-commands#tv_projectnew</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the input string</p> required <p>Returns:</p> Type Description <code>str</code> <p>the \"escaped\" string</p> Source code in <code>pytvpaint/george/client/parse.py</code> <pre><code>def tv_handle_string(s: str) -&gt; str:\n    \"\"\"String handling for George arguments. It wraps the string into quotes if it has spaces.\n\n    See an example here: https://www.tvpaint.com/doc/tvpaint-animation-11/george-commands#tv_projectnew\n\n    Args:\n        s (str): the input string\n\n    Returns:\n        the \"escaped\" string\n    \"\"\"\n    if \" \" in s:\n        return f'\"{s}\"'\n\n    return s\n</code></pre>"},{"location":"api/client/parsing/#pytvpaint.george.client.parse.camel_to_pascal","title":"<code>camel_to_pascal(s: str) -&gt; str</code>","text":"<p>Convert a camel case string to pascal case.</p> Example <p><code>this_is_a_text -&gt; ThisIsAText</code></p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the input string</p> required <p>Returns:</p> Type Description <code>str</code> <p>the string in pascal case</p> Source code in <code>pytvpaint/george/client/parse.py</code> <pre><code>def camel_to_pascal(s: str) -&gt; str:\n    \"\"\"Convert a camel case string to pascal case.\n\n    Example:\n        `this_is_a_text -&gt; ThisIsAText`\n\n    Args:\n        s: the input string\n\n    Returns:\n        the string in pascal case\n    \"\"\"\n    return \"\".join([c.capitalize() for c in s.split(\"_\")])\n</code></pre>"},{"location":"api/client/parsing/#pytvpaint.george.client.parse.tv_cast_to_type","title":"<code>tv_cast_to_type(value: str, cast_type: type[T]) -&gt; T</code>","text":"<p>Cast a value to the provided type using George's convention for values.</p> Note <p>\"1\" and \"on\"/\"ON\" values are considered True when parsing a boolean</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>the input value</p> required <code>cast_type</code> <code>type[pytvpaint.george.client.parse.T]</code> <p>the type to cast to</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if given an enum, and it can't find the value or the enum index is invalid</p> <p>Returns:</p> Type Description <code>pytvpaint.george.client.parse.T</code> <p>the value cast to the provided type</p> Source code in <code>pytvpaint/george/client/parse.py</code> <pre><code>def tv_cast_to_type(value: str, cast_type: type[T]) -&gt; T:\n    \"\"\"Cast a value to the provided type using George's convention for values.\n\n    Note:\n        \"1\" and \"on\"/\"ON\" values are considered True when parsing a boolean\n\n    Args:\n        value: the input value\n        cast_type: the type to cast to\n\n    Raises:\n        ValueError: if given an enum, and it can't find the value or the enum index is invalid\n\n    Returns:\n        the value cast to the provided type\n    \"\"\"\n    if issubclass(cast_type, Enum):\n        value = value.strip().strip('\"')\n\n        # Find all enum members that matches the value (lower case)\n        matches = [m for m in cast_type if value.lower() == m.value.lower()]\n        try:\n            # If the unmodified value is in the enum, return that first\n            return cast(T, next(m for m in matches if value == m.value))\n        except StopIteration:\n            # Otherwise return the first match\n            if matches:\n                return cast(T, matches[0])\n\n        # It didn't work, it can be the enum index\n        try:\n            index = int(value)\n        except ValueError:\n            raise ValueError(\n                f\"{value} is not a valid Enum index since it can't be parsed as int\"\n            )\n\n        # We get the enum member at that index\n        enum_members = list(cast_type)\n        if index &lt; len(enum_members):\n            return cast(T, enum_members[index])\n\n        raise ValueError(\n            f\"Enum index {index} is out of bounds (max {len(enum_members) - 1})\"\n        )\n\n    if get_origin(cast_type) is tuple:\n        # Split by space and convert each member to the right type\n        values_types = zip(value.split(\" \"), get_args(cast_type))\n        return cast(T, tuple(tv_cast_to_type(v, t) for v, t in values_types))\n\n    if cast_type == bool:\n        return cast(T, value.lower() in [\"1\", \"on\", \"true\"])\n\n    if cast_type == str:\n        return cast(T, value.strip().strip('\"'))\n\n    return cast(T, cast_type(value))\n</code></pre>"},{"location":"api/client/parsing/#pytvpaint.george.client.parse.tv_parse_dict","title":"<code>tv_parse_dict(input_text: str, with_fields: FieldTypes | type[DataclassInstance]) -&gt; dict[str, Any]</code>","text":"<p>Parse a list of values as key value pairs returned from TVPaint commands.</p> <p>Cast the values to a provided dataclass type or list of key/types pairs.</p> <p>Parameters:</p> Name Type Description Default <code>input_text</code> <code>str</code> <p>the George string result</p> required <code>with_fields</code> <code>pytvpaint.george.client.parse.FieldTypes | type[pytvpaint.george.client.parse.DataclassInstance]</code> <p>the field types (can be a dataclass)</p> required <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>a dict with the values cast to the given types</p> Source code in <code>pytvpaint/george/client/parse.py</code> <pre><code>def tv_parse_dict(\n    input_text: str,\n    with_fields: FieldTypes | type[DataclassInstance],\n) -&gt; dict[str, Any]:\n    \"\"\"Parse a list of values as key value pairs returned from TVPaint commands.\n\n    Cast the values to a provided dataclass type or list of key/types pairs.\n\n    Args:\n        input_text: the George string result\n        with_fields: the field types (can be a dataclass)\n\n    Returns:\n        a dict with the values cast to the given types\n    \"\"\"\n    # For dataclasses get the type hints and filter those with metadata\n    if is_dataclass(with_fields):\n        with_fields = _get_dataclass_fields(with_fields)\n    else:\n        # Explicitly cast because we are sure now\n        with_fields = cast(FieldTypes, with_fields)\n\n    output_dict: dict[str, Any] = {}\n    search_start = 0\n\n    for i, (field_name, field_type) in enumerate(with_fields):\n        current_key_pascal = camel_to_pascal(field_name)\n\n        # Search for the key from the end\n        search_text = input_text.lower()\n        try:\n            start = search_text.index(current_key_pascal.lower(), search_start)\n        except ValueError:\n            continue\n\n        if i &lt; (len(with_fields) - 1):\n            # Search for the next key also from the end\n            next_key_pascal = camel_to_pascal(with_fields[i + 1][0])\n            end = search_text.rfind(\" \" + next_key_pascal.lower(), search_start)\n        else:\n            end = len(input_text)\n\n        # Get the \"key value\" substring\n        key_value = input_text[start:end]\n\n        # Extract the value\n        cut_at = len(current_key_pascal) + 1\n        value = key_value[cut_at:].strip()\n\n        # Cast it to the corresponding type\n        value = tv_cast_to_type(value, field_type)\n\n        output_dict[field_name] = value\n        search_start = end\n\n    return output_dict\n</code></pre>"},{"location":"api/client/parsing/#pytvpaint.george.client.parse.tv_parse_list","title":"<code>tv_parse_list(output: str, with_fields: FieldTypes | type[DataclassInstance], unused_indices: list[int] | None = None) -&gt; dict[str, Any]</code>","text":"<p>Parse a list of values returned from TVPaint commands.</p> <p>Cast the values to a provided dataclass type or list of key/types pairs.</p> <p>You can specify unused indices to exclude positional values from being parsed. This is useful because some George commands have unused return values.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>the input string</p> required <code>with_fields</code> <code>pytvpaint.george.client.parse.FieldTypes | type[pytvpaint.george.client.parse.DataclassInstance]</code> <p>the field types (can be a dataclass)</p> required <code>unused_indices</code> <code>list[int] | None</code> <p>Some George functions return positional arguments that are unused. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>a dict with the values cast to the given types</p> Source code in <code>pytvpaint/george/client/parse.py</code> <pre><code>def tv_parse_list(\n    output: str,\n    with_fields: FieldTypes | type[DataclassInstance],\n    unused_indices: list[int] | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Parse a list of values returned from TVPaint commands.\n\n    Cast the values to a provided dataclass type or list of key/types pairs.\n\n    You can specify unused indices to exclude positional values from being parsed.\n    This is useful because some George commands have unused return values.\n\n    Args:\n        output: the input string\n        with_fields: the field types (can be a dataclass)\n        unused_indices: Some George functions return positional arguments that are unused. Defaults to None.\n\n    Returns:\n        a dict with the values cast to the given types\n    \"\"\"\n    start = 0\n    current = 0\n    string_open = False\n    tokens: list[str] = []\n\n    while current &lt; len(output):\n        char = output[current]\n        is_quote = char == '\"'\n        is_space = char == \" \"\n        last_char = current == len(output) - 1\n\n        if (is_space and not string_open) or last_char:\n            last_cut = current if not last_char else current + 1\n            token = output[start:last_cut]\n            if start != last_cut and token != \" \":\n                tokens.append(token)\n            start = current = current + 1\n        elif is_quote:\n            if string_open:\n                tokens.append(output[start:current])\n\n            start = current = current + 1\n            string_open = not string_open\n        else:\n            current += 1\n\n    # Get type annotations from the dataclass fields\n    if is_dataclass(with_fields):\n        with_fields = _get_dataclass_fields(with_fields)\n    else:\n        # Explicitly cast because we are sure now\n        with_fields = cast(FieldTypes, with_fields)\n\n    # Remove any unused values\n    if unused_indices:\n        tokens = [t for i, t in enumerate(tokens) if i not in unused_indices]\n\n    # Cast each token to a type and construct the dict\n    tokens_dict: dict[str, Any] = {}\n    for token, (field_name, field_type) in zip(tokens, with_fields):\n        token = tv_cast_to_type(token, field_type)\n        tokens_dict[field_name] = token\n\n    return tokens_dict\n</code></pre>"},{"location":"api/client/parsing/#pytvpaint.george.client.parse.args_dict_to_list","title":"<code>args_dict_to_list(args: dict[str, Any]) -&gt; list[Any]</code>","text":"<p>Converts a dict of named arguments to a flat list of key/values.</p> <p>It also filters pairs with None values</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>dict[str, typing.Any]</code> <p>dict of arguments</p> required <p>Returns:</p> Type Description <code>list[typing.Any]</code> <p>key/values list</p> Source code in <code>pytvpaint/george/client/parse.py</code> <pre><code>def args_dict_to_list(args: dict[str, Any]) -&gt; list[Any]:\n    \"\"\"Converts a dict of named arguments to a flat list of key/values.\n\n    It also filters pairs with None values\n\n    Args:\n        args: dict of arguments\n\n    Returns:\n        key/values list\n    \"\"\"\n    args_filter = {k: v for k, v in args.items() if v is not None}\n    # Flatten dictionnary key value pairs with zip\n    return [item for kv in args_filter.items() for item in kv]\n</code></pre>"},{"location":"api/client/parsing/#pytvpaint.george.client.parse.validate_args_list","title":"<code>validate_args_list(optional_args: Sequence[Value | tuple[Value, ...]]) -&gt; list[Any]</code>","text":"<p>Some George functions only accept a list of values and not key:value pairs, so to set the last positional argument for instance, you need to give all the previous ones.</p> <p>This function allows you to give a list of argument or key:value pairs (as tuples) and check that they are not None.</p> <p>For example, for <code>tv_camerainfo [&lt;iWidth&gt; &lt;iHeight&gt; [&lt;field_order&gt;]]</code> you can't give <code>[500, None, \"upper\"]</code> because <code>&lt;iHeight&gt;</code> is not defined.</p> <p>Parameters:</p> Name Type Description Default <code>optional_args</code> <code>collections.abc.Sequence[pytvpaint.george.client.parse.Value | tuple[pytvpaint.george.client.parse.Value, ...]]</code> <p>list of values or tuple of values (args block)</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if not all the parameters were given</p> <p>Returns:</p> Type Description <code>list[typing.Any]</code> <p>the list of parameters</p> Source code in <code>pytvpaint/george/client/parse.py</code> <pre><code>def validate_args_list(optional_args: Sequence[Value | tuple[Value, ...]]) -&gt; list[Any]:\n    \"\"\"Some George functions only accept a list of values and not key:value pairs, so to set the last positional argument for instance, you need to give all the previous ones.\n\n    This function allows you to give a list of argument or key:value pairs (as tuples) and check that they are not None.\n\n    For example, for `tv_camerainfo [&lt;iWidth&gt; &lt;iHeight&gt; [&lt;field_order&gt;]]`\n    you can't give `[500, None, \"upper\"]` because `&lt;iHeight&gt;` is not defined.\n\n    Args:\n        optional_args: list of values or tuple of values (args block)\n\n    Raises:\n        ValueError: if not all the parameters were given\n\n    Returns:\n        the list of parameters\n    \"\"\"\n    args: list[Any] = []\n\n    for arg in optional_args:\n        if arg is None or (isinstance(arg, tuple) and all(a is None for a in arg)):\n            break\n\n        # If it's a tuple they need to be defined\n        if isinstance(arg, tuple):\n            if any(a is None for a in arg):\n                raise ValueError(f\"You must pass all the parameters: {arg}\")\n            args.extend(arg)\n        else:\n            args.append(arg)\n\n    return args\n</code></pre>"},{"location":"api/client/rpc/","title":"JSON-RPC","text":"<p>JSON-RPC client and data models.</p>"},{"location":"api/client/rpc/#pytvpaint.george.client.rpc.JSONRPCPayload","title":"<code>JSONRPCPayload</code>","text":"<p>             Bases: <code>typing_extensions.TypedDict</code></p> <p>A rpc call is represented by sending a Request object to a Server.</p> <p>See: https://www.jsonrpc.org/specification#request_object</p>"},{"location":"api/client/rpc/#pytvpaint.george.client.rpc.JSONRPCResponse","title":"<code>JSONRPCResponse</code>","text":"<p>             Bases: <code>typing_extensions.TypedDict</code></p> <p>When a rpc call is made, the Server MUST reply with a Response.</p> <p>See: https://www.jsonrpc.org/specification#response_object</p>"},{"location":"api/client/rpc/#pytvpaint.george.client.rpc.JSONRPCError","title":"<code>JSONRPCError</code>","text":"<p>             Bases: <code>typing_extensions.TypedDict</code></p> <p>When a rpc call encounters an error.</p> <p>See: https://www.jsonrpc.org/specification#error_object</p>"},{"location":"api/client/rpc/#pytvpaint.george.client.rpc.JSONRPCResponseError","title":"<code>JSONRPCResponseError(error: JSONRPCError)</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception used when a rpc call encounters an error.</p> Source code in <code>pytvpaint/george/client/rpc.py</code> <pre><code>def __init__(self, error: JSONRPCError) -&gt; None:\n    super().__init__(f\"JSON-RPC Server error ({error['code']}): {error['message']}\")\n</code></pre>"},{"location":"api/client/rpc/#pytvpaint.george.client.rpc.JSONRPCClient","title":"<code>JSONRPCClient(url: str, timeout: int = 60, version: str = '2.0')</code>","text":"<p>Simple JSON-RPC 2.0 client over websockets with automatic reconnection.</p> <p>See: https://www.jsonrpc.org/specification#notification</p> <p>Initialize a new JSON-RPC client with a WebSocket url endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>the WebSocket url endpoint</p> required <code>timeout</code> <code>int</code> <p>the reconnection timeout</p> <code>60</code> <code>version</code> <code>str</code> <p>The JSON-RPC version. Defaults to \"2.0\".</p> <code>'2.0'</code> Source code in <code>pytvpaint/george/client/rpc.py</code> <pre><code>def __init__(self, url: str, timeout: int = 60, version: str = \"2.0\") -&gt; None:\n    \"\"\"Initialize a new JSON-RPC client with a WebSocket url endpoint.\n\n    Args:\n        url: the WebSocket url endpoint\n        timeout: the reconnection timeout\n        version: The JSON-RPC version. Defaults to \"2.0\".\n    \"\"\"\n    self.ws_handle = WebSocket()\n    self.url = url\n    self.rpc_id = 0\n    self.timeout = timeout\n    self.jsonrpc_version = version\n\n    self.stop_ping = threading.Event()\n    self.run_forever = False\n    self.ping_thread: threading.Thread | None = None\n    self._ping_start_time: float = 0\n</code></pre>"},{"location":"api/client/rpc/#pytvpaint.george.client.rpc.JSONRPCClient.is_connected","title":"<code>is_connected: bool</code>  <code>property</code>","text":"<p>Returns True if the client is connected.</p>"},{"location":"api/client/rpc/#pytvpaint.george.client.rpc.JSONRPCClient.connect","title":"<code>connect(timeout: float | None = None) -&gt; None</code>","text":"<p>Connects to the WebSocket endpoint.</p> Source code in <code>pytvpaint/george/client/rpc.py</code> <pre><code>def connect(self, timeout: float | None = None) -&gt; None:\n    \"\"\"Connects to the WebSocket endpoint.\"\"\"\n    self.ws_handle.connect(self.url, timeout=timeout)\n\n    if not self.ping_thread:\n        self._ping_start_time = time()\n        self.ping_thread = threading.Thread(\n            target=self._auto_reconnect, daemon=True\n        )\n        self.run_forever = True\n        self.ping_thread.start()\n</code></pre>"},{"location":"api/client/rpc/#pytvpaint.george.client.rpc.JSONRPCClient.disconnect","title":"<code>disconnect() -&gt; None</code>","text":"<p>Disconnects from the server.</p> Source code in <code>pytvpaint/george/client/rpc.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnects from the server.\"\"\"\n    self.run_forever = False\n    if self.ping_thread:\n        self.ping_thread.join()\n\n    self.ws_handle.close()\n</code></pre>"},{"location":"api/client/rpc/#pytvpaint.george.client.rpc.JSONRPCClient.increment_rpc_id","title":"<code>increment_rpc_id() -&gt; None</code>","text":"<p>Increments the internal RPC id until it reaches <code>sys.maxsize</code>.</p> Source code in <code>pytvpaint/george/client/rpc.py</code> <pre><code>def increment_rpc_id(self) -&gt; None:\n    \"\"\"Increments the internal RPC id until it reaches `sys.maxsize`.\"\"\"\n    self.rpc_id = (self.rpc_id + 1) % sys.maxsize\n</code></pre>"},{"location":"api/client/rpc/#pytvpaint.george.client.rpc.JSONRPCClient.execute_remote","title":"<code>execute_remote(method: str, params: list[JSONValueType] | None = None) -&gt; JSONRPCResponse</code>","text":"<p>Executes a remote procedure call.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>the name of the method to be invoked</p> required <code>params</code> <code>list[pytvpaint.george.client.rpc.JSONValueType] | None</code> <p>the parameter values to be used during the invocation of the method. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>if the client is not connected</p> <code>pytvpaint.george.client.rpc.JSONRPCResponseError</code> <p>if there was an error server-side</p> <p>Returns:</p> Name Type Description <code>JSONRPCResponse</code> <code>pytvpaint.george.client.rpc.JSONRPCResponse</code> <p>the JSON-RPC response payload</p> Source code in <code>pytvpaint/george/client/rpc.py</code> <pre><code>def execute_remote(\n    self,\n    method: str,\n    params: list[JSONValueType] | None = None,\n) -&gt; JSONRPCResponse:\n    \"\"\"Executes a remote procedure call.\n\n    Args:\n        method: the name of the method to be invoked\n        params: the parameter values to be used during the invocation of the method. Defaults to None.\n\n    Raises:\n        ConnectionError: if the client is not connected\n        JSONRPCResponseError: if there was an error server-side\n\n    Returns:\n        JSONRPCResponse: the JSON-RPC response payload\n    \"\"\"\n    if not self.is_connected:\n        raise ConnectionError(\n            f\"Can't send rpc message because the client is not connected to {self.url}\"\n        )\n\n    payload: JSONRPCPayload = {\n        \"jsonrpc\": self.jsonrpc_version,\n        \"id\": self.rpc_id,\n        \"method\": method,\n        \"params\": params or [],\n    }\n\n    self.ws_handle.send(json.dumps(payload))\n    self.increment_rpc_id()\n\n    result = self.ws_handle.recv()\n    response = cast(JSONRPCResponse, json.loads(result))\n\n    if \"error\" in response:\n        raise JSONRPCResponseError(response[\"error\"])\n\n    return response\n</code></pre>"},{"location":"api/george/camera/","title":"Camera related George functions","text":"<p>Camera related George functions.</p>"},{"location":"api/george/camera/#pytvpaint.george.grg_camera.TVPCamera","title":"<code>TVPCamera(width: int, height: int, field_order: FieldOrder, frame_rate: float, pixel_aspect_ratio: float, anti_aliasing: int)</code>  <code>dataclass</code>","text":"<p>TVPaint camera info values.</p>"},{"location":"api/george/camera/#pytvpaint.george.grg_camera.TVPCameraPoint","title":"<code>TVPCameraPoint(x: float, y: float, angle: float, scale: float)</code>  <code>dataclass</code>","text":"<p>camera 2D point info.</p>"},{"location":"api/george/camera/#pytvpaint.george.grg_camera.tv_camera_info_get","title":"<code>tv_camera_info_get() -&gt; TVPCamera</code>","text":"<p>Get the information of the camera.</p> Source code in <code>pytvpaint/george/grg_camera.py</code> <pre><code>def tv_camera_info_get() -&gt; TVPCamera:\n    \"\"\"Get the information of the camera.\"\"\"\n    return TVPCamera(**tv_parse_list(send_cmd(\"tv_CameraInfo\"), with_fields=TVPCamera))\n</code></pre>"},{"location":"api/george/camera/#pytvpaint.george.grg_camera.tv_camera_info_set","title":"<code>tv_camera_info_set(width: int | None = None, height: int | None = None, field_order: FieldOrder | None = None, frame_rate: float | None = None, pixel_aspect_ratio: float | None = None) -&gt; TVPCamera</code>","text":"<p>Set the information of the camera.</p> Source code in <code>pytvpaint/george/grg_camera.py</code> <pre><code>def tv_camera_info_set(\n    width: int | None = None,\n    height: int | None = None,\n    field_order: FieldOrder | None = None,\n    frame_rate: float | None = None,\n    pixel_aspect_ratio: float | None = None,\n) -&gt; TVPCamera:\n    \"\"\"Set the information of the camera.\"\"\"\n    optional_args = [\n        (width, height),\n        field_order.value if field_order else None,\n        frame_rate,\n        pixel_aspect_ratio,\n    ]\n\n    args = validate_args_list(optional_args)\n\n    result = send_cmd(\"tv_CameraInfo\", *args)\n    return TVPCamera(**tv_parse_list(result, with_fields=TVPCamera))\n</code></pre>"},{"location":"api/george/camera/#pytvpaint.george.grg_camera.tv_camera_enum_points","title":"<code>tv_camera_enum_points(index: int) -&gt; TVPCameraPoint</code>","text":"<p>Get the position/angle/scale values of the n-th point of the camera path.</p> Source code in <code>pytvpaint/george/grg_camera.py</code> <pre><code>def tv_camera_enum_points(index: int) -&gt; TVPCameraPoint:\n    \"\"\"Get the position/angle/scale values of the n-th point of the camera path.\"\"\"\n    res = send_cmd(\"tv_CameraEnumPoints\", index, error_values=[GrgErrorValue.NONE])\n    return TVPCameraPoint(**tv_parse_list(res, with_fields=TVPCameraPoint))\n</code></pre>"},{"location":"api/george/camera/#pytvpaint.george.grg_camera.tv_camera_interpolation","title":"<code>tv_camera_interpolation(position: float) -&gt; TVPCameraPoint</code>","text":"<p>Get the position/angle/scale values at the given position on the camera path (between 0 and 1).</p> Source code in <code>pytvpaint/george/grg_camera.py</code> <pre><code>def tv_camera_interpolation(position: float) -&gt; TVPCameraPoint:\n    \"\"\"Get the position/angle/scale values at the given position on the camera path (between 0 and 1).\"\"\"\n    res = tv_parse_list(\n        send_cmd(\"tv_CameraInterpolation\", position),\n        with_fields=TVPCameraPoint,\n    )\n    return TVPCameraPoint(**res)\n</code></pre>"},{"location":"api/george/camera/#pytvpaint.george.grg_camera.tv_camera_insert_point","title":"<code>tv_camera_insert_point(index: int, x: float, y: float, angle: float, scale: float) -&gt; None</code>","text":"<p>Add a point to the camera path before the given index.</p> Source code in <code>pytvpaint/george/grg_camera.py</code> <pre><code>def tv_camera_insert_point(\n    index: int,\n    x: float,\n    y: float,\n    angle: float,\n    scale: float,\n) -&gt; None:\n    \"\"\"Add a point to the camera path *before* the given index.\"\"\"\n    send_cmd(\"tv_CameraInsertPoint\", index, x, y, angle, scale)\n</code></pre>"},{"location":"api/george/camera/#pytvpaint.george.grg_camera.tv_camera_remove_point","title":"<code>tv_camera_remove_point(index: int) -&gt; None</code>","text":"<p>Remove a point at the given index.</p> Source code in <code>pytvpaint/george/grg_camera.py</code> <pre><code>def tv_camera_remove_point(index: int) -&gt; None:\n    \"\"\"Remove a point at the given index.\"\"\"\n    send_cmd(\"tv_CameraRemovePoint\", index)\n</code></pre>"},{"location":"api/george/camera/#pytvpaint.george.grg_camera.tv_camera_set_point","title":"<code>tv_camera_set_point(index: int, x: float, y: float, angle: float, scale: float) -&gt; None</code>","text":"<p>Set position/angle/scale value of a point at the given index and make it current.</p> Source code in <code>pytvpaint/george/grg_camera.py</code> <pre><code>def tv_camera_set_point(\n    index: int,\n    x: float,\n    y: float,\n    angle: float,\n    scale: float,\n) -&gt; None:\n    \"\"\"Set position/angle/scale value of a point at the given index and make it current.\"\"\"\n    send_cmd(\"tv_CameraSetPoint\", index, x, y, angle, scale)\n</code></pre>"},{"location":"api/george/clip/","title":"Clip related George functions","text":"<p>Clip related George functions.</p>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.TVPClip","title":"<code>TVPClip(id: int, name: str, is_current: bool, is_hidden: bool, is_selected: bool, storyboard_start_frame: int, first_frame: int, last_frame: int, frame_count: int, mark_in: int, mark_out: int, color_idx: int)</code>  <code>dataclass</code>","text":"<p>TVPaint clip info values.</p>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.PSDSaveMode","title":"<code>PSDSaveMode</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>PSD save modes.</p> <p>Attributes:</p> Name Type Description <code>ALL</code> <code>IMAGE</code> <code>MARKIN</code>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_info","title":"<code>tv_clip_info(clip_id: int) -&gt; TVPClip</code>","text":"<p>Get the information of the given clip.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid clip id</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid clip id\",\n)\ndef tv_clip_info(clip_id: int) -&gt; TVPClip:\n    \"\"\"Get the information of the given clip.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid clip id\n    \"\"\"\n    result = send_cmd(\"tv_ClipInfo\", clip_id, error_values=[GrgErrorValue.EMPTY])\n    clip = tv_parse_dict(result, with_fields=TVPClip)\n    clip[\"id\"] = clip_id\n    return TVPClip(**clip)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_enum_id","title":"<code>tv_clip_enum_id(scene_id: int, clip_position: int) -&gt; int</code>","text":"<p>Get the id of the clip at the given position inside the given scene.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if given an invalid scene id or clip position or elements have been removed</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>@try_cmd(\n    exception_msg=\"Invalid scene id or clip position or elements have been removed\"\n)\ndef tv_clip_enum_id(scene_id: int, clip_position: int) -&gt; int:\n    \"\"\"Get the id of the clip at the given position inside the given scene.\n\n    Raises:\n        GeorgeError: if given an invalid scene id or clip position or elements have been removed\n    \"\"\"\n    return int(\n        send_cmd(\n            \"tv_ClipEnumId\",\n            scene_id,\n            clip_position,\n            error_values=[GrgErrorValue.NONE],\n        )\n    )\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_current_id","title":"<code>tv_clip_current_id() -&gt; int</code>","text":"<p>Get the id of the current clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_current_id() -&gt; int:\n    \"\"\"Get the id of the current clip.\"\"\"\n    return int(send_cmd(\"tv_ClipCurrentId\"))\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_new","title":"<code>tv_clip_new(name: str) -&gt; None</code>","text":"<p>Create a new clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_new(name: str) -&gt; None:\n    \"\"\"Create a new clip.\"\"\"\n    send_cmd(\"tv_ClipNew\", name, handle_string=False)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_duplicate","title":"<code>tv_clip_duplicate(clip_id: int) -&gt; None</code>","text":"<p>Duplicate the given clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_duplicate(clip_id: int) -&gt; None:\n    \"\"\"Duplicate the given clip.\"\"\"\n    send_cmd(\"tv_ClipDuplicate\", clip_id)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_close","title":"<code>tv_clip_close(clip_id: int) -&gt; None</code>","text":"<p>Remove the given clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_close(clip_id: int) -&gt; None:\n    \"\"\"Remove the given clip.\"\"\"\n    send_cmd(\"tv_ClipClose\", clip_id)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_name_get","title":"<code>tv_clip_name_get(clip_id: int) -&gt; str</code>","text":"<p>Get the clip name.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid clip id</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid clip id\",\n)\ndef tv_clip_name_get(clip_id: int) -&gt; str:\n    \"\"\"Get the clip name.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid clip id\n    \"\"\"\n    return send_cmd(\"tv_ClipName\", clip_id, error_values=[GrgErrorValue.EMPTY])\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_name_set","title":"<code>tv_clip_name_set(clip_id: int, name: str) -&gt; None</code>","text":"<p>Set the clip name.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid clip id</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid clip id\",\n)\ndef tv_clip_name_set(clip_id: int, name: str) -&gt; None:\n    \"\"\"Set the clip name.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid clip id\n    \"\"\"\n    send_cmd(\"tv_ClipName\", clip_id, name, error_values=[GrgErrorValue.EMPTY])\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_move","title":"<code>tv_clip_move(clip_id: int, scene_id: int, position: int) -&gt; None</code>","text":"<p>Manage clip position.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_move(clip_id: int, scene_id: int, position: int) -&gt; None:\n    \"\"\"Manage clip position.\"\"\"\n    send_cmd(\"tv_ClipMove\", clip_id, scene_id, position)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_hidden_get","title":"<code>tv_clip_hidden_get(clip_id: int) -&gt; bool</code>","text":"<p>Get clip visibility.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid clip id</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid clip id\",\n)\ndef tv_clip_hidden_get(clip_id: int) -&gt; bool:\n    \"\"\"Get clip visibility.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid clip id\n    \"\"\"\n    res = send_cmd(\"tv_ClipHidden\", clip_id, error_values=[GrgErrorValue.EMPTY])\n    return bool(int(res))\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_hidden_set","title":"<code>tv_clip_hidden_set(clip_id: int, new_state: bool) -&gt; None</code>","text":"<p>Set clip visibility.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid clip id</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid clip id\",\n)\ndef tv_clip_hidden_set(clip_id: int, new_state: bool) -&gt; None:\n    \"\"\"Set clip visibility.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid clip id\n    \"\"\"\n    send_cmd(\n        \"tv_ClipHidden\", clip_id, int(new_state), error_values=[GrgErrorValue.EMPTY]\n    )\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_select","title":"<code>tv_clip_select(clip_id: int) -&gt; None</code>","text":"<p>Activate/Make current the given clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_select(clip_id: int) -&gt; None:\n    \"\"\"Activate/Make current the given clip.\"\"\"\n    send_cmd(\"tv_ClipSelect\", clip_id)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_selection_get","title":"<code>tv_clip_selection_get(clip_id: int) -&gt; bool</code>","text":"<p>Get the clip's selection state.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid clip id</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid clip id\",\n)\ndef tv_clip_selection_get(clip_id: int) -&gt; bool:\n    \"\"\"Get the clip's selection state.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid clip id\n    \"\"\"\n    res = send_cmd(\"tv_ClipSelection\", clip_id, error_values=[-1])\n    return bool(int(res))\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_selection_set","title":"<code>tv_clip_selection_set(clip_id: int, new_state: bool) -&gt; None</code>","text":"<p>Set the clip's selection state.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid clip id</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid clip id\",\n)\ndef tv_clip_selection_set(clip_id: int, new_state: bool) -&gt; None:\n    \"\"\"Set the clip's selection state.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid clip id\n    \"\"\"\n    send_cmd(\"tv_ClipSelection\", clip_id, int(new_state), error_values=[-1])\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_first_image","title":"<code>tv_first_image() -&gt; int</code>","text":"<p>Get the first image of the clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_first_image() -&gt; int:\n    \"\"\"Get the first image of the clip.\"\"\"\n    return int(send_cmd(\"tv_FirstImage\"))\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_last_image","title":"<code>tv_last_image() -&gt; int</code>","text":"<p>Get the last image of the clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_last_image() -&gt; int:\n    \"\"\"Get the last image of the clip.\"\"\"\n    return int(send_cmd(\"tv_LastImage\"))\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_load_sequence","title":"<code>tv_load_sequence(seq_path: Path | str, offset_count: tuple[int, int] | None = None, field_order: FieldOrder | None = None, stretch: bool = False, time_stretch: bool = False, preload: bool = False) -&gt; int</code>","text":"<p>Load a sequence of images or movie in a new layer.</p> <p>Parameters:</p> Name Type Description Default <code>seq_path</code> <code>pathlib.Path | str</code> <p>the first file of the sequence to load</p> required <code>offset_count</code> <code>tuple[int, int] | None</code> <p>the start and number of images in the sequence to load. Defaults to None.</p> <code>None</code> <code>field_order</code> <code>pytvpaint.george.grg_base.FieldOrder | None</code> <p>the field order. Defaults to None.</p> <code>None</code> <code>stretch</code> <code>bool</code> <p>Stretch each image to the size of the layer. Defaults to None.</p> <code>False</code> <code>time_stretch</code> <code>bool</code> <p>Once loaded, the layer will have a new number of images corresponding to the project framerate. Defaults to None.</p> <code>False</code> <code>preload</code> <code>bool</code> <p>Load all the images in memory, no more reference on the files. Defaults to None.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the sequence file doesn't exist</p> <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if the input file is in an invalid format</p> <p>Returns:</p> Type Description <code>int</code> <p>the number of images of the new layer</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>@try_cmd(exception_msg=\"Invalid format for sequence\")\ndef tv_load_sequence(\n    seq_path: Path | str,\n    offset_count: tuple[int, int] | None = None,\n    field_order: FieldOrder | None = None,\n    stretch: bool = False,\n    time_stretch: bool = False,\n    preload: bool = False,\n) -&gt; int:\n    \"\"\"Load a sequence of images or movie in a new layer.\n\n    Args:\n        seq_path: the first file of the sequence to load\n        offset_count: the start and number of images in the sequence to load. Defaults to None.\n        field_order: the field order. Defaults to None.\n        stretch: Stretch each image to the size of the layer. Defaults to None.\n        time_stretch: Once loaded, the layer will have a new number of images corresponding to the project framerate. Defaults to None.\n        preload: Load all the images in memory, no more reference on the files. Defaults to None.\n\n    Raises:\n        FileNotFoundError: if the sequence file doesn't exist\n        GeorgeError: if the input file is in an invalid format\n\n    Returns:\n        the number of images of the new layer\n    \"\"\"\n    seq_path = Path(seq_path)\n\n    if not seq_path.exists():\n        raise FileNotFoundError(f\"File not found at: {seq_path.as_posix()}\")\n\n    args: list[int | str] = [seq_path.as_posix()]\n    if offset_count and len(offset_count) == 2:\n        args.extend(offset_count)\n    if field_order:\n        args.append(field_order.value)\n\n    extra_args = [\n        (stretch, \"stretch\"),\n        (time_stretch, \"timestretch\"),\n        (preload, \"preload\"),\n    ]\n    for param, param_name in extra_args:\n        if not param:\n            continue\n        args.append(param_name)\n\n    result = send_cmd(\n        \"tv_LoadSequence\",\n        *args,\n        error_values=[-1],\n    )\n\n    return int(result)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_save_sequence","title":"<code>tv_save_sequence(export_path: Path | str, mark_in: int | None = None, mark_out: int | None = None) -&gt; None</code>","text":"<p>Save the current clip.</p> <p>Raises:</p> Type Description <code>NotADirectoryError</code> <p>if the export directory doesn't exist</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_save_sequence(\n    export_path: Path | str,\n    mark_in: int | None = None,\n    mark_out: int | None = None,\n) -&gt; None:\n    \"\"\"Save the current clip.\n\n    Raises:\n        NotADirectoryError: if the export directory doesn't exist\n    \"\"\"\n    export_path = Path(export_path).resolve()\n\n    if not export_path.parent.exists():\n        raise NotADirectoryError(\n            \"Can't save the sequence because parent\"\n            f\"folder does not exist: {export_path.parent.as_posix()}\"\n        )\n\n    args: list[Any] = [export_path.as_posix()]\n\n    if mark_in is not None and mark_out is not None:\n        args.extend([mark_in, mark_out])\n\n    send_cmd(\"tv_SaveSequence\", *args)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_bookmarks_enum","title":"<code>tv_bookmarks_enum(position: int) -&gt; int</code>","text":"<p>Get the frame (in the clip) corresponding to the bookmark at the given position.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if no bookmark found at provided position</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>@try_cmd(exception_msg=\"No bookmark at provided position\")\ndef tv_bookmarks_enum(position: int) -&gt; int:\n    \"\"\"Get the frame (in the clip) corresponding to the bookmark at the given position.\n\n    Raises:\n        GeorgeError: if no bookmark found at provided position\n    \"\"\"\n    return int(\n        send_cmd(\"tv_BookmarksEnum\", position, error_values=[GrgErrorValue.NONE])\n    )\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_bookmark_set","title":"<code>tv_bookmark_set(frame: int) -&gt; None</code>","text":"<p>Set a bookmark at the given frame.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_bookmark_set(frame: int) -&gt; None:\n    \"\"\"Set a bookmark at the given frame.\"\"\"\n    send_cmd(\"tv_BookmarkSet\", frame)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_bookmark_clear","title":"<code>tv_bookmark_clear(frame: int) -&gt; None</code>","text":"<p>Remove a bookmark at the given frame.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_bookmark_clear(frame: int) -&gt; None:\n    \"\"\"Remove a bookmark at the given frame.\"\"\"\n    send_cmd(\"tv_BookmarkClear\", frame)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_bookmark_next","title":"<code>tv_bookmark_next() -&gt; None</code>","text":"<p>Go to the next bookmarked frame.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_bookmark_next() -&gt; None:\n    \"\"\"Go to the next bookmarked frame.\"\"\"\n    send_cmd(\"tv_BookmarkNext\")\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_bookmark_prev","title":"<code>tv_bookmark_prev() -&gt; None</code>","text":"<p>Go to the previous bookmarked frame.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_bookmark_prev() -&gt; None:\n    \"\"\"Go to the previous bookmarked frame.\"\"\"\n    send_cmd(\"tv_BookmarkPrev\")\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_color_get","title":"<code>tv_clip_color_get(clip_id: int) -&gt; int</code>","text":"<p>Get the clip color.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_color_get(clip_id: int) -&gt; int:\n    \"\"\"Get the clip color.\"\"\"\n    return int(send_cmd(\"tv_ClipColor\", clip_id, error_values=[GrgErrorValue.EMPTY]))\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_color_set","title":"<code>tv_clip_color_set(clip_id: int, color_index: int) -&gt; None</code>","text":"<p>Set the clip color.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_color_set(clip_id: int, color_index: int) -&gt; None:\n    \"\"\"Set the clip color.\"\"\"\n    send_cmd(\"tv_ClipColor\", clip_id, color_index, error_values=[GrgErrorValue.EMPTY])\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_action_get","title":"<code>tv_clip_action_get(clip_id: int) -&gt; str</code>","text":"<p>Get the action text of the clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_action_get(clip_id: int) -&gt; str:\n    \"\"\"Get the action text of the clip.\"\"\"\n    # We explicitly check if the clip exists because the error value is an empty string, and we can't determine if the\n    # action text is empty or the clip_id is invalid...\n    tv_clip_name_get(clip_id)\n    return send_cmd(\"tv_ClipAction\", clip_id)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_action_set","title":"<code>tv_clip_action_set(clip_id: int, text: str) -&gt; None</code>","text":"<p>Set the action text of the clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_action_set(clip_id: int, text: str) -&gt; None:\n    \"\"\"Set the action text of the clip.\"\"\"\n    # See tv_clip_action_get above\n    tv_clip_name_get(clip_id)\n    send_cmd(\"tv_ClipAction\", clip_id, text)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_dialog_get","title":"<code>tv_clip_dialog_get(clip_id: int) -&gt; str</code>","text":"<p>Get the dialog text of the clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_dialog_get(clip_id: int) -&gt; str:\n    \"\"\"Get the dialog text of the clip.\"\"\"\n    # See tv_clip_action_get above\n    tv_clip_name_get(clip_id)\n    return send_cmd(\"tv_ClipDialog\", clip_id)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_dialog_set","title":"<code>tv_clip_dialog_set(clip_id: int, dialog: str) -&gt; None</code>","text":"<p>Set the dialog text of the clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_dialog_set(clip_id: int, dialog: str) -&gt; None:\n    \"\"\"Set the dialog text of the clip.\"\"\"\n    # See tv_clip_action_get above\n    tv_clip_name_get(clip_id)\n    send_cmd(\"tv_ClipDialog\", clip_id, dialog)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_note_get","title":"<code>tv_clip_note_get(clip_id: int) -&gt; str</code>","text":"<p>Get the note text of the clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_note_get(clip_id: int) -&gt; str:\n    \"\"\"Get the note text of the clip.\"\"\"\n    # See tv_clip_action_get above\n    tv_clip_name_get(clip_id)\n    return send_cmd(\"tv_ClipNote\", clip_id)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_note_set","title":"<code>tv_clip_note_set(clip_id: int, note: str) -&gt; None</code>","text":"<p>Set the note text of the clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_note_set(clip_id: int, note: str) -&gt; None:\n    \"\"\"Set the note text of the clip.\"\"\"\n    # See tv_clip_action_get above\n    tv_clip_name_get(clip_id)\n    send_cmd(\"tv_ClipNote\", clip_id, note)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_save_clip","title":"<code>tv_save_clip(export_path: Path | str) -&gt; None</code>","text":"<p>Save the current clip in .tvp format.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if file couldn't be saved</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>@try_cmd(exception_msg=\"Can't create file\")\ndef tv_save_clip(export_path: Path | str) -&gt; None:\n    \"\"\"Save the current clip in .tvp format.\n\n    Raises:\n        GeorgeError: if file couldn't be saved\n    \"\"\"\n    export_path = Path(export_path)\n    send_cmd(\"tv_SaveClip\", export_path.as_posix())\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_save_display","title":"<code>tv_save_display(export_path: Path | str) -&gt; None</code>","text":"<p>Save the display.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_save_display(export_path: Path | str) -&gt; None:\n    \"\"\"Save the display.\"\"\"\n    export_path = Path(export_path).resolve()\n    send_cmd(\"tv_SaveDisplay\", export_path.as_posix())\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_save_structure_json","title":"<code>tv_clip_save_structure_json(export_path: Path | str, file_format: SaveFormat, fill_background: bool = False, folder_pattern: str | None = None, file_pattern: str | None = None, visible_layers_only: bool = True, all_images: bool = False, ignore_duplicates: bool = False, exclude_names: list[str] | None = None) -&gt; None</code>","text":"<p>Save the current clip structure in json.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>pathlib.Path | str</code> <p>the JSON export path</p> required <code>file_format</code> <code>pytvpaint.george.grg_base.SaveFormat</code> <p>file format to use for rendering</p> required <code>fill_background</code> <code>bool</code> <p>add a background. Defaults to None.</p> <code>False</code> <code>folder_pattern</code> <code>str | None</code> <p>the folder name pattern (%li: layer index, %ln: layer name, %fi: file index (added in 11.0.8)). Defaults to None.</p> <code>None</code> <code>file_pattern</code> <code>str | None</code> <p>the file name pattern (%li: layer index, %ln: layer name, %ii: image index, %in: image name, %fi: file index (added in 11.0.8)). Defaults to None.</p> <code>None</code> <code>visible_layers_only</code> <code>bool</code> <p>export only visible layers. Defaults to None.</p> <code>True</code> <code>all_images</code> <code>bool</code> <p>export all images. Defaults to None.</p> <code>False</code> <code>ignore_duplicates</code> <code>bool</code> <p>Ignore duplicates images. Defaults to None.</p> <code>False</code> <code>exclude_names</code> <code>list[str] | None</code> <p>the instances names which won't be processed/exported. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>the parent folder doesn't exist</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_save_structure_json(\n    export_path: Path | str,\n    file_format: SaveFormat,\n    fill_background: bool = False,\n    folder_pattern: str | None = None,\n    file_pattern: str | None = None,\n    visible_layers_only: bool = True,\n    all_images: bool = False,\n    ignore_duplicates: bool = False,\n    exclude_names: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Save the current clip structure in json.\n\n    Args:\n        export_path: the JSON export path\n        file_format: file format to use for rendering\n        fill_background: add a background. Defaults to None.\n        folder_pattern: the folder name pattern (%li: layer index, %ln: layer name, %fi: file index (added in 11.0.8)). Defaults to None.\n        file_pattern: the file name pattern (%li: layer index, %ln: layer name, %ii: image index, %in: image name, %fi: file index (added in 11.0.8)). Defaults to None.\n        visible_layers_only: export only visible layers. Defaults to None.\n        all_images: export all images. Defaults to None.\n        ignore_duplicates: Ignore duplicates images. Defaults to None.\n        exclude_names: the instances names which won't be processed/exported. Defaults to None.\n\n    Raises:\n        ValueError: the parent folder doesn't exist\n    \"\"\"\n    export_path = Path(export_path).resolve()\n\n    if not export_path.parent.exists():\n        raise ValueError(\n            \"Can't write file because the destination folder doesn't exist\"\n        )\n\n    args = [export_path.as_posix(), \"JSON\"]\n\n    dict_args = {\n        \"fileformat\": file_format.value,\n        \"background\": int(fill_background) if fill_background else None,\n        \"patternfolder\": folder_pattern,\n        \"patternfile\": file_pattern,\n        \"onlyvisiblelayers\": int(visible_layers_only),\n        \"allimages\": int(all_images),\n        \"ignoreduplicateimages\": int(ignore_duplicates),\n        \"excludenames\": (\";\".join(exclude_names) if exclude_names else None),\n    }\n    args.extend(args_dict_to_list(dict_args))\n\n    send_cmd(\"tv_ClipSaveStructure\", *args, error_values=[-1])\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_save_structure_psd","title":"<code>tv_clip_save_structure_psd(export_path: Path | str, mode: PSDSaveMode, image: int | None = None, mark_in: int | None = None, mark_out: int | None = None) -&gt; None</code>","text":"<p>Save the current clip as a PSD.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>pathlib.Path | str</code> <p>description</p> required <code>mode</code> <code>pytvpaint.george.grg_clip.PSDSaveMode</code> <p>all will export all layers to a single PSD</p> required <code>image</code> <code>int | None</code> <p>will only export the given image. Defaults to None.</p> <code>None</code> <code>mark_in</code> <code>int | None</code> <p>start frame to render. Defaults to None.</p> <code>None</code> <code>mark_out</code> <code>int | None</code> <p>end frame to render. Defaults to None.</p> <code>None</code> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_save_structure_psd(\n    export_path: Path | str,\n    mode: PSDSaveMode,\n    image: int | None = None,\n    mark_in: int | None = None,\n    mark_out: int | None = None,\n) -&gt; None:\n    \"\"\"Save the current clip as a PSD.\n\n    Args:\n        export_path: _description_\n        mode: all will export all layers to a single PSD\n        image: will only export the given image. Defaults to None.\n        mark_in: start frame to render. Defaults to None.\n        mark_out: end frame to render. Defaults to None.\n    \"\"\"\n    export_path = Path(export_path)\n\n    if not export_path.parent.exists():\n        raise ValueError(\n            \"Can't write file because the destination folder doesn't exist\"\n        )\n\n    args_dict: dict[str, str | int | None]\n\n    if mode == PSDSaveMode.ALL:\n        args_dict = {\"mode\": \"all\"}\n    elif mode == PSDSaveMode.IMAGE:\n        if image is None:\n            raise ValueError(\"Image must be defined\")\n        args_dict = {\"image\": image}\n    else:  # Markin\n        if mark_in is None or mark_out is None:\n            raise ValueError(\"mark_in and mark_out must be defined\")\n        args_dict = {\"markin\": mark_in, \"markout\": mark_out}\n\n    args = args_dict_to_list(args_dict)\n\n    send_cmd(\n        \"tv_ClipSaveStructure\",\n        export_path.as_posix(),\n        \"PSD\",\n        *args,\n        error_values=[-1],\n    )\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_save_structure_csv","title":"<code>tv_clip_save_structure_csv(export_path: Path | str, all_images: bool | None = None, exposure_label: str | None = None) -&gt; None</code>","text":"<p>Save the current clip as a CSV.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>pathlib.Path | str</code> <p>the .csv export path</p> required <code>all_images</code> <code>bool | None</code> <p>export all images or only instances. Defaults to None.</p> <code>None</code> <code>exposure_label</code> <code>str | None</code> <p>give a label when the image is an exposure. Defaults to None.</p> <code>None</code> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_save_structure_csv(\n    export_path: Path | str,\n    all_images: bool | None = None,\n    exposure_label: str | None = None,\n) -&gt; None:\n    \"\"\"Save the current clip as a CSV.\n\n    Args:\n        export_path: the .csv export path\n        all_images: export all images or only instances. Defaults to None.\n        exposure_label: give a label when the image is an exposure. Defaults to None.\n    \"\"\"\n    export_path = Path(export_path)\n\n    args = args_dict_to_list(\n        {\n            \"allimages\": int(bool(all_images)),\n            \"exposurelabel\": exposure_label,\n        }\n    )\n\n    send_cmd(\n        \"tv_ClipSaveStructure\",\n        export_path.as_posix(),\n        \"CSV\",\n        *args,\n        error_values=[-1],\n    )\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_save_structure_sprite","title":"<code>tv_clip_save_structure_sprite(export_path: Path | str, layout: SpriteLayout | None = None, space: int | None = None) -&gt; None</code>","text":"<p>Save the current clip as sprites in one image.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>pathlib.Path | str</code> <p>the export path of the sprite image</p> required <code>layout</code> <code>pytvpaint.george.grg_base.SpriteLayout | None</code> <p>the sprite layout. Defaults to None.</p> <code>None</code> <code>space</code> <code>int | None</code> <p>the space between each sprite in the image. Defaults to None.</p> <code>None</code> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_save_structure_sprite(\n    export_path: Path | str,\n    layout: SpriteLayout | None = None,\n    space: int | None = None,\n) -&gt; None:\n    \"\"\"Save the current clip as sprites in one image.\n\n    Args:\n        export_path: the export path of the sprite image\n        layout: the sprite layout. Defaults to None.\n        space: the space between each sprite in the image. Defaults to None.\n    \"\"\"\n    export_path = Path(export_path)\n\n    args = args_dict_to_list(\n        {\n            \"layout\": layout.value if layout is not None else None,\n            \"space\": space,\n        }\n    )\n\n    send_cmd(\n        \"tv_ClipSaveStructure\",\n        export_path.as_posix(),\n        \"sprite\",\n        *args,\n        error_values=[-1],\n    )\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_clip_save_structure_flix","title":"<code>tv_clip_save_structure_flix(export_path: Path | str, mark_in: int | None = None, mark_out: int | None = None, parameters_import: str | None = None, parameters_file: str | None = None, send: bool | None = None, original_file: str | Path | None = None) -&gt; None</code>","text":"<p>Save the current clip for Flix.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>pathlib.Path | str</code> <p>the .xml export path</p> required <code>mark_in</code> <code>int | None</code> <p>the start frame to render. Defaults to None.</p> <code>None</code> <code>mark_out</code> <code>int | None</code> <p>the end frame to render. Defaults to None.</p> <code>None</code> <code>parameters_import</code> <code>str | None</code> <p>the attribute(s) of the global  tag (waitForSource/...). Defaults to None. <code>None</code> <code>parameters_file</code> <code>str | None</code> <p>the attribute(s) of each  (file) tag (dialogue/...). Defaults to None. <code>None</code> <code>send</code> <code>bool | None</code> <p>open a browser with the prefilled url. Defaults to None.</p> <code>None</code> <code>original_file</code> <code>str | pathlib.Path | None</code> <p>the original reference tvpp file path. Defaults to None.</p> <code>None</code> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_clip_save_structure_flix(\n    export_path: Path | str,\n    mark_in: int | None = None,\n    mark_out: int | None = None,\n    parameters_import: str | None = None,\n    parameters_file: str | None = None,\n    send: bool | None = None,\n    original_file: str | Path | None = None,\n) -&gt; None:\n    \"\"\"Save the current clip for Flix.\n\n    Args:\n        export_path: the .xml export path\n        mark_in: the start frame to render. Defaults to None.\n        mark_out: the end frame to render. Defaults to None.\n        parameters_import: the attribute(s) of the global &lt;flixImport&gt; tag (waitForSource/...). Defaults to None.\n        parameters_file: the attribute(s) of each &lt;image&gt; (file) tag (dialogue/...). Defaults to None.\n        send: open a browser with the prefilled url. Defaults to None.\n        original_file: the original reference tvpp file path. Defaults to None.\n    \"\"\"\n    export_path = Path(export_path)\n\n    args_dict = {\n        \"markin\": mark_in,\n        \"markout\": mark_out,\n        \"parametersimport\": parameters_import,\n        \"parametersfile\": parameters_file,\n        \"send\": int(send) if send else None,\n        \"originalfile\": Path(original_file).as_posix() if original_file else None,\n    }\n\n    args = args_dict_to_list(args_dict)\n\n    send_cmd(\n        \"tv_ClipSaveStructure\",\n        export_path.as_posix(),\n        \"Flix\",\n        *args,\n        error_values=[-1],\n    )\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_sound_clip_info","title":"<code>tv_sound_clip_info(clip_id: int, track_index: int) -&gt; TVPSound</code>","text":"<p>Get information about a soundtrack.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_sound_clip_info(clip_id: int, track_index: int) -&gt; TVPSound:\n    \"\"\"Get information about a soundtrack.\"\"\"\n    res = send_cmd(\"tv_SoundClipInfo\", clip_id, track_index, error_values=[-1, -2, -3])\n    res_parse = tv_parse_list(res, with_fields=TVPSound)\n    return TVPSound(**res_parse)\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_sound_clip_new","title":"<code>tv_sound_clip_new(sound_path: Path | str) -&gt; None</code>","text":"<p>Add a new soundtrack.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_sound_clip_new(sound_path: Path | str) -&gt; None:\n    \"\"\"Add a new soundtrack.\"\"\"\n    path = Path(sound_path)\n    if not path.exists():\n        raise ValueError(f\"Sound file not found at : {path.as_posix()}\")\n    send_cmd(\"tv_SoundClipNew\", path.as_posix(), error_values=[-1, -2, -3, -4])\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_sound_clip_remove","title":"<code>tv_sound_clip_remove(track_index: int) -&gt; None</code>","text":"<p>Remove a soundtrack.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_sound_clip_remove(track_index: int) -&gt; None:\n    \"\"\"Remove a soundtrack.\"\"\"\n    send_cmd(\"tv_SoundClipRemove\", track_index, error_values=[-2])\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_sound_clip_reload","title":"<code>tv_sound_clip_reload(clip_id: int, track_index: int) -&gt; None</code>","text":"<p>Reload a soundtrack from its file.</p> <p>Parameters:</p> Name Type Description Default <code>clip_id</code> <code>int</code> <p>the clip id (only works with <code>0</code> being the current clip)</p> required <code>track_index</code> <code>int</code> <p>the sound clip track index</p> required Warning <p>this doesn't accept a proper clip id, only <code>0</code> seem to work for the current clip</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_sound_clip_reload(clip_id: int, track_index: int) -&gt; None:\n    \"\"\"Reload a soundtrack from its file.\n\n    Args:\n        clip_id: the clip id (only works with `0` being the current clip)\n        track_index: the sound clip track index\n\n    Warning:\n        this doesn't accept a proper clip id, only `0` seem to work for the current clip\n    \"\"\"\n    send_cmd(\"tv_SoundClipReload\", clip_id, track_index, error_values=[-1, -2, -3])\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_sound_clip_adjust","title":"<code>tv_sound_clip_adjust(track_index: int, mute: bool | None = None, volume: float | None = None, offset: float | None = None, fade_in_start: float | None = None, fade_in_stop: float | None = None, fade_out_start: float | None = None, fade_out_stop: float | None = None, color_index: int | None = None) -&gt; None</code>","text":"<p>Change a soundtracks settings.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_sound_clip_adjust(\n    track_index: int,\n    mute: bool | None = None,\n    volume: float | None = None,\n    offset: float | None = None,\n    fade_in_start: float | None = None,\n    fade_in_stop: float | None = None,\n    fade_out_start: float | None = None,\n    fade_out_stop: float | None = None,\n    color_index: int | None = None,\n) -&gt; None:\n    \"\"\"Change a soundtracks settings.\"\"\"\n    cur_options = tv_sound_clip_info(tv_clip_current_id(), track_index)\n    args: list[int | float | None] = []\n\n    optional_args = [\n        (int(mute) if mute is not None else None, int(cur_options.mute)),\n        (volume, cur_options.volume),\n        (offset, cur_options.offset),\n        (fade_in_start, cur_options.fade_in_start),\n        (fade_in_stop, cur_options.fade_in_stop),\n        (fade_out_start, cur_options.fade_out_start),\n        (fade_out_stop, cur_options.fade_out_stop),\n    ]\n    for arg, default_value in optional_args:\n        args.append(arg if arg is not None else default_value)\n\n    args.append(color_index)\n    send_cmd(\"tv_SoundClipAdjust\", track_index, *args, error_values=[-2, -3])\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_layer_image_get","title":"<code>tv_layer_image_get() -&gt; int</code>","text":"<p>Get the current frame of the current clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_layer_image_get() -&gt; int:\n    \"\"\"Get the current frame of the current clip.\"\"\"\n    return int(send_cmd(\"tv_LayerGetImage\"))\n</code></pre>"},{"location":"api/george/clip/#pytvpaint.george.grg_clip.tv_layer_image","title":"<code>tv_layer_image(frame: int) -&gt; None</code>","text":"<p>Set the current frame of the current clip.</p> Source code in <code>pytvpaint/george/grg_clip.py</code> <pre><code>def tv_layer_image(frame: int) -&gt; None:\n    \"\"\"Set the current frame of the current clip.\"\"\"\n    send_cmd(\"tv_LayerImage\", frame)\n</code></pre>"},{"location":"api/george/exceptions/","title":"George Exceptions","text":"<p>Custom George exceptions.</p>"},{"location":"api/george/exceptions/#pytvpaint.george.exceptions.GeorgeError","title":"<code>GeorgeError(message: str | None = None, error_value: Any | None = None)</code>","text":"<p>             Bases: <code>Exception</code></p> <p>George error exception.</p> <p>Used for return values in the <code>[ERROR]</code> section of functions in TVPaint's documentation.</p> Source code in <code>pytvpaint/george/exceptions.py</code> <pre><code>def __init__(\n    self, message: str | None = None, error_value: Any | None = None\n) -&gt; None:\n    super().__init__(f\"{message}\" if message else \"\")\n    self.error_value = error_value\n</code></pre>"},{"location":"api/george/exceptions/#pytvpaint.george.exceptions.NoObjectWithIdError","title":"<code>NoObjectWithIdError(obj_id: int)</code>","text":"<p>             Bases: <code>pytvpaint.george.exceptions.GeorgeError</code></p> <p>Exception raised when a TVPaint was not found given its id.</p> Source code in <code>pytvpaint/george/exceptions.py</code> <pre><code>def __init__(self, obj_id: int) -&gt; None:\n    super().__init__(f\"Can't find an object with id: {obj_id}\")\n</code></pre>"},{"location":"api/george/layer/","title":"Layer related George functions","text":"<p>Layer related George functions and enums.</p>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.LayerColorAction","title":"<code>LayerColorAction</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p><code>tv_layercolor</code> actions.</p> <p>Attributes:</p> Name Type Description <code>GETCOLOR</code> <code>SETCOLOR</code> <code>GET</code> <code>SET</code> <code>LOCK</code> <code>UNLOCK</code> <code>SHOW</code> <code>HIDE</code> <code>VISIBLE</code> <code>SELECT</code> <code>UNSELECT</code>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.LayerColorDisplayOpt","title":"<code>LayerColorDisplayOpt</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p><code>tv_layercolorshow</code> display options.</p> <p>Attributes:</p> Name Type Description <code>DISPLAY</code> <p>Activate the layers to show them in the display</p> <code>TIMELINE</code> <p>Uncollpase layers from maximum collapse (2px height) in the timeline</p>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.InstanceNamingMode","title":"<code>InstanceNamingMode</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p><code>tv_instancename</code> naming modes.</p> <p>Attributes:</p> Name Type Description <code>ALL</code> <code>SMART</code>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.InstanceNamingProcess","title":"<code>InstanceNamingProcess</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p><code>tv_instancename</code> naming process.</p> <p>Attributes:</p> Name Type Description <code>EMPTY</code> <code>NUMBER</code> <code>TEXT</code>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.LayerType","title":"<code>LayerType</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>All the layer types.</p> <p>Attributes:</p> Name Type Description <code>IMAGE</code> <code>SEQUENCE</code> <code>XSHEET</code> <code>SCRIBBLES</code>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.StencilMode","title":"<code>StencilMode</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>All the stencil modes.</p> <p>Attributes:</p> Name Type Description <code>ON</code> <code>OFF</code> <code>NORMAL</code> <code>INVERT</code>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.LayerBehavior","title":"<code>LayerBehavior</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Layer behaviors on boundaries.</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <code>REPEAT</code> <code>PINGPONG</code> <code>HOLD</code>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.LayerTransparency","title":"<code>LayerTransparency</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Layer transparency values.</p> <p>Attributes:</p> Name Type Description <code>ON</code> <code>OFF</code> <code>MINUS_1</code> <code>NONE</code>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.InsertDirection","title":"<code>InsertDirection</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Instance insert direction.</p> <p>Attributes:</p> Name Type Description <code>BEFORE</code> <code>AFTER</code>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.TVPClipLayerColor","title":"<code>TVPClipLayerColor(clip_id: int, color_index: int, color_r: int, color_g: int, color_b: int, name: str)</code>  <code>dataclass</code>","text":"<p>Clip layer color values.</p>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.TVPLayer","title":"<code>TVPLayer(id: int, visibility: bool, position: int, density: int, name: str, type: LayerType, first_frame: int, last_frame: int, selected: bool, editable: bool, stencil_state: StencilMode)</code>  <code>dataclass</code>","text":"<p>TVPaint layer info values.</p>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_current_id","title":"<code>tv_layer_current_id() -&gt; int</code>","text":"<p>Get the id of the current layer.</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_current_id() -&gt; int:\n    \"\"\"Get the id of the current layer.\"\"\"\n    return int(send_cmd(\"tv_LayerCurrentId\"))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_get_id","title":"<code>tv_layer_get_id(position: int) -&gt; int</code>","text":"<p>Get the id of the layer at the given position.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if no layer found at the provided position</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(exception_msg=\"No layer at provided position\")\ndef tv_layer_get_id(position: int) -&gt; int:\n    \"\"\"Get the id of the layer at the given position.\n\n    Raises:\n        GeorgeError: if no layer found at the provided position\n    \"\"\"\n    result = send_cmd(\"tv_LayerGetID\", position, error_values=[GrgErrorValue.NONE])\n    return int(result)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_get_pos","title":"<code>tv_layer_get_pos(layer_id: int) -&gt; int</code>","text":"<p>Get the position of the given layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_get_pos(layer_id: int) -&gt; int:\n    \"\"\"Get the position of the given layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    return int(send_cmd(\"tv_LayerGetPos\", layer_id, error_values=[GrgErrorValue.NONE]))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_info","title":"<code>tv_layer_info(layer_id: int) -&gt; TVPLayer</code>","text":"<p>Get information of the given layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_info(layer_id: int) -&gt; TVPLayer:\n    \"\"\"Get information of the given layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    result = send_cmd(\"tv_LayerInfo\", layer_id, error_values=[GrgErrorValue.EMPTY])\n    layer = tv_parse_list(result, with_fields=TVPLayer, unused_indices=[7, 8])\n    layer[\"id\"] = layer_id\n    return TVPLayer(**layer)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_move","title":"<code>tv_layer_move(position: int) -&gt; None</code>","text":"<p>Move the current layer to a new position in the layer stack.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if layer could not be moved</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(exception_msg=\"Couldn't move current layer to position\")\ndef tv_layer_move(position: int) -&gt; None:\n    \"\"\"Move the current layer to a new position in the layer stack.\n\n    Raises:\n        GeorgeError: if layer could not be moved\n    \"\"\"\n    send_cmd(\"tv_LayerMove\", position)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_set","title":"<code>tv_layer_set(layer_id: int) -&gt; None</code>","text":"<p>Make the given layer the current one.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_set(layer_id: int) -&gt; None:\n    \"\"\"Make the given layer the current one.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\"tv_LayerSet\", layer_id)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_selection_get","title":"<code>tv_layer_selection_get(layer_id: int) -&gt; bool</code>","text":"<p>Get the selection state of a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(raise_exc=NoObjectWithIdError, exception_msg=\"Invalid layer id\")\ndef tv_layer_selection_get(layer_id: int) -&gt; bool:\n    \"\"\"Get the selection state of a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    res = send_cmd(\"tv_LayerSelection\", layer_id, error_values=[-1])\n    return tv_cast_to_type(res, bool)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_selection_set","title":"<code>tv_layer_selection_set(layer_id: int, new_state: bool) -&gt; None</code>","text":"<p>Set the selection state of a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(raise_exc=NoObjectWithIdError, exception_msg=\"Invalid layer id\")\ndef tv_layer_selection_set(layer_id: int, new_state: bool) -&gt; None:\n    \"\"\"Set the selection state of a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\"tv_LayerSelection\", layer_id, int(new_state), error_values=[-1])\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_select","title":"<code>tv_layer_select(start_frame: int, frame_count: int) -&gt; int</code>","text":"<p>Select frames in the current layer.</p> <p>Parameters:</p> Name Type Description Default <code>start_frame</code> <code>int</code> <p>selection start</p> required <code>frame_count</code> <code>int</code> <p>number of frames to select</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of frames selected</p> Note <p>If the start position is before the beginning of the layer, the selection will only start at the beginning of the layer, but its length will be measured from the start position. This means that if you ask for a selection of 15 frames starting from position 0 in a layer that actually starts at position 5, only the first 10 frames in the layer will be selected. If the selection goes beyond the end of the layer, it will only include the frames between the start and end of the layer. No frames will be selected if the start position is beyond the end of the layer</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_select(start_frame: int, frame_count: int) -&gt; int:\n    \"\"\"Select frames in the current layer.\n\n    Args:\n        start_frame: selection start\n        frame_count: number of frames to select\n\n    Returns:\n        int: number of frames selected\n\n    Note:\n        If the start position is before the beginning of the layer, the selection will only start at the beginning of\n        the layer, but its length will be measured from the start position.\n        This means that if you ask for a selection of 15 frames starting from position 0 in a layer that actually\n        starts at position 5, only the first 10 frames in the layer will be selected.\n        If the selection goes beyond the end of the layer, it will only include the frames between the start and end of\n        the layer. No frames will be selected if the start position is beyond the end of the layer\n    \"\"\"\n    return int(send_cmd(\"tv_LayerSelect\", start_frame, frame_count, error_values=[-1]))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_select_info","title":"<code>tv_layer_select_info(full: bool = False) -&gt; tuple[int, int]</code>","text":"<p>Get Selected frames in a layer.</p> <p>Parameters:</p> Name Type Description Default <code>full</code> <code>bool</code> <p>Always get the selection range, even on a non anim/ctg layer</p> <code>False</code> <p>Returns:</p> Name Type Description <code>frame</code> <code>int</code> <p>the start frame of the selection</p> <code>count</code> <code>int</code> <p>the number of frames in the selection</p> Bug <p>The official documentation states that this functions selects the layer frames, it does not, it simply returns the frames selected. This will also return all frames in the layer even if they are not selected if the argument <code>full</code> is set to True. We advise using <code>tv_layer_select</code> to select your frames and only using this function to get the selected frames.</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_select_info(full: bool = False) -&gt; tuple[int, int]:\n    \"\"\"Get Selected frames in a layer.\n\n    Args:\n        full:  Always get the selection range, even on a non anim/ctg layer\n\n    Returns:\n        frame: the start frame of the selection\n        count: the number of frames in the selection\n\n    Bug:\n        The official documentation states that this functions selects the layer frames, it does not, it simply\n        returns the frames selected. This will also return all frames in the layer even if they are not selected if the\n        argument `full` is set to True. We advise using `tv_layer_select` to select your frames and only using this\n        function to get the selected frames.\n    \"\"\"\n    args = [\"full\"] if full else []\n    res = send_cmd(\"tv_layerSelectInfo\", *args)\n    frame, count = tuple(map(int, res.split(\" \")))\n    return frame, count\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_create","title":"<code>tv_layer_create(name: str) -&gt; int</code>","text":"<p>Create a new image layer with the given name.</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_create(name: str) -&gt; int:\n    \"\"\"Create a new image layer with the given name.\"\"\"\n    return int(send_cmd(\"tv_LayerCreate\", name, handle_string=False))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_duplicate","title":"<code>tv_layer_duplicate(name: str) -&gt; int</code>","text":"<p>Duplicate the current layer and make it the current one.</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_duplicate(name: str) -&gt; int:\n    \"\"\"Duplicate the current layer and make it the current one.\"\"\"\n    return int(send_cmd(\"tv_LayerDuplicate\", name, handle_string=False))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_rename","title":"<code>tv_layer_rename(layer_id: int, name: str) -&gt; None</code>","text":"<p>Rename a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_rename(layer_id: int, name: str) -&gt; None:\n    \"\"\"Rename a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\"tv_LayerRename\", layer_id, name)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_kill","title":"<code>tv_layer_kill(layer_id: int) -&gt; None</code>","text":"<p>Delete the layer with provided id.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_kill(layer_id: int) -&gt; None:\n    \"\"\"Delete the layer with provided id.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\"tv_LayerKill\", layer_id)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_density_get","title":"<code>tv_layer_density_get() -&gt; int</code>","text":"<p>Get the current layer density (opacity).</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_density_get() -&gt; int:\n    \"\"\"Get the current layer density (opacity).\"\"\"\n    return int(send_cmd(\"tv_LayerDensity\"))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_density_set","title":"<code>tv_layer_density_set(new_density: int) -&gt; None</code>","text":"<p>Set the current layer density (opacity ranging from 0 to 100).</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_density_set(new_density: int) -&gt; None:\n    \"\"\"Set the current layer density (opacity ranging from 0 to 100).\"\"\"\n    send_cmd(\"tv_LayerDensity\", new_density)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_display_get","title":"<code>tv_layer_display_get(layer_id: int) -&gt; bool</code>","text":"<p>Get the visibility of the given layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_display_get(layer_id: int) -&gt; bool:\n    \"\"\"Get the visibility of the given layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    res = send_cmd(\"tv_LayerDisplay\", layer_id, error_values=[0])\n    return tv_cast_to_type(res.lower(), bool)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_display_set","title":"<code>tv_layer_display_set(layer_id: int, new_state: bool, light_table: bool = False) -&gt; None</code>","text":"<p>Set the visibility of the given layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_display_set(\n    layer_id: int, new_state: bool, light_table: bool = False\n) -&gt; None:\n    \"\"\"Set the visibility of the given layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    args: list[Any] = [layer_id, int(new_state)]\n    if light_table:\n        args.insert(1, \"lighttable\")\n    send_cmd(\"tv_LayerDisplay\", *args, error_values=[0])\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_lock_get","title":"<code>tv_layer_lock_get(layer_id: int) -&gt; bool</code>","text":"<p>Get the lock state of the given layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_lock_get(layer_id: int) -&gt; bool:\n    \"\"\"Get the lock state of the given layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    res = send_cmd(\"tv_LayerLock\", layer_id, error_values=[GrgErrorValue.ERROR])\n    return tv_cast_to_type(res.lower(), bool)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_lock_set","title":"<code>tv_layer_lock_set(layer_id: int, new_state: bool) -&gt; None</code>","text":"<p>Set the lock state of the given layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_lock_set(layer_id: int, new_state: bool) -&gt; None:\n    \"\"\"Set the lock state of the given layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\n        \"tv_LayerLock\",\n        layer_id,\n        int(new_state),\n        error_values=[GrgErrorValue.ERROR],\n    )\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_collapse_get","title":"<code>tv_layer_collapse_get(layer_id: int) -&gt; bool</code>","text":"<p>Get the collapse mode of the given layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_collapse_get(layer_id: int) -&gt; bool:\n    \"\"\"Get the collapse mode of the given layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    return bool(int(send_cmd(\"tv_LayerCollapse\", layer_id, error_values=[-2])))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_collapse_set","title":"<code>tv_layer_collapse_set(layer_id: int, new_state: bool) -&gt; None</code>","text":"<p>Set the collapse mode of the given layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_collapse_set(layer_id: int, new_state: bool) -&gt; None:\n    \"\"\"Set the collapse mode of the given layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\"tv_LayerCollapse\", layer_id, int(new_state), error_values=[-2])\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_blending_mode_get","title":"<code>tv_layer_blending_mode_get(layer_id: int) -&gt; BlendingMode</code>","text":"<p>Get the blending mode of the given layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_blending_mode_get(layer_id: int) -&gt; BlendingMode:\n    \"\"\"Get the blending mode of the given layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    res = send_cmd(\"tv_LayerBlendingMode\", layer_id)\n    return tv_cast_to_type(res.lower(), BlendingMode)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_blending_mode_set","title":"<code>tv_layer_blending_mode_set(layer_id: int, mode: BlendingMode) -&gt; None</code>","text":"<p>Set the blending mode of the given layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_blending_mode_set(layer_id: int, mode: BlendingMode) -&gt; None:\n    \"\"\"Set the blending mode of the given layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\"tv_LayerBlendingMode\", layer_id, mode.value)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_stencil_get","title":"<code>tv_layer_stencil_get(layer_id: int) -&gt; StencilMode</code>","text":"<p>Get the stencil state and mode of the given layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_stencil_get(layer_id: int) -&gt; StencilMode:\n    \"\"\"Get the stencil state and mode of the given layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    res = send_cmd(\"tv_LayerStencil\", layer_id)\n    _, state, mode = res.split(\" \")\n\n    if state == \"off\":\n        return StencilMode.OFF\n\n    return tv_cast_to_type(mode, StencilMode)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_stencil_set","title":"<code>tv_layer_stencil_set(layer_id: int, mode: StencilMode) -&gt; None</code>","text":"<p>Set the stencil state and mode of the given layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_stencil_set(layer_id: int, mode: StencilMode) -&gt; None:\n    \"\"\"Set the stencil state and mode of the given layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    if mode == StencilMode.OFF:\n        args = [\"off\"]\n    elif mode == StencilMode.ON:\n        args = [\"on\"]\n    else:\n        args = [\"on\", mode.value]\n\n    send_cmd(\"tv_LayerStencil\", layer_id, *args)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_show_thumbnails_get","title":"<code>tv_layer_show_thumbnails_get(layer_id: int) -&gt; bool</code>","text":"<p>Get the show thumbnails state for a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_show_thumbnails_get(\n    layer_id: int,\n) -&gt; bool:\n    \"\"\"Get the show thumbnails state for a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    res = send_cmd(\n        \"tv_LayerShowThumbnails\", layer_id, error_values=[GrgErrorValue.ERROR]\n    )\n    return res == \"1\"\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_show_thumbnails_set","title":"<code>tv_layer_show_thumbnails_set(layer_id: int, state: bool) -&gt; None</code>","text":"<p>Set the show thumbnail state for a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_show_thumbnails_set(\n    layer_id: int,\n    state: bool,\n) -&gt; None:\n    \"\"\"Set the show thumbnail state for a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\n        \"tv_LayerShowThumbnails\",\n        layer_id,\n        int(state),\n        error_values=[GrgErrorValue.ERROR],\n    )\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_auto_break_instance_get","title":"<code>tv_layer_auto_break_instance_get(layer_id: int) -&gt; bool</code>","text":"<p>Get the layer auto break instance value for a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_auto_break_instance_get(layer_id: int) -&gt; bool:\n    \"\"\"Get the layer auto break instance value for a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    res = send_cmd(\"tv_LayerAutoBreakInstance\", layer_id, error_values=[-1, -2, -3])\n    return res == \"1\"\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_auto_break_instance_set","title":"<code>tv_layer_auto_break_instance_set(layer_id: int, state: bool) -&gt; None</code>","text":"<p>Set the layer auto break instance value for a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_auto_break_instance_set(\n    layer_id: int,\n    state: bool,\n) -&gt; None:\n    \"\"\"Set the layer auto break instance value for a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\n        \"tv_LayerAutoBreakInstance\",\n        layer_id,\n        int(state),\n        error_values=[-1, -2, -3],\n    )\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_auto_create_instance_get","title":"<code>tv_layer_auto_create_instance_get(layer_id: int) -&gt; bool</code>","text":"<p>Get the layer auto create instance value for a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_auto_create_instance_get(\n    layer_id: int,\n) -&gt; bool:\n    \"\"\"Get the layer auto create instance value for a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    res = send_cmd(\"tv_LayerAutoCreateInstance\", layer_id, error_values=[-1, -2, -3])\n    return res == \"1\"\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_auto_create_instance_set","title":"<code>tv_layer_auto_create_instance_set(layer_id: int, state: bool) -&gt; None</code>","text":"<p>Set the layer auto create instance value for a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_auto_create_instance_set(\n    layer_id: int,\n    state: bool,\n) -&gt; None:\n    \"\"\"Set the layer auto create instance value for a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\n        \"tv_LayerAutoCreateInstance\", layer_id, int(state), error_values=[-1, -2, -3]\n    )\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_pre_behavior_get","title":"<code>tv_layer_pre_behavior_get(layer_id: int) -&gt; LayerBehavior</code>","text":"<p>Get the pre-behavior value for a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_pre_behavior_get(layer_id: int) -&gt; LayerBehavior:\n    \"\"\"Get the pre-behavior value for a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    res = send_cmd(\"tv_LayerPreBehavior\", layer_id)\n    return tv_cast_to_type(res, LayerBehavior)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_pre_behavior_set","title":"<code>tv_layer_pre_behavior_set(layer_id: int, behavior: LayerBehavior) -&gt; None</code>","text":"<p>Set the pre-behavior value for a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_pre_behavior_set(layer_id: int, behavior: LayerBehavior) -&gt; None:\n    \"\"\"Set the pre-behavior value for a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\"tv_LayerPreBehavior\", layer_id, behavior.value)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_post_behavior_get","title":"<code>tv_layer_post_behavior_get(layer_id: int) -&gt; LayerBehavior</code>","text":"<p>Get the post-behavior value for a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_post_behavior_get(layer_id: int) -&gt; LayerBehavior:\n    \"\"\"Get the post-behavior value for a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    res = send_cmd(\"tv_LayerPostBehavior\", layer_id)\n    return tv_cast_to_type(res, LayerBehavior)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_post_behavior_set","title":"<code>tv_layer_post_behavior_set(layer_id: int, behavior: LayerBehavior) -&gt; None</code>","text":"<p>Set the post-behavior value for a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_post_behavior_set(layer_id: int, behavior: LayerBehavior) -&gt; None:\n    \"\"\"Set the post-behavior value for a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\"tv_LayerPostBehavior\", layer_id, behavior.value)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_lock_position_get","title":"<code>tv_layer_lock_position_get(layer_id: int) -&gt; bool</code>","text":"<p>Get the lock position state of a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_lock_position_get(layer_id: int) -&gt; bool:\n    \"\"\"Get the lock position state of a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    res = send_cmd(\"tv_LayerLockPosition\", layer_id)\n    return tv_cast_to_type(res, bool)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_lock_position_set","title":"<code>tv_layer_lock_position_set(layer_id: int, state: bool) -&gt; None</code>","text":"<p>Set the lock position state of a layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_lock_position_set(layer_id: int, state: bool) -&gt; None:\n    \"\"\"Set the lock position state of a layer.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\"tv_LayerLockPosition\", layer_id, int(state))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_preserve_get","title":"<code>tv_preserve_get() -&gt; LayerTransparency</code>","text":"<p>Get the preserve transparency state of the current layer.</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_preserve_get() -&gt; LayerTransparency:\n    \"\"\"Get the preserve transparency state of the current layer.\"\"\"\n    res = send_cmd(\"tv_Preserve\")\n    _, state = res.split(\" \")\n    return tv_cast_to_type(state, LayerTransparency)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_preserve_set","title":"<code>tv_preserve_set(state: LayerTransparency) -&gt; None</code>","text":"<p>Set the preserve transparency state of the current layer.</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_preserve_set(state: LayerTransparency) -&gt; None:\n    \"\"\"Set the preserve transparency state of the current layer.\"\"\"\n    send_cmd(\"tv_Preserve\", \"alpha\", state.value)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_mark_get","title":"<code>tv_layer_mark_get(layer_id: int, frame: int) -&gt; int</code>","text":"<p>Get the mark color of a layer at a frame.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>int</code> <p>the layer id</p> required <code>frame</code> <code>int</code> <p>the frame with a mark</p> required <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the mark color index</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_mark_get(layer_id: int, frame: int) -&gt; int:\n    \"\"\"Get the mark color of a layer at a frame.\n\n    Args:\n        layer_id: the layer id\n        frame: the frame with a mark\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n\n    Returns:\n        int: the mark color index\n    \"\"\"\n    return int(send_cmd(\"tv_LayerMarkGet\", layer_id, frame))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_mark_set","title":"<code>tv_layer_mark_set(layer_id: int, frame: int, color_index: int) -&gt; None</code>","text":"<p>Set the mark of the layer's frame.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>int</code> <p>the layer id</p> required <code>frame</code> <code>int</code> <p>the frame to set the mark (use 0 to remove it).</p> required <code>color_index</code> <code>int</code> <p>the mark color</p> required <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_mark_set(layer_id: int, frame: int, color_index: int) -&gt; None:\n    \"\"\"Set the mark of the layer's frame.\n\n    Args:\n        layer_id: the layer id\n        frame: the frame to set the mark (use 0 to remove it).\n        color_index: the mark color\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\"tv_LayerMarkSet\", layer_id, frame, color_index)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_anim","title":"<code>tv_layer_anim(layer_id: int) -&gt; None</code>","text":"<p>Convert the layer to an anim layer.</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_anim(layer_id: int) -&gt; None:\n    \"\"\"Convert the layer to an anim layer.\"\"\"\n    send_cmd(\"tv_LayerAnim\", *([layer_id] if layer_id else []))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_copy","title":"<code>tv_layer_copy() -&gt; None</code>","text":"<p>Copy the current image or the selected ones.</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_copy() -&gt; None:\n    \"\"\"Copy the current image or the selected ones.\"\"\"\n    send_cmd(\"tv_LayerCopy\")\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_cut","title":"<code>tv_layer_cut() -&gt; None</code>","text":"<p>Cut the current image or the selected ones.</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_cut() -&gt; None:\n    \"\"\"Cut the current image or the selected ones.\"\"\"\n    send_cmd(\"tv_LayerCut\")\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_paste","title":"<code>tv_layer_paste() -&gt; None</code>","text":"<p>Paste the previously copied/cut images to the current layer.</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_paste() -&gt; None:\n    \"\"\"Paste the previously copied/cut images to the current layer.\"\"\"\n    send_cmd(\"tv_LayerPaste\")\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_insert_image","title":"<code>tv_layer_insert_image(count: int = 1, direction: InsertDirection | None = None, duplicate: bool | None = None) -&gt; None</code>","text":"<p>Add new image(s) before/after the current one and make it current.</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_insert_image(\n    count: int = 1,\n    direction: InsertDirection | None = None,\n    duplicate: bool | None = None,\n) -&gt; None:\n    \"\"\"Add new image(s) before/after the current one and make it current.\"\"\"\n    if duplicate:\n        args = [0]\n    else:\n        args_dict = {\n            \"count\": count,\n            \"direction\": direction.value if direction is not None else None,\n        }\n        args = args_dict_to_list(args_dict)\n\n    send_cmd(\"tv_LayerInsertImage\", *args)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_merge","title":"<code>tv_layer_merge(layer_id: int, blending_mode: BlendingMode, stamp: bool = False, erase: bool = False, keep_color_grp: bool = True, keep_img_mark: bool = True, keep_instance_name: bool = True) -&gt; None</code>","text":"<p>Merge the given layer with the current one.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>int</code> <p>the layer id</p> required <code>blending_mode</code> <code>pytvpaint.george.grg_base.BlendingMode</code> <p>the blending mode to use</p> required <code>stamp</code> <code>bool</code> <p>Use stamp mode</p> <code>False</code> <code>erase</code> <code>bool</code> <p>Remove the source layer</p> <code>False</code> <code>keep_color_grp</code> <code>bool</code> <p>Keep the color group</p> <code>True</code> <code>keep_img_mark</code> <code>bool</code> <p>Keep the image mark</p> <code>True</code> <code>keep_instance_name</code> <code>bool</code> <p>Keep the instance name</p> <code>True</code> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_merge(\n    layer_id: int,\n    blending_mode: BlendingMode,\n    stamp: bool = False,\n    erase: bool = False,\n    keep_color_grp: bool = True,\n    keep_img_mark: bool = True,\n    keep_instance_name: bool = True,\n) -&gt; None:\n    \"\"\"Merge the given layer with the current one.\n\n    Args:\n        layer_id: the layer id\n        blending_mode: the blending mode to use\n        stamp: Use stamp mode\n        erase: Remove the source layer\n        keep_color_grp: Keep the color group\n        keep_img_mark: Keep the image mark\n        keep_instance_name: Keep the instance name\n    \"\"\"\n    args = [\n        layer_id,\n        blending_mode.value,\n    ]\n\n    if stamp:\n        args.append(\"stamp\")\n    if erase:\n        args.append(\"erase\")\n\n    args_dict = {\n        \"keepcolorgroup\": int(keep_color_grp),\n        \"keepimagemark\": int(keep_img_mark),\n        \"keepinstancename\": int(keep_instance_name),\n    }\n    args.extend(args_dict_to_list(args_dict))\n\n    send_cmd(\"tv_LayerMerge\", layer_id, *args)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_merge_all","title":"<code>tv_layer_merge_all(keep_color_grp: bool = True, keep_img_mark: bool = True, keep_instance_name: bool = True) -&gt; None</code>","text":"<p>Merge all layers.</p> <p>Parameters:</p> Name Type Description Default <code>keep_color_grp</code> <code>bool</code> <p>Keep the color group</p> <code>True</code> <code>keep_img_mark</code> <code>bool</code> <p>Keep the image mark</p> <code>True</code> <code>keep_instance_name</code> <code>bool</code> <p>Keep the instance name</p> <code>True</code> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_merge_all(\n    keep_color_grp: bool = True,\n    keep_img_mark: bool = True,\n    keep_instance_name: bool = True,\n) -&gt; None:\n    \"\"\"Merge all layers.\n\n    Args:\n        keep_color_grp: Keep the color group\n        keep_img_mark: Keep the image mark\n        keep_instance_name: Keep the instance name\n    \"\"\"\n    args_dict = {\n        \"keepcolorgroup\": int(keep_color_grp),\n        \"keepimagemark\": int(keep_img_mark),\n        \"keepinstancename\": int(keep_instance_name),\n    }\n    send_cmd(\"tv_LayerMergeAll\", *args_dict_to_list(args_dict))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_shift","title":"<code>tv_layer_shift(layer_id: int, start: int) -&gt; None</code>","text":"<p>Move the layer to a new frame.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>int</code> <p>layer id</p> required <code>start</code> <code>int</code> <p>frame to shift layer to</p> required Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_shift(layer_id: int, start: int) -&gt; None:\n    \"\"\"Move the layer to a new frame.\n\n    Args:\n        layer_id: layer id\n        start: frame to shift layer to\n    \"\"\"\n    send_cmd(\"tv_LayerShift\", layer_id, start)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_load_dependencies","title":"<code>tv_layer_load_dependencies(layer_id: int) -&gt; None</code>","text":"<p>Load all dependencies of the given layer in memory.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_load_dependencies(layer_id: int) -&gt; None:\n    \"\"\"Load all dependencies of the given layer in memory.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\"tv_LayerLoadDependencies\", layer_id)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_color_get_color","title":"<code>tv_layer_color_get_color(clip_id: int, color_index: int) -&gt; TVPClipLayerColor</code>","text":"<p>Get a specific colors information in the clips color list.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_color_get_color(clip_id: int, color_index: int) -&gt; TVPClipLayerColor:\n    \"\"\"Get a specific colors information in the clips color list.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    result = send_cmd(\n        \"tv_LayerColor\",\n        LayerColorAction.GETCOLOR.value,\n        clip_id,\n        color_index,\n        error_values=[GrgErrorValue.ERROR],\n    )\n    parsed = tv_parse_list(result, with_fields=TVPClipLayerColor)\n    return TVPClipLayerColor(**parsed)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_color_set_color","title":"<code>tv_layer_color_set_color(clip_id: int, color_index: int, color: RGBColor, name: str | None = None) -&gt; None</code>","text":"<p>Set a specific colors information in the clips color list.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Note <p>The color with index 0 is the \"Default\" color, and it can't be changed</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_color_set_color(\n    clip_id: int,\n    color_index: int,\n    color: RGBColor,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Set a specific colors information in the clips color list.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n\n    Note:\n        The color with index 0 is the \"Default\" color, and it can't be changed\n    \"\"\"\n    args: list[Any] = [\n        LayerColorAction.SETCOLOR.value,\n        clip_id,\n        color_index,\n        color.r,\n        color.g,\n        color.b,\n    ]\n\n    if name:\n        args.append(name)\n\n    send_cmd(\"tv_LayerColor\", *args, error_values=[GrgErrorValue.ERROR])\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_color_get","title":"<code>tv_layer_color_get(layer_id: int) -&gt; int</code>","text":"<p>Get the layer's color index from the clips color list.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_color_get(layer_id: int) -&gt; int:\n    \"\"\"Get the layer's color index from the clips color list.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    res = send_cmd(\n        \"tv_LayerColor\",\n        LayerColorAction.GET.value,\n        layer_id,\n        error_values=[-1],\n    )\n    return int(res)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_color_set","title":"<code>tv_layer_color_set(layer_id: int, color_index: int) -&gt; None</code>","text":"<p>Set the layer's color index from the clips color list.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(raise_exc=NoObjectWithIdError)\ndef tv_layer_color_set(layer_id: int, color_index: int) -&gt; None:\n    \"\"\"Set the layer's color index from the clips color list.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    send_cmd(\n        \"tv_LayerColor\",\n        LayerColorAction.SET.value,\n        layer_id,\n        color_index,\n        error_values=[-1],\n    )\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_color_lock","title":"<code>tv_layer_color_lock(color_index: int) -&gt; int</code>","text":"<p>Lock all layers that use the given color index.</p> <p>Parameters:</p> Name Type Description Default <code>color_index</code> <code>int</code> <p>the layer color index</p> required <p>Returns:</p> Type Description <code>int</code> <p>the number of layers locked</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_color_lock(color_index: int) -&gt; int:\n    \"\"\"Lock all layers that use the given color index.\n\n    Args:\n        color_index: the layer color index\n\n    Returns:\n        the number of layers locked\n    \"\"\"\n    return int(send_cmd(\"tv_LayerColor\", LayerColorAction.LOCK.value, color_index))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_color_unlock","title":"<code>tv_layer_color_unlock(color_index: int) -&gt; int</code>","text":"<p>Unlock all layers that use the given color index.</p> <p>Parameters:</p> Name Type Description Default <code>color_index</code> <code>int</code> <p>the layer color index</p> required <p>Returns:</p> Type Description <code>int</code> <p>the number of unlocked layers</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_color_unlock(color_index: int) -&gt; int:\n    \"\"\"Unlock all layers that use the given color index.\n\n    Args:\n        color_index: the layer color index\n\n    Returns:\n        the number of unlocked layers\n    \"\"\"\n    return int(send_cmd(\"tv_LayerColor\", LayerColorAction.UNLOCK.value, color_index))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_color_show","title":"<code>tv_layer_color_show(mode: LayerColorDisplayOpt, color_index: int) -&gt; int</code>","text":"<p>Show all layers that use the given color index.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>pytvpaint.george.grg_layer.LayerColorDisplayOpt</code> <p>the display mode</p> required <code>color_index</code> <code>int</code> <p>the layer color index</p> required <p>Returns:</p> Type Description <code>int</code> <p>the number of unlocked layers</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_color_show(mode: LayerColorDisplayOpt, color_index: int) -&gt; int:\n    \"\"\"Show all layers that use the given color index.\n\n    Args:\n        mode: the display mode\n        color_index: the layer color index\n\n    Returns:\n        the number of unlocked layers\n    \"\"\"\n    res = send_cmd(\n        \"tv_LayerColor\",\n        LayerColorAction.SHOW.value,\n        mode.value,\n        color_index,\n        error_values=[GrgErrorValue.ERROR],\n    )\n    return int(res)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_color_hide","title":"<code>tv_layer_color_hide(mode: LayerColorDisplayOpt, color_index: int) -&gt; int</code>","text":"<p>Hide all layers that use the given color index.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>pytvpaint.george.grg_layer.LayerColorDisplayOpt</code> <p>the display mode</p> required <code>color_index</code> <code>int</code> <p>the layer color index</p> required <p>Returns:</p> Type Description <code>int</code> <p>the number of unlocked layers</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_layer_color_hide(mode: LayerColorDisplayOpt, color_index: int) -&gt; int:\n    \"\"\"Hide all layers that use the given color index.\n\n    Args:\n        mode: the display mode\n        color_index: the layer color index\n\n    Returns:\n        the number of unlocked layers\n    \"\"\"\n    return int(\n        send_cmd(\n            \"tv_LayerColor\",\n            LayerColorAction.HIDE.value,\n            mode.value,\n            color_index,\n            error_values=[GrgErrorValue.ERROR],\n        )\n    )\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_color_visible","title":"<code>tv_layer_color_visible(color_index: int) -&gt; bool</code>","text":"<p>Get the visibility of the color index (2px height) in the timeline.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id\",\n)\ndef tv_layer_color_visible(color_index: int) -&gt; bool:\n    \"\"\"Get the visibility of the color index (2px height) in the timeline.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    return bool(\n        send_cmd(\n            \"tv_LayerColor\",\n            LayerColorAction.VISIBLE.value,\n            color_index,\n            error_values=[-1],\n        )\n    )\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_color_select","title":"<code>tv_layer_color_select(color_index: int) -&gt; int</code>","text":"<p>Select all layers that use the given color index.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid color index\",\n)\ndef tv_layer_color_select(color_index: int) -&gt; int:\n    \"\"\"Select all layers that use the given color index.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    return int(send_cmd(\"tv_LayerColor\", LayerColorAction.SELECT.value, color_index))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_layer_color_unselect","title":"<code>tv_layer_color_unselect(color_index: int) -&gt; int</code>","text":"<p>Unselect all layers that use the given color index.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid color index\",\n)\ndef tv_layer_color_unselect(color_index: int) -&gt; int:\n    \"\"\"Unselect all layers that use the given color index.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id\n    \"\"\"\n    return int(send_cmd(\"tv_LayerColor\", LayerColorAction.UNSELECT.value, color_index))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_instance_name","title":"<code>tv_instance_name(layer_id: int, mode: InstanceNamingMode, prefix: str | None = None, suffix: str | None = None, process: InstanceNamingProcess | None = None) -&gt; None</code>","text":"<p>Rename all instances.</p> Note <p>The suffix can only be added when using mode InstanceNamingMode.SMART</p> Bug <p>Using a wrong layer_id causes a crash</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>int</code> <p>the layer id</p> required <code>mode</code> <code>pytvpaint.george.grg_layer.InstanceNamingMode</code> <p>the instance renaming mode</p> required <code>prefix</code> <code>str | None</code> <p>the prefix to add to each name</p> <code>None</code> <code>suffix</code> <code>str | None</code> <p>the suffix to add to each name</p> <code>None</code> <code>process</code> <code>pytvpaint.george.grg_layer.InstanceNamingProcess | None</code> <p>the instance naming process</p> <code>None</code> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_instance_name(\n    layer_id: int,\n    mode: InstanceNamingMode,\n    prefix: str | None = None,\n    suffix: str | None = None,\n    process: InstanceNamingProcess | None = None,\n) -&gt; None:\n    \"\"\"Rename all instances.\n\n    Note:\n        The suffix can only be added when using mode InstanceNamingMode.SMART\n\n    Bug:\n        Using a wrong layer_id causes a crash\n\n    Args:\n        layer_id: the layer id\n        mode: the instance renaming mode\n        prefix: the prefix to add to each name\n        suffix: the suffix to add to each name\n        process: the instance naming process\n    \"\"\"\n    args_dict: dict[str, Any] = {\n        \"mode\": mode.value,\n        \"prefix\": prefix,\n    }\n\n    if mode == InstanceNamingMode.SMART:\n        args_dict[\"suffix\"] = suffix\n        args_dict[\"process\"] = process.value if process else None\n\n    args = args_dict_to_list(args_dict)\n    send_cmd(\"tv_InstanceName\", layer_id, *args, error_values=[-1, -2])\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_instance_get_name","title":"<code>tv_instance_get_name(layer_id: int, frame: int) -&gt; str</code>","text":"<p>Get the name of an instance.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>int</code> <p>the layer id</p> required <code>frame</code> <code>int</code> <p>the frame of the instance</p> required <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid layer id or an invalid instance frame</p> <p>Returns:</p> Type Description <code>str</code> <p>the instance name</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid layer id or the frame doesn't have an instance\",\n)\ndef tv_instance_get_name(layer_id: int, frame: int) -&gt; str:\n    \"\"\"Get the name of an instance.\n\n    Args:\n        layer_id: the layer id\n        frame: the frame of the instance\n\n    Raises:\n        NoObjectWithIdError: if given an invalid layer id or an invalid instance frame\n\n    Returns:\n        the instance name\n    \"\"\"\n    return send_cmd(\"tv_InstanceGetName\", layer_id, frame).strip('\"')\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_instance_set_name","title":"<code>tv_instance_set_name(layer_id: int, frame: int, name: str) -&gt; str</code>","text":"<p>Set the name of an instance.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if an invalid layer id was provided or no instance was found at the given frame</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(exception_msg=\"Invalid layer id or no instance at given frame\")\ndef tv_instance_set_name(layer_id: int, frame: int, name: str) -&gt; str:\n    \"\"\"Set the name of an instance.\n\n    Raises:\n        GeorgeError: if an invalid layer id was provided or no instance was found at the given frame\n    \"\"\"\n    return send_cmd(\"tv_InstanceSetName\", layer_id, frame, name)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_exposure_next","title":"<code>tv_exposure_next() -&gt; int</code>","text":"<p>Go to the next layer instance head.</p> <p>Returns:</p> Type Description <code>int</code> <p>The next instances start frame</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_exposure_next() -&gt; int:\n    \"\"\"Go to the next layer instance head.\n\n    Returns:\n        The next instances start frame\n    \"\"\"\n    return int(send_cmd(\"tv_ExposureNext\"))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_exposure_break","title":"<code>tv_exposure_break(frame: int) -&gt; None</code>","text":"<p>Break a layer instance/exposure at the given frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>the split frame</p> required Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_exposure_break(frame: int) -&gt; None:\n    \"\"\"Break a layer instance/exposure at the given frame.\n\n    Args:\n        frame: the split frame\n    \"\"\"\n    send_cmd(\"tv_ExposureBreak\", frame)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_exposure_add","title":"<code>tv_exposure_add(frame: int, count: int) -&gt; None</code>","text":"<p>Add new frames to an existing layer instance/exposure.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>the split frame</p> required <code>count</code> <code>int</code> <p>the number of frames to add</p> required Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_exposure_add(frame: int, count: int) -&gt; None:\n    \"\"\"Add new frames to an existing layer instance/exposure.\n\n    Args:\n        frame: the split frame\n        count: the number of frames to add\n    \"\"\"\n    send_cmd(\"tv_ExposureAdd\", frame, count)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_exposure_set","title":"<code>tv_exposure_set(frame: int, count: int) -&gt; None</code>","text":"<p>Set the number frames of an existing layer instance/exposure.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>the split frame</p> required <code>count</code> <code>int</code> <p>the number of frames to add</p> required Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_exposure_set(frame: int, count: int) -&gt; None:\n    \"\"\"Set the number frames of an existing layer instance/exposure.\n\n    Args:\n        frame: the split frame\n        count: the number of frames to add\n    \"\"\"\n    send_cmd(\"tv_ExposureSet\", frame, count)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_exposure_prev","title":"<code>tv_exposure_prev() -&gt; int</code>","text":"<p>Go to the previous layer instance head (before the current instance).</p> <p>Returns:</p> Type Description <code>int</code> <p>The previous instances start frame</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_exposure_prev() -&gt; int:\n    \"\"\"Go to the previous layer instance head (*before* the current instance).\n\n    Returns:\n        The previous instances start frame\n    \"\"\"\n    return int(send_cmd(\"tv_ExposurePrev\"))\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_save_image","title":"<code>tv_save_image(export_path: Path | str) -&gt; None</code>","text":"<p>Save the current image of the current layer.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if the file couldn't be saved or an invalid format was provided</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(exception_msg=\"No file found or invalid format\")\ndef tv_save_image(export_path: Path | str) -&gt; None:\n    \"\"\"Save the current image of the current layer.\n\n    Raises:\n        GeorgeError: if the file couldn't be saved or an invalid format was provided\n    \"\"\"\n    export_path = Path(export_path)\n    send_cmd(\"tv_SaveImage\", export_path.as_posix())\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_load_image","title":"<code>tv_load_image(img_path: Path | str, stretch: bool = False) -&gt; None</code>","text":"<p>Load an image in the current image layer.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the input file doesn't exist</p> <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if the provided file is in an invalid format</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>@try_cmd(exception_msg=\"Invalid image format\")\ndef tv_load_image(img_path: Path | str, stretch: bool = False) -&gt; None:\n    \"\"\"Load an image in the current image layer.\n\n    Raises:\n        FileNotFoundError: if the input file doesn't exist\n        GeorgeError: if the provided file is in an invalid format\n    \"\"\"\n    img_path = Path(img_path)\n\n    if not img_path.exists():\n        raise FileNotFoundError(f\"File not found at: {img_path.as_posix()}\")\n\n    args: list[Any] = [img_path.as_posix()]\n    if stretch:\n        args.append(\"stretch\")\n\n    send_cmd(\"tv_LoadImage\", *args)\n</code></pre>"},{"location":"api/george/layer/#pytvpaint.george.grg_layer.tv_clear","title":"<code>tv_clear(fill_b_pen: bool = False) -&gt; None</code>","text":"<p>Clear (or fill with BPen) the current image (selection) of the current layer.</p> Source code in <code>pytvpaint/george/grg_layer.py</code> <pre><code>def tv_clear(fill_b_pen: bool = False) -&gt; None:\n    \"\"\"Clear (or fill with BPen) the current image (selection) of the current layer.\"\"\"\n    send_cmd(\"tv_Clear\", int(fill_b_pen))\n</code></pre>"},{"location":"api/george/misc/","title":"Miscellaneous George functions","text":"<p>All George values as enum and functions which are not specific to any TVPaint element.</p>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.GrgErrorValue","title":"<code>GrgErrorValue</code>","text":"<p>Common George error values.</p> <p>Attributes:</p> Name Type Description <code>EMPTY</code> <code>str</code> <p>See <code>tv_clipinfo</code> for example</p> <code>NONE</code> <code>str</code> <p>See <code>tv_clipenumid</code> for example</p> <code>ERROR</code> <code>str</code> <p>See <code>tv_setapen</code> for example</p>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.GrgBoolState","title":"<code>GrgBoolState</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>George booleans.</p> <p>Attributes:</p> Name Type Description <code>ON</code> <code>OFF</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.FieldOrder","title":"<code>FieldOrder</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Field order of the camera.</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <code>LOWER</code> <code>UPPER</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.MarkType","title":"<code>MarkType</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>The mark command.</p> <p>Attributes:</p> Name Type Description <code>MARKIN</code> <code>MARKOUT</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.MarkReference","title":"<code>MarkReference</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>The object to mark.</p> <p>Attributes:</p> Name Type Description <code>PROJECT</code> <code>CLIP</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.MarkAction","title":"<code>MarkAction</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>The mark action.</p> <p>Attributes:</p> Name Type Description <code>SET</code> <code>CLEAR</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.RectButton","title":"<code>RectButton</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>The rect button when drawing.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <code>RIGHT</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.TVPShape","title":"<code>TVPShape</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>The shape tools.</p> <p>Attributes:</p> Name Type Description <code>B_SPLINE</code> <code>BEZIER</code> <code>BEZIER_FILL</code> <code>CAMERA</code> <code>CIRCLE</code> <code>CIRCLE_2PTS</code> <code>CIRCLE_3PTS</code> <code>CIRCLE_FILL</code> <code>CIRCLE_2PTS_FILL</code> <code>CIRCLE_3PTS_FILL</code> <code>CROP</code> <code>CUT_RECT</code> <code>CUT_POLY</code> <code>CUT_FREE_HAND</code> <code>CUT_FLOOD</code> <code>DOT</code> <code>FLOOD</code> <code>FREE_HAND_LINE</code> <code>FREE_HAND_FILL</code> <code>ELLIPSE</code> <code>ELLIPSE_FILL</code> <code>ELLIPSE_2PTS</code> <code>ELLIPSE_2PTS_FILL</code> <code>LINE</code> <code>LINE_FILL</code> <code>PLANNING</code> <code>POSITION</code> <code>RECTANGLE</code> <code>RECTANGLE_FILL</code> <code>SELECT_RECTANGLE</code> <code>SELECT_ELLIPSE</code> <code>SELECT_2PTS</code> <code>SELECT_3PTS</code> <code>SELECT_POLY</code> <code>SELECT_FREE_HAND</code> <code>SELECT_FLOOD</code> <code>SELECT_COLOR</code> <code>SELECT_BEZIER</code> <code>SELECT_B_SPLINE</code> <code>SINGLE_DOT</code> <code>SPLIT_3PTS</code> <code>SPLINE_FILL</code> <code>WARP</code> <code>WRAP</code> <code>ZOOM_IN</code> <code>ZOOM_OUT</code> <code>ZOOM_HAND</code> <code>ZOOM_RECT</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.ResizeOption","title":"<code>ResizeOption</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Resize options for projects.</p> <p>Attributes:</p> Name Type Description <code>EMPTY</code> <code>CROP</code> <code>STRETCH</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.SpriteLayout","title":"<code>SpriteLayout</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Sprite layout when exporting as sprites.</p> <p>Attributes:</p> Name Type Description <code>RECTANGLE</code> <code>HORIZONTAL</code> <code>VERTICAL</code> <code>DIAGONAL</code> <code>ANTI_DIAGONAL</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.AlphaMode","title":"<code>AlphaMode</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>The alpha load mode.</p> <p>Attributes:</p> Name Type Description <code>PREMULTIPLY</code> <code>NO_PREMULTIPLY</code> <code>NO_ALPHA</code> <code>ALPHA_ONLY</code> <code>GUESS</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.AlphaSaveMode","title":"<code>AlphaSaveMode</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>The alpha save mode.</p> <p>Attributes:</p> Name Type Description <code>PREMULTIPLY</code> <code>NO_PREMULTIPLY</code> <code>NO_ALPHA</code> <code>ALPHA_ONLY</code> <code>GUESS</code> <code>ALPHA_BINARY</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.SaveFormat","title":"<code>SaveFormat</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>All save formats.</p> <p>Attributes:</p> Name Type Description <code>AVI</code> <code>BMP</code> <code>CINEON</code> <code>DEEP</code> <code>DPX</code> <code>FLI</code> <code>GIF</code> <code>ILBM</code> <code>JPG</code> <p>jpeg</p> <code>MKV</code> <p>Mode=1017</p> <code>MOV</code> <p>Mode=1015</p> <code>MP4</code> <p>Mode=1016</p> <code>PCX</code> <code>PDF</code> <code>PNG</code> <code>PSD</code> <code>SGI</code> <p>Mode=16</p> <code>SOFTIMAGE</code> <p>Mode=10</p> <code>SUNRASTER</code> <p>sun</p> <code>TGA</code> <p>tga</p> <code>TIFF</code> <p>Mode=15</p> <code>VPB</code> <code>WEBM</code> <p>Mode=1018</p>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.SaveFormat.from_extension","title":"<code>from_extension(extension: str) -&gt; SaveFormat</code>  <code>classmethod</code>","text":"<p>Returns the correct tvpaint format value from a string extension.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>@classmethod\ndef from_extension(cls, extension: str) -&gt; SaveFormat:\n    \"\"\"Returns the correct tvpaint format value from a string extension.\"\"\"\n    extension = extension.replace(\".\", \"\").upper()\n    if not hasattr(SaveFormat, extension):\n        raise ValueError(\n            f\"Could not find format ({extension}) in accepted formats ({SaveFormat})\"\n        )\n    return cast(SaveFormat, getattr(cls, extension.upper()))\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.SaveFormat.is_image","title":"<code>is_image(extension: str) -&gt; bool</code>  <code>classmethod</code>","text":"<p>Returns True if the extension correspond to an image format.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>@classmethod\ndef is_image(cls, extension: str) -&gt; bool:\n    \"\"\"Returns True if the extension correspond to an image format.\"\"\"\n    extension = extension.replace(\".\", \"\").lower()\n    image_formats = [\n        \"bmp\",\n        \"cin\",\n        \"deep\",\n        \"dpx\",\n        \"ilbm\",\n        \"jpg\",\n        \"jpeg\",\n        \"pcx\",\n        \"png\",\n        \"psd\",\n        \"sgi\",\n        \"pic\",\n        \"ras\",\n        \"sun\",\n        \"tga\",\n        \"tiff\",\n    ]\n    return extension in image_formats\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.RGBColor","title":"<code>RGBColor(r: int, g: int, b: int)</code>  <code>dataclass</code>","text":"<p>RGB color with 0-255 range values.</p>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.HSLColor","title":"<code>HSLColor(h: int, s: int, l: int)</code>  <code>dataclass</code>","text":"<p>HSL color. Maximum values are (360, 100, 100) for h, s, l.</p>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.BlendingMode","title":"<code>BlendingMode</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>All the blending modes.</p> <p>Attributes:</p> Name Type Description <code>COLOR</code> <code>BEHIND</code> <code>ERASE</code> <code>SHADE</code> <code>LIGHT</code> <code>COLORIZE</code> <code>HUE</code> <code>SATURATION</code> <code>VALUE</code> <code>ADD</code> <code>SUB</code> <code>MULTIPLY</code> <code>SCREEN</code> <code>REPLACE</code> <code>COPY</code> <code>DIFFERENCE</code> <code>DIVIDE</code> <code>OVERLAY</code> <code>OVERLAY2</code> <code>LIGHT2</code> <code>SHADE2</code> <code>HARDLIGHT</code> <code>SOFTLIGHT</code> <code>GRAIN_EXTRACT</code> <code>GRAIN_MERGE</code> <code>SUB2</code> <code>DARKEN</code> <code>LIGHTEN</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.DrawingMode","title":"<code>DrawingMode</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>All the drawing modes.</p> <p>Attributes:</p> Name Type Description <code>COLOR</code> <code>BEHIND</code> <code>ERASE</code> <code>PANTO</code> <code>MERGE</code> <code>SHADE</code> <code>LIGHT</code> <code>COLORIZE</code> <code>TINT</code> <code>GRAIN</code> <code>BLUR</code> <code>NOISE</code> <code>NEGATIVE</code> <code>SHARP</code> <code>EMBOSS</code> <code>SOLARIZE</code> <code>SATURATE</code> <code>UNSATURATE</code> <code>ADD</code> <code>SUB</code> <code>MULTIPLY</code> <code>SCREEN</code> <code>DIFF</code> <code>HEALING</code> <code>BURN</code> <code>DODGE</code> <code>DARKEN</code> <code>LIGHTEN</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.MenuElement","title":"<code>MenuElement</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>All the TVPaint menu elements.</p> <p>Attributes:</p> Name Type Description <code>SHOW_UI</code> <code>HIDE_UI</code> <code>RESIZE_UI</code> <code>CENTER_DISPLAY</code> <code>FIT_DISPLAY</code> <code>FRONT</code> <code>BACK</code> <code>ASPECT_RATIO</code> <code>CLIP</code> <code>PROJECT</code> <code>XSHEET</code> <code>NOTES</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.FileMode","title":"<code>FileMode</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>File mode save or load.</p> <p>Attributes:</p> Name Type Description <code>SAVE</code> <code>LOAD</code>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.TVPPenBrush","title":"<code>TVPPenBrush(mode: DrawingMode, size: float, power: int, opacity: int, dry: bool, aaliasing: bool, gradient: bool, csize: str, cpower: str)</code>  <code>dataclass</code>","text":"<p>A TVPaint brush.</p>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.TVPSound","title":"<code>TVPSound(offset: float, volume: float, mute: bool, fade_in_start: float, fade_in_stop: float, fade_out_start: float, fade_out_stop: float, path: Path, sound_in: float, sound_out: float, color_index: int)</code>  <code>dataclass</code>","text":"<p>A TVPaint sound (clip and project).</p>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.undoable","title":"<code>undoable(func: T) -&gt; T</code>","text":"<p>Decorator to register actions in the TVPaint undo stack.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def undoable(func: T) -&gt; T:\n    \"\"\"Decorator to register actions in the TVPaint undo stack.\"\"\"\n\n    def wrapper(*args: Any, **kwargs: Any) -&gt; T:\n        tv_undo_open_stack()\n        res = func(*args, **kwargs)\n        tv_undo_close_stack(func.__name__)\n        return cast(T, res)\n\n    return cast(T, wrapper)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.undoable_stack","title":"<code>undoable_stack() -&gt; Generator[None, None, None]</code>","text":"<p>Context manager that creates an undo stack. Useful to undo a sequence of George actions.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>@contextlib.contextmanager\ndef undoable_stack() -&gt; Generator[None, None, None]:\n    \"\"\"Context manager that creates an undo stack. Useful to undo a sequence of George actions.\"\"\"\n    tv_undo_open_stack()\n    yield\n    tv_undo_close_stack()\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_warn","title":"<code>tv_warn(msg: str) -&gt; None</code>","text":"<p>Display a warning message.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_warn(msg: str) -&gt; None:\n    \"\"\"Display a warning message.\"\"\"\n    send_cmd(\"tv_Warn\", msg)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_version","title":"<code>tv_version() -&gt; tuple[str, str, str]</code>","text":"<p>Returns the software name, version and language.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_version() -&gt; tuple[str, str, str]:\n    \"\"\"Returns the software name, version and language.\"\"\"\n    cmd_fields = [\n        (\"software_name\", str),\n        (\"version\", str),\n        (\"language\", str),\n    ]\n    res = tv_parse_list(send_cmd(\"tv_Version\"), with_fields=cmd_fields)\n    software_name, version, language = res.values()\n    return software_name, version, language\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_quit","title":"<code>tv_quit() -&gt; None</code>","text":"<p>Closes the TVPaint instance.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_quit() -&gt; None:\n    \"\"\"Closes the TVPaint instance.\"\"\"\n    send_cmd(\"tv_Quit\")\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_host2back","title":"<code>tv_host2back() -&gt; None</code>","text":"<p>Minimize the TVPaint window.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_host2back() -&gt; None:\n    \"\"\"Minimize the TVPaint window.\"\"\"\n    send_cmd(\"tv_Host2Back\")\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_host2front","title":"<code>tv_host2front() -&gt; None</code>","text":"<p>Restore the TVPaint window after being minimized.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_host2front() -&gt; None:\n    \"\"\"Restore the TVPaint window after being minimized.\"\"\"\n    send_cmd(\"tv_Host2Front\")\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_menu_hide","title":"<code>tv_menu_hide() -&gt; None</code>","text":"<p>Switch to inlay view and hide all non-docking panels.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_menu_hide() -&gt; None:\n    \"\"\"Switch to inlay view and hide all non-docking panels.\"\"\"\n    send_cmd(\"tv_MenuHide\")\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.add_some_magic","title":"<code>add_some_magic(i_am_a_badass: bool = False, magic_number: int | None = None) -&gt; None</code>","text":"<p>Don't use ! Will change your life forever...</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def add_some_magic(\n    i_am_a_badass: bool = False, magic_number: int | None = None\n) -&gt; None:\n    \"\"\"Don't use ! Will change your life forever...\"\"\"\n    if not i_am_a_badass:\n        log.warning(\"Sorry, you're not enough of a badass for this function...\")\n\n    magic_number = magic_number or 14\n    send_cmd(\"tv_MagicNumber\", magic_number)\n    log.info(\"Totally worth it, right ? ^^\")\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_menu_show","title":"<code>tv_menu_show(menu_element: MenuElement | None = None, *menu_options: Any, current: bool = False) -&gt; None</code>","text":"<p>For the complete documentation, see: https://www.tvpaint.com/doc/tvpaint-animation-11/george-commands#tv_menushow.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_menu_show(\n    menu_element: MenuElement | None = None, *menu_options: Any, current: bool = False\n) -&gt; None:\n    \"\"\"For the complete documentation, see: https://www.tvpaint.com/doc/tvpaint-animation-11/george-commands#tv_menushow.\"\"\"\n    cmd_args: list[str] = []\n\n    if current:\n        cmd_args.append(\"current\")\n\n    if menu_element:\n        cmd_args.append(menu_element.value)\n\n    send_cmd(\"tv_MenuShow\", *cmd_args, *menu_options)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_request","title":"<code>tv_request(msg: str, confirm_text: str = 'Yes', cancel_text: str = 'No') -&gt; bool</code>","text":"<p>Open a confirmation prompt with a message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>the message to display</p> required <code>confirm_text</code> <code>str</code> <p>the confirm button text. Defaults to \"Yes\".</p> <code>'Yes'</code> <code>cancel_text</code> <code>str</code> <p>the cancel button text. Defaults to \"No\".</p> <code>'No'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if clicked on \"Yes\"</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_request(msg: str, confirm_text: str = \"Yes\", cancel_text: str = \"No\") -&gt; bool:\n    \"\"\"Open a confirmation prompt with a message.\n\n    Args:\n        msg: the message to display\n        confirm_text: the confirm button text. Defaults to \"Yes\".\n        cancel_text: the cancel button text. Defaults to \"No\".\n\n    Returns:\n        bool: True if clicked on \"Yes\"\n    \"\"\"\n    return bool(int(send_cmd(\"tv_Request\", msg, confirm_text, cancel_text)))\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_req_num","title":"<code>tv_req_num(value: int, min: int, max: int, title: str = 'Enter Value') -&gt; int | None</code>","text":"<p>Open a prompt to request an integer (within a range).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the initial value</p> required <code>min</code> <code>int</code> <p>the minimum value</p> required <code>max</code> <code>int</code> <p>the maximum value</p> required <code>title</code> <code>str</code> <p>title of the prompt dialog. Defaults to \"Enter Value\".</p> <code>'Enter Value'</code> <p>Returns:</p> Type Description <code>int | None</code> <p>the value or None if cancelled</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_req_num(\n    value: int, min: int, max: int, title: str = \"Enter Value\"\n) -&gt; int | None:\n    \"\"\"Open a prompt to request an integer (within a range).\n\n    Args:\n        value: the initial value\n        min: the minimum value\n        max: the maximum value\n        title: title of the prompt dialog. Defaults to \"Enter Value\".\n\n    Returns:\n        the value or None if cancelled\n    \"\"\"\n    res = send_cmd(\"tv_ReqNum\", value, min, max, title, handle_string=False)\n    return None if res.lower() == \"cancel\" else int(res)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_req_angle","title":"<code>tv_req_angle(value: float, min: float, max: float, title: str = 'Enter Value') -&gt; float | None</code>","text":"<p>Open a prompt to request an angle (in degree).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>the initial value</p> required <code>min</code> <code>float</code> <p>the minimum value</p> required <code>max</code> <code>float</code> <p>the maximum value</p> required <code>title</code> <code>str</code> <p>title of the prompt. Defaults to \"Enter Value\".</p> <code>'Enter Value'</code> <p>Returns:</p> Type Description <code>float | None</code> <p>the value or None if cancelled</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_req_angle(\n    value: float, min: float, max: float, title: str = \"Enter Value\"\n) -&gt; float | None:\n    \"\"\"Open a prompt to request an angle (in degree).\n\n    Args:\n        value: the initial value\n        min: the minimum value\n        max: the maximum value\n        title: title of the prompt. Defaults to \"Enter Value\".\n\n    Returns:\n        the value or None if cancelled\n    \"\"\"\n    res = send_cmd(\"tv_ReqAngle\", value, min, max, title, handle_string=False)\n    return None if res.lower() == \"cancel\" else float(res)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_req_float","title":"<code>tv_req_float(value: float, min: float, max: float, title: str = 'Enter value') -&gt; float | None</code>","text":"<p>Open a prompt to request a float.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>the initial value</p> required <code>min</code> <code>float</code> <p>the minimum value</p> required <code>max</code> <code>float</code> <p>the maximum value</p> required <code>title</code> <code>str</code> <p>title of the prompt. Defaults to \"Enter Value\".</p> <code>'Enter value'</code> <p>Returns:</p> Type Description <code>float | None</code> <p>the value or None if cancelled</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_req_float(\n    value: float, min: float, max: float, title: str = \"Enter value\"\n) -&gt; float | None:\n    \"\"\"Open a prompt to request a float.\n\n    Args:\n        value: the initial value\n        min: the minimum value\n        max: the maximum value\n        title: title of the prompt. Defaults to \"Enter Value\".\n\n    Returns:\n        the value or None if cancelled\n    \"\"\"\n    res = send_cmd(\"tv_ReqFloat\", value, min, max, title, handle_string=False)\n    return None if res.lower() == \"cancel\" else float(res)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_req_string","title":"<code>tv_req_string(title: str, text: str) -&gt; str | None</code>","text":"<p>Open a prompt to request a string.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>title of the requester. Defaults to \"Enter Value\".</p> required <code>text</code> <code>str</code> <p>the initial value</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>the value or None if cancelled</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_req_string(title: str, text: str) -&gt; str | None:\n    \"\"\"Open a prompt to request a string.\n\n    Args:\n        title: title of the requester. Defaults to \"Enter Value\".\n        text: the initial value\n\n    Returns:\n        the value or None if cancelled\n    \"\"\"\n    cmd_args = [\"|\".join([title, text])]\n    if \"\\n\" in text:\n        cmd_args.insert(0, \"multiline\")\n    res = send_cmd(\"tv_ReqString\", *cmd_args, handle_string=False)\n    return None if res.lower() == \"cancel\" else res\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_list_request","title":"<code>tv_list_request(entries: list[Entry]) -&gt; tuple[int, str]</code>","text":"<p>Open a prompt to request a selection in a list.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>list[pytvpaint.george.grg_base.Entry]</code> <p>the list of entries (either a single entry or sub entries)</p> required <p>Returns:</p> Type Description <code>tuple[int, str]</code> <p>the position, the entry</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_list_request(entries: list[Entry]) -&gt; tuple[int, str]:\n    \"\"\"Open a prompt to request a selection in a list.\n\n    Args:\n        entries: the list of entries (either a single entry or sub entries)\n\n    Returns:\n        the position, the entry\n    \"\"\"\n    entries_str = \"|\".join(map(_entry_to_str, entries))\n    res = send_cmd(\"tv_ListRequest\", entries_str, error_values=[\"-1 Cancel\"])\n    res_obj = tv_parse_list(\n        res,\n        with_fields=[\n            (\"index\", int),\n            (\"entry\", str),\n        ],\n    )\n    index, entry = tuple(res_obj.values())\n    return int(index), entry\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_req_file","title":"<code>tv_req_file(mode: FileMode, title: str = '', working_dir: Path | str | None = None, default_name: str | None = None, extension_filter: str | None = None) -&gt; Path | None</code>","text":"<p>Open a prompt to request a file.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>pytvpaint.george.grg_base.FileMode</code> <p>save or load</p> required <code>title</code> <code>str</code> <p>the title of the request</p> <code>''</code> <code>working_dir</code> <code>pathlib.Path | str | None</code> <p>the default folder to go. Defaults to None.</p> <code>None</code> <code>default_name</code> <code>str | None</code> <p>the default name. Defaults to None.</p> <code>None</code> <code>extension_filter</code> <code>str | None</code> <p>display the files with this extension. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pathlib.Path | None</code> <p>the choosen path or None if cancelled</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_req_file(\n    mode: FileMode,\n    title: str = \"\",\n    working_dir: Path | str | None = None,\n    default_name: str | None = None,\n    extension_filter: str | None = None,\n) -&gt; Path | None:\n    \"\"\"Open a prompt to request a file.\n\n    Args:\n        mode: save or load\n        title: the title of the request\n        working_dir: the default folder to go. Defaults to None.\n        default_name: the default name. Defaults to None.\n        extension_filter: display the files with this extension. Defaults to None.\n\n    Returns:\n        the choosen path or None if cancelled\n    \"\"\"\n    cmd_args = [\n        title,\n        Path(working_dir).as_posix() if working_dir else None,\n        default_name,\n        extension_filter,\n    ]\n\n    arg_str = \"|\".join([v if v is not None else \"\" for v in cmd_args])\n    res = send_cmd(\"tv_ReqFile\", f\"{mode.value} {arg_str}\", handle_string=False)\n\n    return None if res.lower() == \"cancel\" else Path(res)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_undo","title":"<code>tv_undo() -&gt; None</code>","text":"<p>Do an undo.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_undo() -&gt; None:\n    \"\"\"Do an undo.\"\"\"\n    send_cmd(\"tv_Undo\")\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_update_undo","title":"<code>tv_update_undo() -&gt; None</code>","text":"<p>Copies the contents of the current image in the current layer into the buffer undo memory.</p> <p>None of the draw commands described in this section updates this buffer memory. If you click on the Undo button after executing a George program, everything that the program has drawn in your image will be deleted. With this function you can update the undo buffer memory whenever you wish (for example at the beginning of the program).</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_update_undo() -&gt; None:\n    \"\"\"Copies the contents of the current image in the current layer into the buffer undo memory.\n\n    None of the draw commands described in this section updates this buffer memory.\n    If you click on the Undo button after executing a George program, everything that the program has drawn in your image will be deleted.\n    With this function you can update the undo buffer memory whenever you wish (for example at the beginning of the program).\n    \"\"\"\n    send_cmd(\"tv_UpdateUndo\")\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_undo_open_stack","title":"<code>tv_undo_open_stack() -&gt; None</code>","text":"<p>Open an 'undo' stack.</p> <p>Surround a piece of code with tv_undoopenstack ... tv_undoclosestack, then multiple undo will be added to this stack, and closing this stack will undo everything inside. (To be sure the script returns to the expected result use tv_updateundo before tv_undoopenstack)</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_undo_open_stack() -&gt; None:\n    \"\"\"Open an 'undo' stack.\n\n    Surround a piece of code with tv_undoopenstack ... tv_undoclosestack, then multiple undo will be added to this stack, and closing this stack will undo everything inside.\n    (To be sure the script returns to the expected result use tv_updateundo before tv_undoopenstack)\n    \"\"\"\n    send_cmd(\"tv_UndoOpenStack\")\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_undo_close_stack","title":"<code>tv_undo_close_stack(name: str = '') -&gt; None</code>","text":"<p>Close an 'undo' stack (See tv_undo_open_stack).</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_undo_close_stack(name: str = \"\") -&gt; None:\n    \"\"\"Close an 'undo' stack (See tv_undo_open_stack).\"\"\"\n    send_cmd(\"tv_UndoCloseStack\", name)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_save_mode_get","title":"<code>tv_save_mode_get() -&gt; tuple[SaveFormat, list[str]]</code>","text":"<p>Get the saving alpha mode.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_save_mode_get() -&gt; tuple[SaveFormat, list[str]]:\n    \"\"\"Get the saving alpha mode.\"\"\"\n    res = send_cmd(\"tv_SaveMode\")\n    res_split = res.split()\n    save_format = tv_cast_to_type(res_split.pop(0), SaveFormat)\n    return save_format, res_split\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_save_mode_set","title":"<code>tv_save_mode_set(save_format: SaveFormat, *format_options: str | int | float) -&gt; None</code>","text":"<p>Set the saving alpha mode.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_save_mode_set(\n    save_format: SaveFormat, *format_options: str | int | float\n) -&gt; None:\n    \"\"\"Set the saving alpha mode.\"\"\"\n    send_cmd(\"tv_SaveMode\", save_format.value, *format_options)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_alpha_load_mode_get","title":"<code>tv_alpha_load_mode_get() -&gt; AlphaMode</code>","text":"<p>Set the loading alpha mode.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_alpha_load_mode_get() -&gt; AlphaMode:\n    \"\"\"Set the loading alpha mode.\"\"\"\n    res = send_cmd(\"tv_AlphaLoadMode\")\n    return tv_cast_to_type(res, AlphaMode)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_alpha_load_mode_set","title":"<code>tv_alpha_load_mode_set(mode: AlphaMode) -&gt; None</code>","text":"<p>Get the loading alpha mode.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_alpha_load_mode_set(mode: AlphaMode) -&gt; None:\n    \"\"\"Get the loading alpha mode.\"\"\"\n    send_cmd(\"tv_AlphaLoadMode\", mode.value)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_alpha_save_mode_get","title":"<code>tv_alpha_save_mode_get() -&gt; AlphaSaveMode</code>","text":"<p>Get the saving alpha mode.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_alpha_save_mode_get() -&gt; AlphaSaveMode:\n    \"\"\"Get the saving alpha mode.\"\"\"\n    res = send_cmd(\"tv_AlphaSaveMode\")\n    return tv_cast_to_type(res, AlphaSaveMode)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_alpha_save_mode_set","title":"<code>tv_alpha_save_mode_set(mode: AlphaSaveMode) -&gt; None</code>","text":"<p>Set the saving alpha mode.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_alpha_save_mode_set(mode: AlphaSaveMode) -&gt; None:\n    \"\"\"Set the saving alpha mode.\"\"\"\n    send_cmd(\"tv_AlphaSaveMode\", mode.value)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_mark_in_get","title":"<code>tv_mark_in_get(reference: MarkReference) -&gt; tuple[int, MarkAction]</code>","text":"<p>Get markin of the project / clip.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_mark_in_get(\n    reference: MarkReference,\n) -&gt; tuple[int, MarkAction]:\n    \"\"\"Get markin of the project / clip.\"\"\"\n    return _tv_mark(MarkType.MARKIN, reference)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_mark_in_set","title":"<code>tv_mark_in_set(reference: MarkReference, frame: int | None, action: MarkAction) -&gt; tuple[int, MarkAction]</code>","text":"<p>Set markin of the project / clip.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_mark_in_set(\n    reference: MarkReference,\n    frame: int | None,\n    action: MarkAction,\n) -&gt; tuple[int, MarkAction]:\n    \"\"\"Set markin of the project / clip.\"\"\"\n    return _tv_mark(MarkType.MARKIN, reference, frame, action)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_mark_out_get","title":"<code>tv_mark_out_get(reference: MarkReference) -&gt; tuple[int, MarkAction]</code>","text":"<p>Get markout of the project / clip.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_mark_out_get(\n    reference: MarkReference,\n) -&gt; tuple[int, MarkAction]:\n    \"\"\"Get markout of the project / clip.\"\"\"\n    return _tv_mark(MarkType.MARKOUT, reference)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_mark_out_set","title":"<code>tv_mark_out_set(reference: MarkReference, frame: int | None, action: MarkAction) -&gt; tuple[int, MarkAction]</code>","text":"<p>Set markout of the project / clip.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_mark_out_set(\n    reference: MarkReference, frame: int | None, action: MarkAction\n) -&gt; tuple[int, MarkAction]:\n    \"\"\"Set markout of the project / clip.\"\"\"\n    return _tv_mark(MarkType.MARKOUT, reference, frame, action)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_get_active_shape","title":"<code>tv_get_active_shape() -&gt; TVPShape</code>","text":"<p>Get the current shape.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_get_active_shape() -&gt; TVPShape:\n    \"\"\"Get the current shape.\"\"\"\n    return tv_cast_to_type(send_cmd(\"tv_GetActiveShape\"), TVPShape)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_set_active_shape","title":"<code>tv_set_active_shape(shape: TVPShape, **shape_kwargs: Any) -&gt; None</code>","text":"<p>Set the current shape and its tool parameters.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>pytvpaint.george.grg_base.TVPShape</code> <p>the shape to set</p> required <code>**shape_kwargs</code> <code>typing.Any</code> <p>the shape specific parameters as keyword arguments</p> <code>{}</code> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_set_active_shape(shape: TVPShape, **shape_kwargs: Any) -&gt; None:\n    \"\"\"Set the current shape and its tool parameters.\n\n    Args:\n        shape: the shape to set\n        **shape_kwargs: the shape specific parameters as keyword arguments\n    \"\"\"\n    send_cmd(\"tv_SetActiveShape\", shape.value, *args_dict_to_list(shape_kwargs))\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_set_a_pen_rgba","title":"<code>tv_set_a_pen_rgba(color: RGBColor, alpha: int | None = None) -&gt; RGBColor</code>","text":"<p>Set the APen RGBA color.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_set_a_pen_rgba(color: RGBColor, alpha: int | None = None) -&gt; RGBColor:\n    \"\"\"Set the APen RGBA color.\"\"\"\n    return _tv_set_ab_pen(\"a\", color.r, color.g, color.b, \"rgb\", a=alpha)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_set_a_pen_hsl","title":"<code>tv_set_a_pen_hsl(color: HSLColor) -&gt; HSLColor</code>","text":"<p>Set the A Pen HSL color.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_set_a_pen_hsl(color: HSLColor) -&gt; HSLColor:\n    \"\"\"Set the A Pen HSL color.\"\"\"\n    return _tv_set_ab_pen(\"a\", color.h, color.s, color.l, color_format=\"hsl\")\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_set_b_pen_rgba","title":"<code>tv_set_b_pen_rgba(color: RGBColor, alpha: int | None = None) -&gt; RGBColor</code>","text":"<p>Set the B Pen RGBA color.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_set_b_pen_rgba(color: RGBColor, alpha: int | None = None) -&gt; RGBColor:\n    \"\"\"Set the B Pen RGBA color.\"\"\"\n    return _tv_set_ab_pen(\"b\", color.r, color.g, color.b, color_format=\"rgb\", a=alpha)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_set_b_pen_hsl","title":"<code>tv_set_b_pen_hsl(color: HSLColor) -&gt; HSLColor</code>","text":"<p>Set the B Pen HSL color.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_set_b_pen_hsl(color: HSLColor) -&gt; HSLColor:\n    \"\"\"Set the B Pen HSL color.\"\"\"\n    return _tv_set_ab_pen(\"b\", color.h, color.s, color.l, color_format=\"hsl\")\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_pen","title":"<code>tv_pen(size: float) -&gt; float</code>","text":"<p>Change current pen tool size. This function is most likely deprecated it is undocumented in the George reference but still works.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_pen(size: float) -&gt; float:\n    \"\"\"Change current pen tool size. This function is most likely deprecated it is undocumented in the George reference but still works.\"\"\"\n    res = tv_parse_dict(send_cmd(\"tv_Pen\", size), with_fields=[(\"size\", float)])\n    return cast(float, res[\"size\"])\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_pen_brush_get","title":"<code>tv_pen_brush_get(tool_mode: bool = False) -&gt; TVPPenBrush</code>","text":"<p>Get pen brush parameters.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_pen_brush_get(tool_mode: bool = False) -&gt; TVPPenBrush:\n    \"\"\"Get pen brush parameters.\"\"\"\n    args = (\"toolmode\", \"backup\") if tool_mode else (\"backup\",)\n    result = send_cmd(\"tv_PenBrush\", *args)\n\n    # Remove the first value which is tv_penbrush\n    result = result[len(\"tv_penbrush\") + 1 :]\n\n    res = tv_parse_dict(result, with_fields=TVPPenBrush)\n    return TVPPenBrush(**res)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_pen_brush_set","title":"<code>tv_pen_brush_set(mode: DrawingMode | None = None, size: int | None = None, opacity: int | None = None, tool_mode: bool = False, reset: bool = False) -&gt; TVPPenBrush</code>","text":"<p>Manage pen brush.</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_pen_brush_set(\n    mode: DrawingMode | None = None,\n    size: int | None = None,\n    opacity: int | None = None,\n    tool_mode: bool = False,\n    reset: bool = False,\n) -&gt; TVPPenBrush:\n    \"\"\"Manage pen brush.\"\"\"\n    args = {\n        \"mode\": mode.value if mode else None,\n        \"size\": size,\n        \"opacity\": opacity,\n    }\n\n    args_list = args_dict_to_list(args)\n\n    if tool_mode:\n        args_list.append(\"toolmode\")\n    if reset:\n        args_list.append(\"reset\")\n\n    send_cmd(\"tv_PenBrush\", *args_list)\n\n    # Since TVPaint is returning only the values that were modified\n    # this is almost impossible to parse so we call get\n    return tv_pen_brush_get()\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_line","title":"<code>tv_line(xy1: tuple[int, int], xy2: tuple[int, int], right_click: bool = False, dry: bool = False) -&gt; None</code>","text":"<p>Draw a line (with the current brush).</p> <p>Parameters:</p> Name Type Description Default <code>xy1</code> <code>tuple[int, int]</code> <p>start position as (x, y)</p> required <code>xy2</code> <code>tuple[int, int]</code> <p>end position as (x, y)</p> required <code>right_click</code> <code>bool</code> <p>True to emulate right click, False to emulate left click. Default is False</p> <code>False</code> <code>dry</code> <code>bool</code> <p>True for dry mode</p> <code>False</code> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_line(\n    xy1: tuple[int, int],\n    xy2: tuple[int, int],\n    right_click: bool = False,\n    dry: bool = False,\n) -&gt; None:\n    \"\"\"Draw a line (with the current brush).\n\n    Args:\n        xy1: start position as (x, y)\n        xy2: end position as (x, y)\n        right_click: True to emulate right click, False to emulate left click. Default is False\n        dry: True for dry mode\n    \"\"\"\n    args = [\n        *xy1,\n        *xy2,\n        bool(right_click),\n        bool(dry),\n    ]\n    send_cmd(\"tv_Line\", *args)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_text","title":"<code>tv_text(text: str, x: int, y: int, use_b_pen: bool = False) -&gt; None</code>","text":"<p>Write text in a layer instance.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to write</p> required <code>x</code> <code>int</code> <p>text x position</p> required <code>y</code> <code>int</code> <p>text y position</p> required <code>use_b_pen</code> <code>bool</code> <p>True will use b pen, False will use A pen</p> <code>False</code> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_text(text: str, x: int, y: int, use_b_pen: bool = False) -&gt; None:\n    \"\"\"Write text in a layer instance.\n\n    Args:\n        text: text to write\n        x: text x position\n        y: text y position\n        use_b_pen: True will use b pen, False will use A pen\n    \"\"\"\n    send_cmd(\"tv_Text\", x, y, int(use_b_pen), text)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_text_brush","title":"<code>tv_text_brush(text: str) -&gt; None</code>","text":"<p>Set the text for the text brush.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to write</p> required Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_text_brush(text: str) -&gt; None:\n    \"\"\"Set the text for the text brush.\n\n    Args:\n        text: text to write\n    \"\"\"\n    send_cmd(\"tv_TextBrush\", text)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_rect","title":"<code>tv_rect(tlx: float, tly: float, brx: float, bry: float, button: RectButton | None = None) -&gt; None</code>","text":"<p>Draws an unfilled rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>tlx</code> <code>float</code> <p>top left x coordinate</p> required <code>tly</code> <code>float</code> <p>top left y coordinate</p> required <code>brx</code> <code>float</code> <p>bottom right x coordinate</p> required <code>bry</code> <code>float</code> <p>bottom right y coordinate</p> required <code>button</code> <code>pytvpaint.george.grg_base.RectButton | None</code> <p>use left or right click button (left draws, right erases)</p> <code>None</code> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_rect(\n    tlx: float,\n    tly: float,\n    brx: float,\n    bry: float,\n    button: RectButton | None = None,\n) -&gt; None:\n    \"\"\"Draws an unfilled rectangle.\n\n    Args:\n        tlx: top left x coordinate\n        tly: top left y coordinate\n        brx: bottom right x coordinate\n        bry: bottom right y coordinate\n        button: use left or right click button (left draws, right erases)\n    \"\"\"\n    args: list[float] = [tlx, tly, brx, bry]\n    if button:\n        args.append(button.value)\n    send_cmd(\"tv_Rect\", *args)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_rect_fill","title":"<code>tv_rect_fill(tlx: float, tly: float, brx: float, bry: float, grx: float = 0, gry: float = 0, erase_mode: bool = False, tool_mode: bool = False) -&gt; None</code>","text":"<p>Draws a filled rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>tlx</code> <code>float</code> <p>top left x coordinate</p> required <code>tly</code> <code>float</code> <p>top left y coordinate</p> required <code>brx</code> <code>float</code> <p>bottom right x coordinate</p> required <code>bry</code> <code>float</code> <p>bottom right y coordinate</p> required <code>grx</code> <code>float</code> <p>gradient vector x</p> <code>0</code> <code>gry</code> <code>float</code> <p>gradient vector y</p> <code>0</code> <code>erase_mode</code> <code>bool</code> <p>erase drawing mode</p> <code>False</code> <code>tool_mode</code> <code>bool</code> <p>manage drawing mode</p> <code>False</code> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_rect_fill(\n    tlx: float,\n    tly: float,\n    brx: float,\n    bry: float,\n    grx: float = 0,\n    gry: float = 0,\n    erase_mode: bool = False,\n    tool_mode: bool = False,\n) -&gt; None:\n    \"\"\"Draws a filled rectangle.\n\n    Args:\n        tlx: top left x coordinate\n        tly: top left y coordinate\n        brx: bottom right x coordinate\n        bry: bottom right y coordinate\n        grx: gradient vector x\n        gry: gradient vector y\n        erase_mode: erase drawing mode\n        tool_mode: manage drawing mode\n    \"\"\"\n    args: list[Any] = [tlx, tly, brx, bry, grx, gry, int(erase_mode)]\n    if tool_mode:\n        args.insert(0, \"toolmode\")\n    send_cmd(\"tv_RectFill\", *args)\n</code></pre>"},{"location":"api/george/misc/#pytvpaint.george.grg_base.tv_fast_line","title":"<code>tv_fast_line(x1: float, y1: float, x2: float, y2: float, r: int = 255, b: int = 255, g: int = 0, a: int = 255) -&gt; None</code>","text":"<p>Draw a line (1 pixel size and not antialiased).</p> Source code in <code>pytvpaint/george/grg_base.py</code> <pre><code>def tv_fast_line(\n    x1: float,\n    y1: float,\n    x2: float,\n    y2: float,\n    r: int = 255,\n    b: int = 255,\n    g: int = 0,\n    a: int = 255,\n) -&gt; None:\n    \"\"\"Draw a line (1 pixel size and not antialiased).\"\"\"\n    send_cmd(\"tv_fastline\", x1, y1, x2, y2, r, g, b, a)\n</code></pre>"},{"location":"api/george/project/","title":"Project related George functions","text":"<p>Project related George functions and enums.</p>"},{"location":"api/george/project/#pytvpaint.george.grg_project.TVPProject","title":"<code>TVPProject(id: str, path: Path, width: int, height: int, pixel_aspect_ratio: float, frame_rate: float, field_order: FieldOrder, start_frame: int)</code>  <code>dataclass</code>","text":"<p>TVPaint project info values.</p>"},{"location":"api/george/project/#pytvpaint.george.grg_project.BackgroundMode","title":"<code>BackgroundMode</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>The project background mode.</p> <p>Attributes:</p> Name Type Description <code>CHECK</code> <code>COLOR</code> <code>NONE</code>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_background_get","title":"<code>tv_background_get() -&gt; tuple[BackgroundMode, tuple[RGBColor, RGBColor] | RGBColor | None]</code>","text":"<p>Get the background mode of the project, and the color(s) if in <code>color</code> or <code>check</code> mode.</p> <p>Returns:</p> Name Type Description <code>mode</code> <code>pytvpaint.george.grg_project.BackgroundMode</code> <p>the background mode</p> <code>colors</code> <code>tuple[pytvpaint.george.grg_base.RGBColor, pytvpaint.george.grg_base.RGBColor] | pytvpaint.george.grg_base.RGBColor | None</code> <p>the background colors if any</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_background_get() -&gt; (\n    tuple[BackgroundMode, tuple[RGBColor, RGBColor] | RGBColor | None]\n):\n    \"\"\"Get the background mode of the project, and the color(s) if in `color` or `check` mode.\n\n    Returns:\n        mode: the background mode\n        colors: the background colors if any\n\n    \"\"\"\n    res = send_cmd(\"tv_Background\")\n\n    mode, *values = res.split(\" \")\n\n    if mode == BackgroundMode.NONE.value:\n        return BackgroundMode.NONE, None\n\n    if mode == BackgroundMode.CHECK.value:\n        c1 = map(int, values[:3])\n        c2 = map(int, values[3:])\n        return BackgroundMode.CHECK, (RGBColor(*c1), RGBColor(*c2))\n\n    return BackgroundMode.COLOR, RGBColor(*map(int, values))\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_background_set","title":"<code>tv_background_set(mode: BackgroundMode, color: tuple[RGBColor, RGBColor] | RGBColor | None = None) -&gt; None</code>","text":"<p>Set the background mode of the project.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>pytvpaint.george.grg_project.BackgroundMode</code> <p>color mode (None, checker or one color)</p> required <code>color</code> <code>tuple[pytvpaint.george.grg_base.RGBColor, pytvpaint.george.grg_base.RGBColor] | pytvpaint.george.grg_base.RGBColor | None</code> <p>None for None mode, RBGColor for one color, and tuple of RGBColors for checker</p> <code>None</code> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_background_set(\n    mode: BackgroundMode,\n    color: tuple[RGBColor, RGBColor] | RGBColor | None = None,\n) -&gt; None:\n    \"\"\"Set the background mode of the project.\n\n    Args:\n        mode: color mode (None, checker or one color)\n        color: None for None mode, RBGColor for one color, and tuple of RGBColors for checker\n    \"\"\"\n    args = []\n\n    if mode == BackgroundMode.CHECK and isinstance(color, tuple):\n        c1, c2 = color\n        args = [c1.r, c1.g, c1.b, c2.r, c2.g, c2.b]\n    elif mode == BackgroundMode.COLOR and isinstance(color, RGBColor):\n        args = [color.r, color.g, color.b]\n\n    send_cmd(\"tv_Background\", mode.value, *args)\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_new","title":"<code>tv_project_new(project_path: Path | str, width: int = 1920, height: int = 1080, pixel_aspect_ratio: float = 1.0, frame_rate: float = 24.0, field_order: FieldOrder = FieldOrder.NONE, start_frame: int = 1) -&gt; str</code>","text":"<p>Create a new project.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if an error occurred during the project creation</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>@try_cmd(exception_msg=\"Project created but may be corrupted\")\ndef tv_project_new(\n    project_path: Path | str,\n    width: int = 1920,\n    height: int = 1080,\n    pixel_aspect_ratio: float = 1.0,\n    frame_rate: float = 24.0,\n    field_order: FieldOrder = FieldOrder.NONE,\n    start_frame: int = 1,\n) -&gt; str:\n    \"\"\"Create a new project.\n\n    Raises:\n        GeorgeError: if an error occurred during the project creation\n    \"\"\"\n    return send_cmd(\n        \"tv_ProjectNew\",\n        Path(project_path).as_posix(),\n        width,\n        height,\n        pixel_aspect_ratio,\n        frame_rate,\n        field_order.value,\n        start_frame,\n        error_values=[GrgErrorValue.EMPTY],\n    )\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_load_project","title":"<code>tv_load_project(project_path: Path | str, silent: bool = False) -&gt; str</code>","text":"<p>Load a file as a project if possible or open Import panel.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the project file doesn't exist</p> <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if the provided file is in an invalid format</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>@try_cmd(exception_msg=\"Invalid format\")\ndef tv_load_project(project_path: Path | str, silent: bool = False) -&gt; str:\n    \"\"\"Load a file as a project if possible or open Import panel.\n\n    Raises:\n        FileNotFoundError: if the project file doesn't exist\n        GeorgeError: if the provided file is in an invalid format\n    \"\"\"\n    project_path = Path(project_path)\n\n    if not project_path.exists():\n        raise FileNotFoundError(f\"Project not found at: {project_path.as_posix()}\")\n\n    args: list[Any] = [project_path.as_posix()]\n\n    if silent:\n        args.extend([\"silent\", int(silent)])\n\n    return send_cmd(\"tv_LoadProject\", *args, error_values=[-1])\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_save_project","title":"<code>tv_save_project(project_path: Path | str) -&gt; None</code>","text":"<p>Save the current project as tvpp.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_save_project(project_path: Path | str) -&gt; None:\n    \"\"\"Save the current project as tvpp.\"\"\"\n    project_path = Path(project_path)\n    parent = project_path.parent\n\n    if not parent.exists():\n        msg = f\"Can't save because parent folder does not exist: {parent.as_posix()}\"\n        raise ValueError(msg)\n\n    send_cmd(\"tv_SaveProject\", project_path.as_posix())\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_duplicate","title":"<code>tv_project_duplicate() -&gt; None</code>","text":"<p>Duplicate the current project.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if an error occurred during the project creation.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>@try_cmd(exception_msg=\"Can't duplicate the current project\")\ndef tv_project_duplicate() -&gt; None:\n    \"\"\"Duplicate the current project.\n\n    Raises:\n        GeorgeError: if an error occurred during the project creation.\n    \"\"\"\n    send_cmd(\"tv_ProjectDuplicate\", error_values=[0])\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_enum_id","title":"<code>tv_project_enum_id(position: int) -&gt; str</code>","text":"<p>Get the id of the project at the given position.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if no project found at the provided position.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>@try_cmd(exception_msg=\"No project at provided position\")\ndef tv_project_enum_id(position: int) -&gt; str:\n    \"\"\"Get the id of the project at the given position.\n\n    Raises:\n        GeorgeError: if no project found at the provided position.\n    \"\"\"\n    return send_cmd(\"tv_ProjectEnumId\", position, error_values=[GrgErrorValue.NONE])\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_current_id","title":"<code>tv_project_current_id() -&gt; str</code>","text":"<p>Get the id of the current project.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_project_current_id() -&gt; str:\n    \"\"\"Get the id of the current project.\"\"\"\n    return send_cmd(\"tv_ProjectCurrentId\")\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_info","title":"<code>tv_project_info(project_id: str) -&gt; TVPProject</code>","text":"<p>Get info of the given project.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid project id</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid project id\",\n)\ndef tv_project_info(project_id: str) -&gt; TVPProject:\n    \"\"\"Get info of the given project.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid project id\n    \"\"\"\n    result = send_cmd(\"tv_ProjectInfo\", project_id, error_values=[GrgErrorValue.EMPTY])\n    project = tv_parse_list(result, with_fields=TVPProject)\n    project[\"id\"] = project_id\n    return TVPProject(**project)\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_get_project_name","title":"<code>tv_get_project_name() -&gt; str</code>","text":"<p>Returns the save path of the current project.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_get_project_name() -&gt; str:\n    \"\"\"Returns the save path of the current project.\"\"\"\n    return send_cmd(\"tv_GetProjectName\")\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_select","title":"<code>tv_project_select(project_id: str) -&gt; str</code>","text":"<p>Make the given project current.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_project_select(project_id: str) -&gt; str:\n    \"\"\"Make the given project current.\"\"\"\n    return send_cmd(\"tv_ProjectSelect\", project_id)\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_close","title":"<code>tv_project_close(project_id: str) -&gt; None</code>","text":"<p>Close the given project.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_project_close(project_id: str) -&gt; None:\n    \"\"\"Close the given project.\"\"\"\n    send_cmd(\"tv_ProjectClose\", project_id)\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_resize_project","title":"<code>tv_resize_project(width: int, height: int) -&gt; None</code>","text":"<p>Resize the current project.</p> Note <p>creates a resized copy of the project with a new id</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_resize_project(width: int, height: int) -&gt; None:\n    \"\"\"Resize the current project.\n\n    Note:\n        creates a resized copy of the project with a new id\n    \"\"\"\n    send_cmd(\"tv_ResizeProject\", width, height)\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_resize_page","title":"<code>tv_resize_page(width: int, height: int, resize_opt: ResizeOption) -&gt; None</code>","text":"<p>Create a new resized project and close the current one.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_resize_page(width: int, height: int, resize_opt: ResizeOption) -&gt; None:\n    \"\"\"Create a new resized project and close the current one.\"\"\"\n    send_cmd(\"tv_ResizePage\", width, height, resize_opt.value)\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_get_width","title":"<code>tv_get_width() -&gt; int</code>","text":"<p>Get the current project width.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_get_width() -&gt; int:\n    \"\"\"Get the current project width.\"\"\"\n    return int(send_cmd(\"tv_GetWidth\"))\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_get_height","title":"<code>tv_get_height() -&gt; int</code>","text":"<p>Get the current project height.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_get_height() -&gt; int:\n    \"\"\"Get the current project height.\"\"\"\n    return int(send_cmd(\"tv_GetHeight\"))\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_ratio","title":"<code>tv_ratio() -&gt; float</code>","text":"<p>Get the current project pixel aspect ratio.</p> Bug <p>Doesn't work and always returns an empty string</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_ratio() -&gt; float:\n    \"\"\"Get the current project pixel aspect ratio.\n\n    Bug:\n        Doesn't work and always returns an empty string\n    \"\"\"\n    return float(send_cmd(\"tv_GetRatio\", error_values=[GrgErrorValue.EMPTY]))\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_get_field","title":"<code>tv_get_field() -&gt; FieldOrder</code>","text":"<p>Get the current project field mode.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_get_field() -&gt; FieldOrder:\n    \"\"\"Get the current project field mode.\"\"\"\n    return tv_cast_to_type(send_cmd(\"tv_GetField\"), cast_type=FieldOrder)\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_save_sequence","title":"<code>tv_project_save_sequence(export_path: Path | str, use_camera: bool = False, start: int | None = None, end: int | None = None) -&gt; None</code>","text":"<p>Save the current project.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_project_save_sequence(\n    export_path: Path | str,\n    use_camera: bool = False,\n    start: int | None = None,\n    end: int | None = None,\n) -&gt; None:\n    \"\"\"Save the current project.\"\"\"\n    export_path = Path(export_path).resolve()\n    args: list[Any] = [export_path.as_posix()]\n\n    if use_camera:\n        args.append(\"camera\")\n    if start is not None and end is not None:\n        args.extend((start, end))\n\n    send_cmd(\n        \"tv_ProjectSaveSequence\",\n        *args,\n        error_values=[-1],\n    )\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_render_camera","title":"<code>tv_project_render_camera(project_id: str) -&gt; str</code>","text":"<p>Render the given project's camera view to a new project.</p> <p>Returns:</p> Type Description <code>str</code> <p>the new project id</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_project_render_camera(project_id: str) -&gt; str:\n    \"\"\"Render the given project's camera view to a new project.\n\n    Returns:\n        the new project id\n    \"\"\"\n    return send_cmd(\n        \"tv_ProjectRenderCamera\",\n        project_id,\n        error_values=[GrgErrorValue.ERROR],\n    )\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_frame_rate_get","title":"<code>tv_frame_rate_get() -&gt; tuple[float, float]</code>","text":"<p>Get the framerate of the current project.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_frame_rate_get() -&gt; tuple[float, float]:\n    \"\"\"Get the framerate of the current project.\"\"\"\n    parse = tv_parse_list(\n        send_cmd(\"tv_FrameRate\", 1, \"info\"),\n        with_fields=[\n            (\"project_fps\", float),\n            (\"playback_fps\", float),\n        ],\n    )\n    project_fps, playback_fps = parse.values()\n    return project_fps, playback_fps\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_frame_rate_set","title":"<code>tv_frame_rate_set(frame_rate: float, time_stretch: bool = False, preview: bool = False) -&gt; None</code>","text":"<p>Get the framerate of the current project.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_frame_rate_set(\n    frame_rate: float, time_stretch: bool = False, preview: bool = False\n) -&gt; None:\n    \"\"\"Get the framerate of the current project.\"\"\"\n    args: list[Any] = []\n    if time_stretch:\n        args = [\"timestretch\"]\n    if preview:\n        args = [\"preview\"]\n    args.insert(0, frame_rate)\n    send_cmd(\"tv_FrameRate\", *args)\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_frame_rate_project_set","title":"<code>tv_frame_rate_project_set(frame_rate: float, time_stretch: bool = False) -&gt; None</code>","text":"<p>Set the framerate of the current project.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_frame_rate_project_set(frame_rate: float, time_stretch: bool = False) -&gt; None:\n    \"\"\"Set the framerate of the current project.\"\"\"\n    args: list[Any] = [frame_rate]\n    if time_stretch:\n        args.append(\"timestretch\")\n    send_cmd(\"tv_FrameRate\", *args)\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_frame_rate_preview_set","title":"<code>tv_frame_rate_preview_set(frame_rate: float) -&gt; None</code>","text":"<p>Set the framerate of the preview (playback).</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_frame_rate_preview_set(frame_rate: float) -&gt; None:\n    \"\"\"Set the framerate of the preview (playback).\"\"\"\n    send_cmd(\"tv_FrameRate\", frame_rate, \"preview\")\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_current_frame_get","title":"<code>tv_project_current_frame_get() -&gt; int</code>","text":"<p>Get the current frame of the current project.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_project_current_frame_get() -&gt; int:\n    \"\"\"Get the current frame of the current project.\"\"\"\n    return int(send_cmd(\"tv_ProjectCurrentFrame\"))\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_current_frame_set","title":"<code>tv_project_current_frame_set(frame: int) -&gt; int</code>","text":"<p>Set the current frame of the current project.</p> Note <p>this is relative to the current clip markin</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_project_current_frame_set(frame: int) -&gt; int:\n    \"\"\"Set the current frame of the current project.\n\n    Note:\n        this is relative to the current clip markin\n    \"\"\"\n    return int(send_cmd(\"tv_ProjectCurrentFrame\", frame))\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_load_palette","title":"<code>tv_load_palette(palette_path: Path | str) -&gt; None</code>","text":"<p>Load a palette(s) from a file/directory.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if palette was not found at the provided path</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_load_palette(palette_path: Path | str) -&gt; None:\n    \"\"\"Load a palette(s) from a file/directory.\n\n    Raises:\n        FileNotFoundError: if palette was not found at the provided path\n    \"\"\"\n    palette_path = Path(palette_path)\n    if not palette_path.exists():\n        raise FileNotFoundError(f\"Palette not found at: {palette_path.as_posix()}\")\n    send_cmd(\"tv_LoadPalette\", palette_path.as_posix())\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_save_palette","title":"<code>tv_save_palette(palette_path: Path | str) -&gt; None</code>","text":"<p>Save the current palette.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if palette save directory doesn't exist</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_save_palette(palette_path: Path | str) -&gt; None:\n    \"\"\"Save the current palette.\n\n    Raises:\n        FileNotFoundError: if palette save directory doesn't exist\n    \"\"\"\n    palette_path = Path(palette_path)\n\n    if not palette_path.parent.exists():\n        parent_path = palette_path.parent.as_posix()\n        raise NotADirectoryError(\n            f\"Can't save palette because parent folder doesn't exist: {parent_path}\"\n        )\n\n    send_cmd(\"tv_SavePalette\", palette_path.as_posix())\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_save_video_dependencies","title":"<code>tv_project_save_video_dependencies(project_id: str, on_save: bool = True, now: bool = False) -&gt; int</code>","text":"<p>Saves current project video dependencies.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_project_save_video_dependencies(\n    project_id: str, on_save: bool = True, now: bool = False\n) -&gt; int:\n    \"\"\"Saves current project video dependencies.\"\"\"\n    args: list[Any] = [project_id]\n    if not now:\n        args.append(int(on_save))\n    return int(\n        send_cmd(\"tv_ProjectSaveVideoDependencies\", *args, error_values=[-1, -2])\n    )\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_save_audio_dependencies","title":"<code>tv_project_save_audio_dependencies(project_id: str, on_save: bool = True) -&gt; int</code>","text":"<p>Saves current project audio dependencies.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_project_save_audio_dependencies(project_id: str, on_save: bool = True) -&gt; int:\n    \"\"\"Saves current project audio dependencies.\"\"\"\n    return int(\n        send_cmd(\n            \"tv_ProjectSaveAudioDependencies\",\n            project_id,\n            int(on_save),\n            error_values=[-1, -2],\n        )\n    )\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_sound_project_info","title":"<code>tv_sound_project_info(project_id: str, track_index: int) -&gt; TVPSound</code>","text":"<p>Get information about a project soundtrack.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_sound_project_info(project_id: str, track_index: int) -&gt; TVPSound:\n    \"\"\"Get information about a project soundtrack.\"\"\"\n    res = send_cmd(\n        \"tv_SoundProjectInfo\", project_id, track_index, error_values=[-1, -2, -3]\n    )\n    res_parse = tv_parse_list(res, with_fields=TVPSound)\n    return TVPSound(**res_parse)\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_sound_project_new","title":"<code>tv_sound_project_new(sound_path: Path | str) -&gt; None</code>","text":"<p>Add a new soundtrack to the current project.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_sound_project_new(sound_path: Path | str) -&gt; None:\n    \"\"\"Add a new soundtrack to the current project.\"\"\"\n    path = Path(sound_path)\n    if not path.exists():\n        raise ValueError(f\"Sound file not found at : {path.as_posix()}\")\n\n    send_cmd(\"tv_SoundProjectNew\", path.as_posix(), error_values=[-1, -3, -4])\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_sound_project_remove","title":"<code>tv_sound_project_remove(track_index: int) -&gt; None</code>","text":"<p>Remove a soundtrack from the current project.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_sound_project_remove(track_index: int) -&gt; None:\n    \"\"\"Remove a soundtrack from the current project.\"\"\"\n    send_cmd(\"tv_SoundProjectRemove\", track_index, error_values=[-2])\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_sound_project_reload","title":"<code>tv_sound_project_reload(project_id: str, track_index: int) -&gt; None</code>","text":"<p>Reload a project soundtracks file.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_sound_project_reload(project_id: str, track_index: int) -&gt; None:\n    \"\"\"Reload a project soundtracks file.\"\"\"\n    send_cmd(\n        \"tv_SoundProjectReload\",\n        project_id,\n        track_index,\n        error_values=[-1, -2, -3],\n    )\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_sound_project_adjust","title":"<code>tv_sound_project_adjust(track_index: int, mute: bool | None = None, volume: float | None = None, offset: float | None = None, fade_in_start: float | None = None, fade_in_stop: float | None = None, fade_out_start: float | None = None, fade_out_stop: float | None = None, color_index: int | None = None) -&gt; None</code>","text":"<p>Change the current project's soundtrack settings.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_sound_project_adjust(\n    track_index: int,\n    mute: bool | None = None,\n    volume: float | None = None,\n    offset: float | None = None,\n    fade_in_start: float | None = None,\n    fade_in_stop: float | None = None,\n    fade_out_start: float | None = None,\n    fade_out_stop: float | None = None,\n    color_index: int | None = None,\n) -&gt; None:\n    \"\"\"Change the current project's soundtrack settings.\"\"\"\n    cur_options = tv_sound_project_info(tv_project_current_id(), track_index)\n    args: list[int | float | None] = []\n\n    optional_args = [\n        (int(mute) if mute is not None else None, int(cur_options.mute)),\n        (volume, cur_options.volume),\n        (offset, cur_options.offset),\n        (fade_in_start, cur_options.fade_in_start),\n        (fade_in_stop, cur_options.fade_in_stop),\n        (fade_out_start, cur_options.fade_out_start),\n        (fade_out_stop, cur_options.fade_out_stop),\n    ]\n    for arg, default_value in optional_args:\n        args.append(arg if arg is not None else default_value)\n\n    args.append(color_index)\n    send_cmd(\"tv_SoundProjectAdjust\", track_index, *args, error_values=[-2, -3])\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_header_info_get","title":"<code>tv_project_header_info_get(project_id: str) -&gt; str</code>","text":"<p>Get the project header info.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid project id</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid project id\",\n)\ndef tv_project_header_info_get(project_id: str) -&gt; str:\n    \"\"\"Get the project header info.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid project id\n    \"\"\"\n    return send_cmd(\n        \"tv_ProjectHeaderInfo\",\n        project_id,\n        error_values=[GrgErrorValue.ERROR],\n    ).strip('\"')\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_header_info_set","title":"<code>tv_project_header_info_set(project_id: str, text: str) -&gt; None</code>","text":"<p>Set the project header info.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid project id</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid project id\",\n)\ndef tv_project_header_info_set(project_id: str, text: str) -&gt; None:\n    \"\"\"Set the project header info.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid project id\n    \"\"\"\n    send_cmd(\n        \"tv_ProjectHeaderInfo\",\n        project_id,\n        text,\n        error_values=[GrgErrorValue.ERROR],\n    )\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_header_author_get","title":"<code>tv_project_header_author_get(project_id: str) -&gt; str</code>","text":"<p>Get the project author info.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid project id</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid project id\",\n)\ndef tv_project_header_author_get(project_id: str) -&gt; str:\n    \"\"\"Get the project author info.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid project id\n    \"\"\"\n    return send_cmd(\n        \"tv_ProjectHeaderAuthor\",\n        project_id,\n        error_values=[GrgErrorValue.ERROR],\n    ).strip('\"')\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_header_author_set","title":"<code>tv_project_header_author_set(project_id: str, text: str) -&gt; None</code>","text":"<p>Set the project author info.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid project id</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid project id\",\n)\ndef tv_project_header_author_set(project_id: str, text: str) -&gt; None:\n    \"\"\"Set the project author info.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid project id\n    \"\"\"\n    send_cmd(\n        \"tv_ProjectHeaderAuthor\",\n        project_id,\n        text,\n        error_values=[GrgErrorValue.ERROR],\n    )\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_header_notes_get","title":"<code>tv_project_header_notes_get(project_id: str) -&gt; str</code>","text":"<p>Get the project notes.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid project id</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid project id\",\n)\ndef tv_project_header_notes_get(project_id: str) -&gt; str:\n    \"\"\"Get the project notes.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid project id\n    \"\"\"\n    return send_cmd(\n        \"tv_ProjectHeaderNotes\",\n        project_id,\n        error_values=[GrgErrorValue.ERROR],\n    ).strip('\"')\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_project_header_notes_set","title":"<code>tv_project_header_notes_set(project_id: str, text: str) -&gt; None</code>","text":"<p>Set the project notes.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.NoObjectWithIdError</code> <p>if given an invalid project id</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>@try_cmd(\n    raise_exc=NoObjectWithIdError,\n    exception_msg=\"Invalid project id\",\n)\ndef tv_project_header_notes_set(project_id: str, text: str) -&gt; None:\n    \"\"\"Set the project notes.\n\n    Raises:\n        NoObjectWithIdError: if given an invalid project id\n    \"\"\"\n    send_cmd(\n        \"tv_ProjectHeaderNotes\",\n        project_id,\n        text,\n        error_values=[GrgErrorValue.ERROR],\n    )\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_start_frame_get","title":"<code>tv_start_frame_get() -&gt; int</code>","text":"<p>Get the start frame of the current project.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_start_frame_get() -&gt; int:\n    \"\"\"Get the start frame of the current project.\"\"\"\n    return int(send_cmd(\"tv_StartFrame\"))\n</code></pre>"},{"location":"api/george/project/#pytvpaint.george.grg_project.tv_start_frame_set","title":"<code>tv_start_frame_set(start_frame: int) -&gt; int</code>","text":"<p>Set the start frame of the current project.</p> Source code in <code>pytvpaint/george/grg_project.py</code> <pre><code>def tv_start_frame_set(start_frame: int) -&gt; int:\n    \"\"\"Set the start frame of the current project.\"\"\"\n    return int(send_cmd(\"tv_StartFrame\", start_frame))\n</code></pre>"},{"location":"api/george/scene/","title":"Scene related George functions","text":"<p>Scene related George functions.</p>"},{"location":"api/george/scene/#pytvpaint.george.grg_scene.tv_scene_enum_id","title":"<code>tv_scene_enum_id(position: int) -&gt; int</code>","text":"<p>Get the id of the scene at the given position in the current project.</p> <p>Raises:</p> Type Description <code>pytvpaint.george.exceptions.GeorgeError</code> <p>if no scene found at the provided position</p> Source code in <code>pytvpaint/george/grg_scene.py</code> <pre><code>@try_cmd(exception_msg=\"No scene at provided position\")\ndef tv_scene_enum_id(position: int) -&gt; int:\n    \"\"\"Get the id of the scene at the given position in the current project.\n\n    Raises:\n        GeorgeError: if no scene found at the provided position\n    \"\"\"\n    return int(send_cmd(\"tv_SceneEnumId\", position, error_values=[GrgErrorValue.NONE]))\n</code></pre>"},{"location":"api/george/scene/#pytvpaint.george.grg_scene.tv_scene_current_id","title":"<code>tv_scene_current_id() -&gt; int</code>","text":"<p>Get the id of the current scene.</p> Source code in <code>pytvpaint/george/grg_scene.py</code> <pre><code>def tv_scene_current_id() -&gt; int:\n    \"\"\"Get the id of the current scene.\"\"\"\n    return int(send_cmd(\"tv_SceneCurrentId\"))\n</code></pre>"},{"location":"api/george/scene/#pytvpaint.george.grg_scene.tv_scene_move","title":"<code>tv_scene_move(scene_id: int, position: int) -&gt; None</code>","text":"<p>Move a scene to another position.</p> Source code in <code>pytvpaint/george/grg_scene.py</code> <pre><code>def tv_scene_move(scene_id: int, position: int) -&gt; None:\n    \"\"\"Move a scene to another position.\"\"\"\n    send_cmd(\"tv_SceneMove\", scene_id, position)\n</code></pre>"},{"location":"api/george/scene/#pytvpaint.george.grg_scene.tv_scene_new","title":"<code>tv_scene_new() -&gt; None</code>","text":"<p>Create a new scene (with a new clip) after the current scene.</p> Source code in <code>pytvpaint/george/grg_scene.py</code> <pre><code>def tv_scene_new() -&gt; None:\n    \"\"\"Create a new scene (with a new clip) after the current scene.\"\"\"\n    send_cmd(\"tv_SceneNew\")\n</code></pre>"},{"location":"api/george/scene/#pytvpaint.george.grg_scene.tv_scene_duplicate","title":"<code>tv_scene_duplicate(scene_id: int) -&gt; None</code>","text":"<p>Duplicate the given scene.</p> Source code in <code>pytvpaint/george/grg_scene.py</code> <pre><code>def tv_scene_duplicate(scene_id: int) -&gt; None:\n    \"\"\"Duplicate the given scene.\"\"\"\n    send_cmd(\"tv_SceneDuplicate\", scene_id)\n</code></pre>"},{"location":"api/george/scene/#pytvpaint.george.grg_scene.tv_scene_close","title":"<code>tv_scene_close(scene_id: int) -&gt; None</code>","text":"<p>Remove the given scene.</p> Source code in <code>pytvpaint/george/grg_scene.py</code> <pre><code>def tv_scene_close(scene_id: int) -&gt; None:\n    \"\"\"Remove the given scene.\"\"\"\n    send_cmd(\"tv_SceneClose\", scene_id)\n</code></pre>"},{"location":"api/objects/camera/","title":"Camera class","text":"<p>Camera related objects and classes.</p>"},{"location":"api/objects/camera/#pytvpaint.camera.Camera","title":"<code>Camera(clip: Clip, data: george.TVPCamera | None = None)</code>","text":"<p>             Bases: <code>pytvpaint.utils.Refreshable</code></p> <p>The Camera class represents the camera in a TVPaint clip.</p> <p>There's only one camera in the clip so instantiating multiple objects of this class won't create cameras.</p> Source code in <code>pytvpaint/camera.py</code> <pre><code>def __init__(self, clip: Clip, data: george.TVPCamera | None = None) -&gt; None:\n    super().__init__()\n    self._clip = clip\n    self._data: george.TVPCamera = data or george.tv_camera_info_get()\n    self._points: list[CameraPoint] = []\n</code></pre>"},{"location":"api/objects/camera/#pytvpaint.camera.Camera.clip","title":"<code>clip: Clip</code>  <code>property</code>","text":"<p>The camera's clip.</p>"},{"location":"api/objects/camera/#pytvpaint.camera.Camera.points","title":"<code>points: Iterator[CameraPoint]</code>  <code>property</code>","text":"<p>Iterator for the <code>CameraPoint</code> objects of the camera.</p>"},{"location":"api/objects/camera/#pytvpaint.camera.Camera.refresh","title":"<code>refresh() -&gt; None</code>","text":"<p>Refreshed the camera data.</p> Source code in <code>pytvpaint/camera.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshed the camera data.\"\"\"\n    if not self.refresh_on_call and self._data:\n        return\n    self._data = george.tv_camera_info_get()\n</code></pre>"},{"location":"api/objects/camera/#pytvpaint.camera.Camera.make_current","title":"<code>make_current() -&gt; None</code>","text":"<p>Makes the parent clip the current one, thereby making sure the correct camera will be set.</p> Source code in <code>pytvpaint/camera.py</code> <pre><code>def make_current(self) -&gt; None:\n    \"\"\"Makes the parent clip the current one, thereby making sure the correct camera will be set.\"\"\"\n    self._clip.make_current()\n</code></pre>"},{"location":"api/objects/camera/#pytvpaint.camera.Camera.anti_aliasing","title":"<code>anti_aliasing() -&gt; int</code>","text":"<p>The antialiasing value of the camera.</p> Source code in <code>pytvpaint/camera.py</code> <pre><code>@refreshed_property\n@set_as_current\ndef anti_aliasing(self) -&gt; int:\n    \"\"\"The antialiasing value of the camera.\"\"\"\n    return self._data.anti_aliasing\n</code></pre>"},{"location":"api/objects/camera/#pytvpaint.camera.Camera.insert_point","title":"<code>insert_point(index: int, x: int, y: int, angle: int, scale: float) -&gt; CameraPoint</code>","text":"<p>Insert a new point in the camera path.</p> Source code in <code>pytvpaint/camera.py</code> <pre><code>@set_as_current\ndef insert_point(\n    self,\n    index: int,\n    x: int,\n    y: int,\n    angle: int,\n    scale: float,\n) -&gt; CameraPoint:\n    \"\"\"Insert a new point in the camera path.\"\"\"\n    return CameraPoint.new(self, index, x, y, angle, scale)\n</code></pre>"},{"location":"api/objects/camera/#pytvpaint.camera.Camera.get_point_data_at","title":"<code>get_point_data_at(position: float) -&gt; george.TVPCameraPoint</code>","text":"<p>Get the points data interpolated at that position (between 0 and 1).</p> Source code in <code>pytvpaint/camera.py</code> <pre><code>@set_as_current\ndef get_point_data_at(self, position: float) -&gt; george.TVPCameraPoint:\n    \"\"\"Get the points data interpolated at that position (between 0 and 1).\"\"\"\n    position = max(0.0, min(position, 1.0))\n    return george.tv_camera_interpolation(position)\n</code></pre>"},{"location":"api/objects/camera/#pytvpaint.camera.Camera.remove_point","title":"<code>remove_point(index: int) -&gt; None</code>","text":"<p>Remove a point at that index.</p> Source code in <code>pytvpaint/camera.py</code> <pre><code>@set_as_current\ndef remove_point(self, index: int) -&gt; None:\n    \"\"\"Remove a point at that index.\"\"\"\n    try:\n        point = next(p for i, p in enumerate(self.points) if i == index)\n        point.remove()\n    except StopIteration:\n        pass\n</code></pre>"},{"location":"api/objects/camera/#pytvpaint.camera.CameraPoint","title":"<code>CameraPoint(index: int, camera: Camera, data: george.TVPCameraPoint | None = None)</code>","text":"<p>             Bases: <code>pytvpaint.utils.Removable</code></p> <p>A CameraPoint is a point on the camera path.</p> <p>You can use them to animate the camera movement.</p> Source code in <code>pytvpaint/camera.py</code> <pre><code>def __init__(\n    self,\n    index: int,\n    camera: Camera,\n    data: george.TVPCameraPoint | None = None,\n) -&gt; None:\n    super().__init__()\n    self._index: int = index\n    self._camera: Camera = camera\n    self._data = data or george.tv_camera_enum_points(self._index)\n</code></pre>"},{"location":"api/objects/camera/#pytvpaint.camera.CameraPoint.data","title":"<code>data: george.TVPCameraPoint</code>  <code>property</code>","text":"<p>Returns the raw data of the point.</p>"},{"location":"api/objects/camera/#pytvpaint.camera.CameraPoint.index","title":"<code>index: int</code>  <code>property</code>","text":"<p>The index of the point in the path.</p>"},{"location":"api/objects/camera/#pytvpaint.camera.CameraPoint.camera","title":"<code>camera: Camera</code>  <code>property</code>","text":"<p>The camera instance it belongs to.</p>"},{"location":"api/objects/camera/#pytvpaint.camera.CameraPoint.refresh","title":"<code>refresh() -&gt; None</code>","text":"<p>Refreshed the camera point data.</p> Source code in <code>pytvpaint/camera.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshed the camera point data.\"\"\"\n    super().refresh()\n    if not self.refresh_on_call and self._data:\n        return\n    self._data = george.tv_camera_enum_points(self._index)\n</code></pre>"},{"location":"api/objects/camera/#pytvpaint.camera.CameraPoint.new","title":"<code>new(camera: Camera, index: int, x: int, y: int, angle: int, scale: float) -&gt; CameraPoint</code>  <code>classmethod</code>","text":"<p>Create a new point and add it to the camera path at that index.</p> Source code in <code>pytvpaint/camera.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    camera: Camera,\n    index: int,\n    x: int,\n    y: int,\n    angle: int,\n    scale: float,\n) -&gt; CameraPoint:\n    \"\"\"Create a new point and add it to the camera path at that index.\"\"\"\n    george.tv_camera_insert_point(index, x, y, angle, scale)\n    return cls(index, camera)\n</code></pre>"},{"location":"api/objects/camera/#pytvpaint.camera.CameraPoint.remove","title":"<code>remove() -&gt; None</code>","text":"<p>Remove the camera point.</p> Warning <p>the point instance won't be usable after that call</p> Source code in <code>pytvpaint/camera.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"Remove the camera point.\n\n    Warning:\n        the point instance won't be usable after that call\n    \"\"\"\n    george.tv_camera_remove_point(self.index)\n    self.mark_removed()\n</code></pre>"},{"location":"api/objects/clip/","title":"Clip class","text":"<p>Clip object class module.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip","title":"<code>Clip(clip_id: int, project: Project | None = None)</code>","text":"<p>             Bases: <code>pytvpaint.utils.Removable</code>, <code>pytvpaint.utils.Renderable</code></p> <p>A Clip is a container for layers and is part of a Scene.</p> <p>Constructs a Clip from an existing TVPaint clip (giving its id).</p> Note <p>You should use <code>Clip.new</code> to create a new clip</p> <p>Parameters:</p> Name Type Description Default <code>clip_id</code> <code>int</code> <p>an existing clip id</p> required <code>project</code> <code>pytvpaint.project.Project | None</code> <p>the project or the current one if None</p> <code>None</code> Source code in <code>pytvpaint/clip.py</code> <pre><code>def __init__(\n    self,\n    clip_id: int,\n    project: Project | None = None,\n) -&gt; None:\n    \"\"\"Constructs a Clip from an existing TVPaint clip (giving its id).\n\n    Note:\n        You should use `Clip.new` to create a new clip\n\n    Args:\n        clip_id: an existing clip id\n        project: the project or the current one if None\n    \"\"\"\n    from pytvpaint.project import Project\n\n    super().__init__()\n    self._id = clip_id\n    self._project = project or Project.current_project()\n    self._data = george.tv_clip_info(self.id)\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.id","title":"<code>id: int</code>  <code>property</code>","text":"<p>The clip id.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.project","title":"<code>project: Project</code>  <code>property</code>","text":"<p>The clip's project.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.scene","title":"<code>scene: Scene</code>  <code>property</code> <code>writable</code>","text":"<p>The clip's scene.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if clip cannot be found in the project</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.camera","title":"<code>camera: Camera</code>  <code>property</code>","text":"<p>The clip camera.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.position","title":"<code>position: int</code>  <code>property</code> <code>writable</code>","text":"<p>The position of the clip in the scene.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if clip cannot be found in the project</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.name","title":"<code>name: str</code>  <code>property</code> <code>writable</code>","text":"<p>The clip name.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.duration","title":"<code>duration: int</code>  <code>property</code>","text":"<p>The duration of the clip in frames. Takes into account the mark in/out of the clip.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.is_selected","title":"<code>is_selected: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Returns True if the clip is selected.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.is_visible","title":"<code>is_visible: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Returns True if the clip is visible.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.color_index","title":"<code>color_index: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the clip color index.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.action_text","title":"<code>action_text: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get the action text of the clip.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.dialog_text","title":"<code>dialog_text: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get the dialog text of the clip.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.note_text","title":"<code>note_text: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get the note text of the clip.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.current_frame","title":"<code>current_frame: int</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the current frame in the clip (timeline) relative to the project start frame.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.layer_ids","title":"<code>layer_ids: Iterator[int]</code>  <code>property</code>","text":"<p>Iterator over the layer ids.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.layers","title":"<code>layers: Iterator[Layer]</code>  <code>property</code>","text":"<p>Iterator over the clip's layers.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.layer_names","title":"<code>layer_names: Iterator[str]</code>  <code>property</code>","text":"<p>Iterator over the clip's layer names.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.current_layer","title":"<code>current_layer: Layer</code>  <code>property</code>","text":"<p>Get the current layer in the clip.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if clip cannot be found in the project</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.selected_layers","title":"<code>selected_layers: Iterator[Layer]</code>  <code>property</code>","text":"<p>Iterator over the selected layers.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.visible_layers","title":"<code>visible_layers: Iterator[Layer]</code>  <code>property</code>","text":"<p>Iterator over the visible layers.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.mark_in","title":"<code>mark_in: int | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get the mark in of the clip.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.mark_out","title":"<code>mark_out: int | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get the mark out of the clip.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.layer_colors","title":"<code>layer_colors: Iterator[LayerColor]</code>  <code>property</code>","text":"<p>Iterator over the layer colors.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.bookmarks","title":"<code>bookmarks: Iterator[int]</code>  <code>property</code>","text":"<p>Iterator over the clip bookmarks.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.sounds","title":"<code>sounds: Iterator[ClipSound]</code>  <code>property</code>","text":"<p>Iterates through the clip's soundtracks.</p>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.new","title":"<code>new(name: str, scene: Scene | None = None, project: Project | None = None) -&gt; Clip</code>  <code>classmethod</code>","text":"<p>Creates a new clip.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the new clip name</p> required <code>scene</code> <code>pytvpaint.scene.Scene | None</code> <p>the scene or the current one if None. Defaults to None.</p> <code>None</code> <code>project</code> <code>pytvpaint.project.Project | None</code> <p>the project or the current one if None. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Clip</code> <code>pytvpaint.clip.Clip</code> <p>the newly created clip</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    name: str,\n    scene: Scene | None = None,\n    project: Project | None = None,\n) -&gt; Clip:\n    \"\"\"Creates a new clip.\n\n    Args:\n        name: the new clip name\n        scene: the scene or the current one if None. Defaults to None.\n        project: the project or the current one if None. Defaults to None.\n\n    Returns:\n        Clip: the newly created clip\n    \"\"\"\n    from pytvpaint.project import Project\n\n    project = project or Project.current_project()\n    project.make_current()\n\n    scene = scene or project.current_scene\n    scene.make_current()\n\n    name = utils.get_unique_name(project.clip_names, name)\n    george.tv_clip_new(name)\n\n    return Clip.current_clip()\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.refresh","title":"<code>refresh() -&gt; None</code>","text":"<p>Refreshes the clip data.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the clip data.\"\"\"\n    super().refresh()\n    if not self.refresh_on_call and self._data:\n        return\n    self._data = george.tv_clip_info(self._id)\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.make_current","title":"<code>make_current() -&gt; None</code>","text":"<p>Make the clip the current one.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>def make_current(self) -&gt; None:\n    \"\"\"Make the clip the current one.\"\"\"\n    if george.tv_clip_current_id() == self.id:\n        return\n    george.tv_clip_select(self.id)\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.start","title":"<code>start() -&gt; int</code>","text":"<p>The start frame of the clip.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@refreshed_property\ndef start(self) -&gt; int:\n    \"\"\"The start frame of the clip.\"\"\"\n    return self._data.first_frame + self.project.start_frame\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.end","title":"<code>end() -&gt; int</code>","text":"<p>The end frame of the clip.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@refreshed_property\ndef end(self) -&gt; int:\n    \"\"\"The end frame of the clip.\"\"\"\n    return self._data.last_frame + self.project.start_frame\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.timeline_start","title":"<code>timeline_start() -&gt; int</code>","text":"<p>The start frame of the clip relative to the project's timeline.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@refreshed_property\ndef timeline_start(self) -&gt; int:\n    \"\"\"The start frame of the clip relative to the project's timeline.\"\"\"\n    # get clip real start in project timeline\n    clip_real_start = 0\n    for clip in self.project.clips:\n        if clip == self:\n            break\n        clip_start = clip.mark_in or clip.start\n        clip_end = clip.mark_out or clip.end\n        clip_duration = (clip_end - clip_start) + 1\n        clip_real_start += clip_duration\n\n    return clip_real_start + self.project.start_frame\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.timeline_end","title":"<code>timeline_end() -&gt; int</code>","text":"<p>The end frame of the clip relative to the project's timeline.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@refreshed_property\ndef timeline_end(self) -&gt; int:\n    \"\"\"The end frame of the clip relative to the project's timeline.\"\"\"\n    clip_start = self.mark_in or self.start\n    clip_end = self.mark_out or self.end\n    clip_duration = clip_end - clip_start\n    return self.timeline_start + clip_duration\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.frame_count","title":"<code>frame_count() -&gt; int</code>","text":"<p>The clip's frame count.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@refreshed_property\ndef frame_count(self) -&gt; int:\n    \"\"\"The clip's frame count.\"\"\"\n    return self._data.frame_count\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.is_current","title":"<code>is_current() -&gt; bool</code>","text":"<p>Returns True if the clip is the current one.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@refreshed_property\ndef is_current(self) -&gt; bool:\n    \"\"\"Returns True if the clip is the current one.\"\"\"\n    return Clip.current_clip_id() == self.id\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.current_clip_id","title":"<code>current_clip_id() -&gt; int</code>  <code>staticmethod</code>","text":"<p>Returns the id of the current clip.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@staticmethod\ndef current_clip_id() -&gt; int:\n    \"\"\"Returns the id of the current clip.\"\"\"\n    return george.tv_clip_current_id()\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.current_clip","title":"<code>current_clip() -&gt; Clip</code>  <code>staticmethod</code>","text":"<p>Returns the current clip object.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@staticmethod\ndef current_clip() -&gt; Clip:\n    \"\"\"Returns the current clip object.\"\"\"\n    from pytvpaint.project import Project\n\n    return Clip(Clip.current_clip_id(), Project.current_project())\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.duplicate","title":"<code>duplicate() -&gt; Clip</code>","text":"<p>Duplicates the clip.</p> Note <p>a new unique name is choosen for the duplicated clip with <code>get_unique_name</code>.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@set_as_current\ndef duplicate(self) -&gt; Clip:\n    \"\"\"Duplicates the clip.\n\n    Note:\n        a new unique name is choosen for the duplicated clip with `get_unique_name`.\n    \"\"\"\n    george.tv_clip_duplicate(self.id)\n    new_clip = self.project.current_clip\n    new_clip.name = utils.get_unique_name(self.project.clip_names, new_clip.name)\n    return new_clip\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.remove","title":"<code>remove() -&gt; None</code>","text":"<p>Removes the clip.</p> Warning <p>the instance is not usable after that call because it's marked as removed.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"Removes the clip.\n\n    Warning:\n        the instance is not usable after that call because it's marked as removed.\n    \"\"\"\n    george.tv_clip_close(self.id)\n    self.mark_removed()\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.get_layer","title":"<code>get_layer(by_id: int | None = None, by_name: str | None = None) -&gt; Layer | None</code>","text":"<p>Get a specific layer by id or name.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>def get_layer(\n    self,\n    by_id: int | None = None,\n    by_name: str | None = None,\n) -&gt; Layer | None:\n    \"\"\"Get a specific layer by id or name.\"\"\"\n    return utils.get_tvp_element(self.layers, by_id, by_name)\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.add_layer","title":"<code>add_layer(layer_name: str) -&gt; Layer</code>","text":"<p>Add a new layer in the layer stack.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@set_as_current\ndef add_layer(self, layer_name: str) -&gt; Layer:\n    \"\"\"Add a new layer in the layer stack.\"\"\"\n    return Layer.new(name=layer_name, clip=self)\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.load_media","title":"<code>load_media(media_path: Path, start_count: tuple[int, int] | None = None, stretch: bool = False, time_stretch: bool = False, preload: bool = False, with_name: str = '', field_order: george.FieldOrder = george.FieldOrder.LOWER) -&gt; Layer</code>","text":"<p>Loads a media (single frame, video, ...) into a new Layer in the clip.</p> <p>Parameters:</p> Name Type Description Default <code>media_path</code> <code>pathlib.Path</code> <p>the path of the media. If it's a file sequence, give the path of the first image.</p> required <code>start_count</code> <code>tuple[int, int] | None</code> <p>the start and number of image of sequence to load. Defaults to None.</p> <code>None</code> <code>stretch</code> <code>bool</code> <p>Stretch each image to the size of the layer. Defaults to None.</p> <code>False</code> <code>time_stretch</code> <code>bool</code> <p>Once loaded, the layer will have a new number of image corresponding to the project framerate. Defaults to None.</p> <code>False</code> <code>preload</code> <code>bool</code> <p>Load all the images in memory, no more reference on the files. Defaults to None.</p> <code>False</code> <code>with_name</code> <code>str</code> <p>the name of the new layer</p> <code>''</code> <code>field_order</code> <code>pytvpaint.george.FieldOrder</code> <p>the field order. Defaults to None.</p> <code>pytvpaint.george.FieldOrder.LOWER</code> <p>Returns:</p> Name Type Description <code>Layer</code> <code>pytvpaint.layer.Layer</code> <p>the new layer created</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@set_as_current\n@george.undoable\ndef load_media(\n    self,\n    media_path: Path,\n    start_count: tuple[int, int] | None = None,\n    stretch: bool = False,\n    time_stretch: bool = False,\n    preload: bool = False,\n    with_name: str = \"\",\n    field_order: george.FieldOrder = george.FieldOrder.LOWER,\n) -&gt; Layer:\n    \"\"\"Loads a media (single frame, video, ...) into a new Layer in the clip.\n\n    Args:\n        media_path: the path of the media. If it's a file sequence, give the path of the first image.\n        start_count: the start and number of image of sequence to load. Defaults to None.\n        stretch: Stretch each image to the size of the layer. Defaults to None.\n        time_stretch: Once loaded, the layer will have a new number of image corresponding to the project framerate. Defaults to None.\n        preload: Load all the images in memory, no more reference on the files. Defaults to None.\n        with_name: the name of the new layer\n        field_order: the field order. Defaults to None.\n\n    Returns:\n        Layer: the new layer created\n    \"\"\"\n    media_path = Path(media_path)\n\n    george.tv_load_sequence(\n        media_path,\n        start_count,\n        field_order,\n        stretch,\n        time_stretch,\n        preload,\n    )\n\n    new_layer = Layer.current_layer()\n    new_layer.name = with_name or media_path.stem\n\n    return new_layer\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.render","title":"<code>render(output_path: Path | str | FileSequence, start: int | None = None, end: int | None = None, use_camera: bool = False, layer_selection: list[Layer] | None = None, alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY, background_mode: george.BackgroundMode | None = None, format_opts: list[str] | None = None) -&gt; None</code>","text":"<p>Render the clip to a single frame or frame sequence or movie.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>pathlib.Path | str | fileseq.filesequence.FileSequence</code> <p>a single file or file sequence pattern</p> required <code>start</code> <code>int | None</code> <p>the start frame to render or the mark in or the clip's start if None. Defaults to None.</p> <code>None</code> <code>end</code> <code>int | None</code> <p>the end frame to render or the mark out or the clip's end if None. Defaults to None.</p> <code>None</code> <code>use_camera</code> <code>bool</code> <p>use the camera for rendering, otherwise render the whole canvas. Defaults to False.</p> <code>False</code> <code>layer_selection</code> <code>list[pytvpaint.layer.Layer] | None</code> <p>list of layers to render, if None render all of them. Defaults to None.</p> <code>None</code> <code>alpha_mode</code> <code>pytvpaint.george.AlphaSaveMode</code> <p>the alpha mode for rendering. Defaults to george.AlphaSaveMode.PREMULTIPLY.</p> <code>pytvpaint.george.AlphaSaveMode.PREMULTIPLY</code> <code>background_mode</code> <code>pytvpaint.george.BackgroundMode | None</code> <p>the background mode for rendering. Defaults to None.</p> <code>None</code> <code>format_opts</code> <code>list[str] | None</code> <p>custom format options. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if requested range (start-end) not in clip range/bounds</p> <code>ValueError</code> <p>if output is a movie, and it's duration is equal to 1 frame</p> <code>FileNotFoundError</code> <p>if the render failed and no files were found on disk or missing frames</p> Note <p>This functions uses the clip's range as a basis (start-end). This  is different from a project range, which uses the project timeline. For more details on the differences in frame ranges and the timeline in TVPaint, please check the <code>Usage/Rendering</code> section of the documentation.</p> Warning <p>Even tough pytvpaint does a pretty good job of correcting the frame ranges for rendering, we're still encountering some weird edge cases where TVPaint will consider the range invalid for seemingly no reason.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@set_as_current\ndef render(\n    self,\n    output_path: Path | str | FileSequence,\n    start: int | None = None,\n    end: int | None = None,\n    use_camera: bool = False,\n    layer_selection: list[Layer] | None = None,\n    alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY,\n    background_mode: george.BackgroundMode | None = None,\n    format_opts: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Render the clip to a single frame or frame sequence or movie.\n\n    Args:\n        output_path: a single file or file sequence pattern\n        start: the start frame to render or the mark in or the clip's start if None. Defaults to None.\n        end: the end frame to render or the mark out or the clip's end if None. Defaults to None.\n        use_camera: use the camera for rendering, otherwise render the whole canvas. Defaults to False.\n        layer_selection: list of layers to render, if None render all of them. Defaults to None.\n        alpha_mode: the alpha mode for rendering. Defaults to george.AlphaSaveMode.PREMULTIPLY.\n        background_mode: the background mode for rendering. Defaults to None.\n        format_opts: custom format options. Defaults to None.\n\n    Raises:\n        ValueError: if requested range (start-end) not in clip range/bounds\n        ValueError: if output is a movie, and it's duration is equal to 1 frame\n        FileNotFoundError: if the render failed and no files were found on disk or missing frames\n\n    Note:\n        This functions uses the clip's range as a basis (start-end). This  is different from a project range, which\n        uses the project timeline. For more details on the differences in frame ranges and the timeline in TVPaint,\n        please check the `Usage/Rendering` section of the documentation.\n\n    Warning:\n        Even tough pytvpaint does a pretty good job of correcting the frame ranges for rendering, we're still\n        encountering some weird edge cases where TVPaint will consider the range invalid for seemingly no reason.\n    \"\"\"\n    default_start = self.mark_in or self.start\n    default_end = self.mark_out or self.end\n\n    self._render(\n        output_path,\n        default_start,\n        default_end,\n        start,\n        end,\n        use_camera,\n        layer_selection=layer_selection,\n        alpha_mode=alpha_mode,\n        background_mode=background_mode,\n        format_opts=format_opts,\n    )\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.export_tvp","title":"<code>export_tvp(export_path: Path | str) -&gt; None</code>","text":"<p>Exports the clip in .tvp format which can be imported as a project in TVPaint.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if output extension is not (.tvp)</p> <code>FileNotFoundError</code> <p>if the render failed and no files were found on disk</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@set_as_current\ndef export_tvp(self, export_path: Path | str) -&gt; None:\n    \"\"\"Exports the clip in .tvp format which can be imported as a project in TVPaint.\n\n    Raises:\n        ValueError: if output extension is not (.tvp)\n        FileNotFoundError: if the render failed and no files were found on disk\n    \"\"\"\n    export_path = Path(export_path)\n\n    if export_path.suffix != \".tvp\":\n        raise ValueError(\"The file extension must be .tvp\")\n\n    export_path.parent.mkdir(exist_ok=True, parents=True)\n    george.tv_save_clip(export_path)\n\n    if not export_path.exists():\n        raise FileNotFoundError(\n            f\"Could not find output at : {export_path.as_posix()}\"\n        )\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.export_json","title":"<code>export_json(export_path: Path | str, save_format: george.SaveFormat, folder_pattern: str = '[%3li] %ln', file_pattern: str = '[%3ii] %ln', layer_selection: list[Layer] | None = None, alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY, background_mode: george.BackgroundMode | None = None, format_opts: list[str] | None = None, all_images: bool = False, ignore_duplicates: bool = False) -&gt; None</code>","text":"<p>Exports the instances (or all the images) of layers in the clip and a JSON file describing the structure of that clip.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>pathlib.Path | str</code> <p>the JSON export path</p> required <code>save_format</code> <code>pytvpaint.george.SaveFormat</code> <p>file format to use for rendering</p> required <code>folder_pattern</code> <code>str</code> <p>the folder name pattern (%li: layer index, %ln: layer name, %fi: file index (added in 11.0.8)). Defaults to None.</p> <code>'[%3li] %ln'</code> <code>file_pattern</code> <code>str</code> <p>the file name pattern (%li: layer index, %ln: layer name, %ii: image index, %in: image name, %fi: file index (added in 11.0.8)). Defaults to None.</p> <code>'[%3ii] %ln'</code> <code>layer_selection</code> <code>list[pytvpaint.layer.Layer] | None</code> <p>list of layers to render or all if None. Defaults to None.</p> <code>None</code> <code>alpha_mode</code> <code>pytvpaint.george.AlphaSaveMode</code> <p>the export alpha mode. Defaults to george.AlphaSaveMode.PREMULTIPLY.</p> <code>pytvpaint.george.AlphaSaveMode.PREMULTIPLY</code> <code>background_mode</code> <code>pytvpaint.george.BackgroundMode | None</code> <p>the export background mode. Defaults to None.</p> <code>None</code> <code>format_opts</code> <code>list[str] | None</code> <p>custom format options. Defaults to None.</p> <code>None</code> <code>all_images</code> <code>bool</code> <p>export all images (not only the instances). Defaults to False.</p> <code>False</code> <code>ignore_duplicates</code> <code>bool</code> <p>Ignore duplicates images. Defaults to None.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the export failed and no files were found on disk</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@set_as_current\ndef export_json(\n    self,\n    export_path: Path | str,\n    save_format: george.SaveFormat,\n    folder_pattern: str = r\"[%3li] %ln\",\n    file_pattern: str = r\"[%3ii] %ln\",\n    layer_selection: list[Layer] | None = None,\n    alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY,\n    background_mode: george.BackgroundMode | None = None,\n    format_opts: list[str] | None = None,\n    all_images: bool = False,\n    ignore_duplicates: bool = False,\n) -&gt; None:\n    \"\"\"Exports the instances (or all the images) of layers in the clip and a JSON file describing the structure of that clip.\n\n    Args:\n        export_path: the JSON export path\n        save_format: file format to use for rendering\n        folder_pattern: the folder name pattern (%li: layer index, %ln: layer name, %fi: file index (added in 11.0.8)). Defaults to None.\n        file_pattern: the file name pattern (%li: layer index, %ln: layer name, %ii: image index, %in: image name, %fi: file index (added in 11.0.8)). Defaults to None.\n        layer_selection: list of layers to render or all if None. Defaults to None.\n        alpha_mode: the export alpha mode. Defaults to george.AlphaSaveMode.PREMULTIPLY.\n        background_mode: the export background mode. Defaults to None.\n        format_opts: custom format options. Defaults to None.\n        all_images: export all images (not only the instances). Defaults to False.\n        ignore_duplicates: Ignore duplicates images. Defaults to None.\n\n    Raises:\n        FileNotFoundError: if the export failed and no files were found on disk\n    \"\"\"\n    export_path = Path(export_path)\n    export_path.parent.mkdir(exist_ok=True, parents=True)\n\n    fill_background = bool(\n        background_mode not in [None, george.BackgroundMode.NONE]\n    )\n\n    with utils.render_context(\n        alpha_mode, background_mode, save_format, format_opts, layer_selection\n    ):\n        george.tv_clip_save_structure_json(\n            export_path,\n            save_format,\n            fill_background=fill_background,\n            folder_pattern=folder_pattern,\n            file_pattern=file_pattern,\n            visible_layers_only=True,\n            all_images=all_images,\n            ignore_duplicates=ignore_duplicates,\n        )\n\n    if not export_path.exists():\n        raise FileNotFoundError(\n            f\"Could not find output at : {export_path.as_posix()}\"\n        )\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.export_psd","title":"<code>export_psd(export_path: Path | str, mode: george.PSDSaveMode, start: int | None = None, end: int | None = None, layer_selection: list[Layer] | None = None, alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY, background_mode: george.BackgroundMode | None = None, format_opts: list[str] | None = None) -&gt; None</code>","text":"<p>Save the current clip as a PSD.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>pathlib.Path | str</code> <p>the PSD save path</p> required <code>mode</code> <code>pytvpaint.george.PSDSaveMode</code> <p>whether to save all the images, only the instances or inside the markin</p> required <code>start</code> <code>int | None</code> <p>the start frame. Defaults to None.</p> <code>None</code> <code>end</code> <code>int | None</code> <p>the end frame. Defaults to None.</p> <code>None</code> <code>layer_selection</code> <code>list[pytvpaint.layer.Layer] | None</code> <p>layers to render. Defaults to None (render all the layers).</p> <code>None</code> <code>alpha_mode</code> <code>pytvpaint.george.AlphaSaveMode</code> <p>the alpha save mode. Defaults to george.AlphaSaveMode.PREMULTIPLY.</p> <code>pytvpaint.george.AlphaSaveMode.PREMULTIPLY</code> <code>background_mode</code> <code>pytvpaint.george.BackgroundMode | None</code> <p>the export background mode. Defaults to None.</p> <code>None</code> <code>format_opts</code> <code>list[str] | None</code> <p>custom format options. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the export failed and no files were found on disk</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@set_as_current\ndef export_psd(\n    self,\n    export_path: Path | str,\n    mode: george.PSDSaveMode,\n    start: int | None = None,\n    end: int | None = None,\n    layer_selection: list[Layer] | None = None,\n    alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY,\n    background_mode: george.BackgroundMode | None = None,\n    format_opts: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Save the current clip as a PSD.\n\n    Args:\n        export_path: the PSD save path\n        mode: whether to save all the images, only the instances or inside the markin\n        start: the start frame. Defaults to None.\n        end: the end frame. Defaults to None.\n        layer_selection: layers to render. Defaults to None (render all the layers).\n        alpha_mode: the alpha save mode. Defaults to george.AlphaSaveMode.PREMULTIPLY.\n        background_mode: the export background mode. Defaults to None.\n        format_opts: custom format options. Defaults to None.\n\n    Raises:\n        FileNotFoundError: if the export failed and no files were found on disk\n    \"\"\"\n    start = start or self.mark_in or self.start\n    end = end or self.mark_out or self.end\n\n    export_path = Path(export_path)\n    image = start if mode == george.PSDSaveMode.IMAGE else None\n\n    with utils.render_context(\n        alpha_mode,\n        background_mode,\n        george.SaveFormat.PSD,\n        format_opts,\n        layer_selection,\n    ):\n        george.tv_clip_save_structure_psd(\n            export_path,\n            mode,\n            image=image,\n            mark_in=start,\n            mark_out=end,\n        )\n\n    if mode == george.PSDSaveMode.MARKIN:\n        # raises error if sequence not found\n        check_path = export_path.with_suffix(f\".#{export_path.suffix}\").as_posix()\n        assert FileSequence.findSequenceOnDisk(check_path)\n    else:\n        if not export_path.exists():\n            raise FileNotFoundError(\n                f\"Could not find output at : {export_path.as_posix()}\"\n            )\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.export_csv","title":"<code>export_csv(export_path: Path | str, save_format: george.SaveFormat, all_images: bool = False, exposure_label: str = '', layer_selection: list[Layer] | None = None, alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY, background_mode: george.BackgroundMode | None = None, format_opts: list[str] | None = None) -&gt; None</code>","text":"<p>Save the current clip as a CSV.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>pathlib.Path | str</code> <p>the .csv export path</p> required <code>save_format</code> <code>pytvpaint.george.SaveFormat</code> <p>file format to use for rendering</p> required <code>all_images</code> <code>bool</code> <p>export all images or only instances. Defaults to None.</p> <code>False</code> <code>exposure_label</code> <code>str</code> <p>give a label when the image is an exposure. Defaults to None.</p> <code>''</code> <code>layer_selection</code> <code>list[pytvpaint.layer.Layer] | None</code> <p>layers to render. Defaults to None (render all the layers).</p> <code>None</code> <code>alpha_mode</code> <code>pytvpaint.george.AlphaSaveMode</code> <p>the alpha save mode. Defaults to george.AlphaSaveMode.PREMULTIPLY.</p> <code>pytvpaint.george.AlphaSaveMode.PREMULTIPLY</code> <code>background_mode</code> <code>pytvpaint.george.BackgroundMode | None</code> <p>the export background mode. Defaults to None.</p> <code>None</code> <code>format_opts</code> <code>list[str] | None</code> <p>custom format options. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the extension is not .csv</p> <code>FileNotFoundError</code> <p>if the render failed and no files were found on disk</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@set_as_current\ndef export_csv(\n    self,\n    export_path: Path | str,\n    save_format: george.SaveFormat,\n    all_images: bool = False,\n    exposure_label: str = \"\",\n    layer_selection: list[Layer] | None = None,\n    alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY,\n    background_mode: george.BackgroundMode | None = None,\n    format_opts: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Save the current clip as a CSV.\n\n    Args:\n        export_path: the .csv export path\n        save_format: file format to use for rendering\n        all_images: export all images or only instances. Defaults to None.\n        exposure_label: give a label when the image is an exposure. Defaults to None.\n        layer_selection: layers to render. Defaults to None (render all the layers).\n        alpha_mode: the alpha save mode. Defaults to george.AlphaSaveMode.PREMULTIPLY.\n        background_mode: the export background mode. Defaults to None.\n        format_opts: custom format options. Defaults to None.\n\n    Raises:\n        ValueError: if the extension is not .csv\n        FileNotFoundError: if the render failed and no files were found on disk\n    \"\"\"\n    export_path = Path(export_path)\n\n    if export_path.suffix != \".csv\":\n        raise ValueError(\"Export path must have .csv extension\")\n\n    with utils.render_context(\n        alpha_mode, background_mode, save_format, format_opts, layer_selection\n    ):\n        george.tv_clip_save_structure_csv(export_path, all_images, exposure_label)\n\n    if not export_path.exists():\n        raise FileNotFoundError(\n            f\"Could not find output at : {export_path.as_posix()}\"\n        )\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.export_sprites","title":"<code>export_sprites(export_path: Path | str, layout: george.SpriteLayout | None = None, space: int = 0, layer_selection: list[Layer] | None = None, alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY, background_mode: george.BackgroundMode | None = None, format_opts: list[str] | None = None) -&gt; None</code>","text":"<p>Save the current clip as sprites in one image.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>pathlib.Path | str</code> <p>description</p> required <code>layout</code> <code>pytvpaint.george.SpriteLayout | None</code> <p>the sprite layout. Defaults to None.</p> <code>None</code> <code>space</code> <code>int</code> <p>the space between each sprite in the image. Defaults to None.</p> <code>0</code> <code>layer_selection</code> <code>list[pytvpaint.layer.Layer] | None</code> <p>layers to render. Defaults to None (render all the layers).</p> <code>None</code> <code>alpha_mode</code> <code>pytvpaint.george.AlphaSaveMode</code> <p>the alpha save mode. Defaults to george.AlphaSaveMode.PREMULTIPLY.</p> <code>pytvpaint.george.AlphaSaveMode.PREMULTIPLY</code> <code>background_mode</code> <code>pytvpaint.george.BackgroundMode | None</code> <p>the export background mode. Defaults to None.</p> <code>None</code> <code>format_opts</code> <code>list[str] | None</code> <p>custom format options. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the export failed and no files were found on disk</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@set_as_current\ndef export_sprites(\n    self,\n    export_path: Path | str,\n    layout: george.SpriteLayout | None = None,\n    space: int = 0,\n    layer_selection: list[Layer] | None = None,\n    alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY,\n    background_mode: george.BackgroundMode | None = None,\n    format_opts: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Save the current clip as sprites in one image.\n\n    Args:\n        export_path (Path | str): _description_\n        layout: the sprite layout. Defaults to None.\n        space: the space between each sprite in the image. Defaults to None.\n        layer_selection: layers to render. Defaults to None (render all the layers).\n        alpha_mode: the alpha save mode. Defaults to george.AlphaSaveMode.PREMULTIPLY.\n        background_mode: the export background mode. Defaults to None.\n        format_opts: custom format options. Defaults to None.\n\n    Raises:\n        FileNotFoundError: if the export failed and no files were found on disk\n    \"\"\"\n    export_path = Path(export_path)\n    save_format = george.SaveFormat.from_extension(export_path.suffix)\n\n    with utils.render_context(\n        alpha_mode, background_mode, save_format, format_opts, layer_selection\n    ):\n        george.tv_clip_save_structure_sprite(export_path, layout, space)\n\n    if not export_path.exists():\n        raise FileNotFoundError(\n            f\"Could not find output at : {export_path.as_posix()}\"\n        )\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.export_flix","title":"<code>export_flix(export_path: Path | str, start: int | None = None, end: int | None = None, import_parameters: str = '', file_parameters: str = '', send: bool = False, layer_selection: list[Layer] | None = None, alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY, background_mode: george.BackgroundMode | None = None, format_opts: list[str] | None = None) -&gt; None</code>","text":"<p>Save the current clip for Flix.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>pathlib.Path | str</code> <p>the .xml export path</p> required <code>start</code> <code>int | None</code> <p>the start frame. Defaults to None.</p> <code>None</code> <code>end</code> <code>int | None</code> <p>the end frame. Defaults to None.</p> <code>None</code> <code>import_parameters</code> <code>str</code> <p>the attribute(s) of the global  tag (waitForSource/...). Defaults to None. <code>''</code> <code>file_parameters</code> <code>str</code> <p>the attribute(s) of each  (file) tag (dialogue/...). Defaults to None. <code>''</code> <code>send</code> <code>bool</code> <p>open a browser with the prefilled url. Defaults to None.</p> <code>False</code> <code>layer_selection</code> <code>list[pytvpaint.layer.Layer] | None</code> <p>layers to render. Defaults to None (render all the layers).</p> <code>None</code> <code>alpha_mode</code> <code>pytvpaint.george.AlphaSaveMode</code> <p>the alpha save mode. Defaults to george.AlphaSaveMode.PREMULTIPLY.</p> <code>pytvpaint.george.AlphaSaveMode.PREMULTIPLY</code> <code>background_mode</code> <code>pytvpaint.george.BackgroundMode | None</code> <p>the export background mode. Defaults to None.</p> <code>None</code> <code>format_opts</code> <code>list[str] | None</code> <p>custom format options. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the extension is not .xml</p> <code>FileNotFoundError</code> <p>if the export failed and no files were found on disk</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@set_as_current\ndef export_flix(\n    self,\n    export_path: Path | str,\n    start: int | None = None,\n    end: int | None = None,\n    import_parameters: str = \"\",\n    file_parameters: str = \"\",\n    send: bool = False,\n    layer_selection: list[Layer] | None = None,\n    alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY,\n    background_mode: george.BackgroundMode | None = None,\n    format_opts: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Save the current clip for Flix.\n\n    Args:\n        export_path: the .xml export path\n        start: the start frame. Defaults to None.\n        end: the end frame. Defaults to None.\n        import_parameters: the attribute(s) of the global &lt;flixImport&gt; tag (waitForSource/...). Defaults to None.\n        file_parameters: the attribute(s) of each &lt;image&gt; (file) tag (dialogue/...). Defaults to None.\n        send: open a browser with the prefilled url. Defaults to None.\n        layer_selection: layers to render. Defaults to None (render all the layers).\n        alpha_mode: the alpha save mode. Defaults to george.AlphaSaveMode.PREMULTIPLY.\n        background_mode: the export background mode. Defaults to None.\n        format_opts: custom format options. Defaults to None.\n\n    Raises:\n        ValueError: if the extension is not .xml\n        FileNotFoundError: if the export failed and no files were found on disk\n    \"\"\"\n    export_path = Path(export_path)\n\n    if export_path.suffix != \".xml\":\n        raise ValueError(\"Export path must have .xml extension\")\n\n    original_file = self.project.path\n    import_parameters = (\n        import_parameters\n        or 'waitForSource=\"1\" multipleSetups=\"1\" replaceSelection=\"0\"'\n    )\n\n    # The project needs to be saved\n    self.project.save()\n\n    # save alpha mode and save format values\n    with utils.render_context(\n        alpha_mode, background_mode, None, format_opts, layer_selection\n    ):\n        george.tv_clip_save_structure_flix(\n            export_path,\n            start,\n            end,\n            import_parameters,\n            file_parameters,\n            send,\n            original_file,\n        )\n\n    if not export_path.exists():\n        raise FileNotFoundError(\n            f\"Could not find output at : {export_path.as_posix()}\"\n        )\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.set_layer_color","title":"<code>set_layer_color(layer_color: LayerColor) -&gt; None</code>","text":"<p>Set the layer color at the provided index.</p> <p>Parameters:</p> Name Type Description Default <code>layer_color</code> <code>pytvpaint.layer.LayerColor</code> <p>the layer color instance.</p> required Source code in <code>pytvpaint/clip.py</code> <pre><code>def set_layer_color(self, layer_color: LayerColor) -&gt; None:\n    \"\"\"Set the layer color at the provided index.\n\n    Args:\n        layer_color: the layer color instance.\n    \"\"\"\n    george.tv_layer_color_set_color(\n        self.id, layer_color.index, layer_color.color, layer_color.name\n    )\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.get_layer_color","title":"<code>get_layer_color(by_index: int | None = None, by_name: str | None = None) -&gt; LayerColor | None</code>","text":"<p>Get a layer color by index or name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if none of the arguments <code>by_index</code> and <code>by_name</code> where provided</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>def get_layer_color(\n    self,\n    by_index: int | None = None,\n    by_name: str | None = None,\n) -&gt; LayerColor | None:\n    \"\"\"Get a layer color by index or name.\n\n    Raises:\n        ValueError: if none of the arguments `by_index` and `by_name` where provided\n    \"\"\"\n    if not by_index and by_name:\n        raise ValueError(\n            \"At least one value (by_index or by_name) must be provided\"\n        )\n\n    if by_index is not None:\n        return next(c for i, c in enumerate(self.layer_colors) if i == by_index)\n\n    try:\n        return next(c for c in self.layer_colors if c.name == by_name)\n    except StopIteration:\n        return None\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.add_bookmark","title":"<code>add_bookmark(frame: int) -&gt; None</code>","text":"<p>Add a bookmark at that frame.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>def add_bookmark(self, frame: int) -&gt; None:\n    \"\"\"Add a bookmark at that frame.\"\"\"\n    george.tv_bookmark_set(frame - self.project.start_frame)\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.remove_bookmark","title":"<code>remove_bookmark(frame: int) -&gt; None</code>","text":"<p>Remove a bookmark at that frame.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>def remove_bookmark(self, frame: int) -&gt; None:\n    \"\"\"Remove a bookmark at that frame.\"\"\"\n    george.tv_bookmark_clear(frame - self.project.start_frame)\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.clear_bookmarks","title":"<code>clear_bookmarks() -&gt; None</code>","text":"<p>Remove all the bookmarks.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>def clear_bookmarks(self) -&gt; None:\n    \"\"\"Remove all the bookmarks.\"\"\"\n    bookmarks = list(self.bookmarks)\n    for frame in bookmarks:\n        self.remove_bookmark(frame)\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.go_to_previous_bookmark","title":"<code>go_to_previous_bookmark() -&gt; None</code>","text":"<p>Go to the previous bookmarks frame.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@set_as_current\ndef go_to_previous_bookmark(self) -&gt; None:\n    \"\"\"Go to the previous bookmarks frame.\"\"\"\n    george.tv_bookmark_prev()\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.go_to_next_bookmark","title":"<code>go_to_next_bookmark() -&gt; None</code>","text":"<p>Go to the next bookmarks frame.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>@set_as_current\ndef go_to_next_bookmark(self) -&gt; None:\n    \"\"\"Go to the next bookmarks frame.\"\"\"\n    george.tv_bookmark_next()\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.get_sound","title":"<code>get_sound(by_id: int | None = None, by_path: Path | str | None = None) -&gt; ClipSound | None</code>","text":"<p>Get a clip sound by id or by path.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if sound object could not be found in clip</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>def get_sound(\n    self,\n    by_id: int | None = None,\n    by_path: Path | str | None = None,\n) -&gt; ClipSound | None:\n    \"\"\"Get a clip sound by id or by path.\n\n    Raises:\n        ValueError: if sound object could not be found in clip\n    \"\"\"\n    for sound in self.sounds:\n        if (by_id and sound.id == by_id) or (by_path and sound.path == by_path):\n            return sound\n\n    return None\n</code></pre>"},{"location":"api/objects/clip/#pytvpaint.clip.Clip.add_sound","title":"<code>add_sound(sound_path: Path | str) -&gt; ClipSound</code>","text":"<p>Adds a new clip soundtrack.</p> Source code in <code>pytvpaint/clip.py</code> <pre><code>def add_sound(self, sound_path: Path | str) -&gt; ClipSound:\n    \"\"\"Adds a new clip soundtrack.\"\"\"\n    return ClipSound.new(sound_path, parent=self)\n</code></pre>"},{"location":"api/objects/clip_sound/","title":"ClipSound class","text":"<p>             Bases: <code>pytvpaint.sound.BaseSound['Clip']</code></p> <p>A clip sound.</p> Source code in <code>pytvpaint/sound.py</code> <pre><code>def __init__(\n    self,\n    track_index: int,\n    clip: Clip | None = None,\n) -&gt; None:\n    from pytvpaint.clip import Clip\n\n    clip = clip or Clip.current_clip()\n    super().__init__(track_index, clip)\n</code></pre>"},{"location":"api/objects/clip_sound/#pytvpaint.sound.ClipSound.clip","title":"<code>clip: Clip</code>  <code>property</code>","text":"<p>The sound's clip.</p>"},{"location":"api/objects/clip_sound/#pytvpaint.sound.ClipSound.make_current","title":"<code>make_current() -&gt; None</code>","text":"<p>Makes the sound clip current.</p> Source code in <code>pytvpaint/sound.py</code> <pre><code>def make_current(self) -&gt; None:\n    \"\"\"Makes the sound clip current.\"\"\"\n    self.clip.make_current()\n</code></pre>"},{"location":"api/objects/clip_sound/#pytvpaint.sound.ClipSound.remove","title":"<code>remove() -&gt; None</code>","text":"<p>Remove the sound from the clip.</p> Source code in <code>pytvpaint/sound.py</code> <pre><code>@set_as_current\ndef remove(self) -&gt; None:\n    \"\"\"Remove the sound from the clip.\"\"\"\n    george.tv_sound_clip_remove(self.track_index)\n    self.mark_removed()\n</code></pre>"},{"location":"api/objects/clip_sound/#pytvpaint.sound.ClipSound.reload","title":"<code>reload() -&gt; None</code>","text":"<p>Reload the sound from file.</p> Source code in <code>pytvpaint/sound.py</code> <pre><code>@set_as_current\ndef reload(self) -&gt; None:\n    \"\"\"Reload the sound from file.\"\"\"\n    george.tv_sound_clip_reload(self._parent.id, self.track_index)\n</code></pre>"},{"location":"api/objects/layer/","title":"Layer class","text":"<p>             Bases: <code>pytvpaint.utils.Removable</code></p> <p>A Layer is inside a clip and contains drawings.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def __init__(self, layer_id: int, clip: Clip | None = None) -&gt; None:\n    from pytvpaint.clip import Clip\n\n    super().__init__()\n    self._id = layer_id\n    self._clip = clip or Clip.current_clip()\n    self._data = george.tv_layer_info(self.id)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.id","title":"<code>id: int</code>  <code>property</code>","text":"<p>The layers unique identifier.</p> Warning <p>layer ids are not persistent across project load/close</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.project","title":"<code>project: Project</code>  <code>property</code>","text":"<p>The project containing this layer.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.scene","title":"<code>scene: Scene</code>  <code>property</code>","text":"<p>The scene containing this layer.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.clip","title":"<code>clip: Clip</code>  <code>property</code>","text":"<p>The clip containing this layer.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.position","title":"<code>position: int</code>  <code>property</code> <code>writable</code>","text":"<p>The position in the layer stack.</p> Note <p>layer positions start at 0</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.opacity","title":"<code>opacity: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the layer opacity value.</p> Note <p>In George, this is called density, we renamed it to <code>opacity</code> as it seems more appropriate</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.color","title":"<code>color: LayerColor</code>  <code>property</code> <code>writable</code>","text":"<p>Get the layer color.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.is_current","title":"<code>is_current: bool</code>  <code>property</code>","text":"<p>Returns True if the layer is the current one in the clip.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.is_selected","title":"<code>is_selected: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Returns True if the layer is selected.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.is_visible","title":"<code>is_visible: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Returns True if the layer is visible.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.is_locked","title":"<code>is_locked: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Returns True if the layer is locked.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.is_collapsed","title":"<code>is_collapsed: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Returns True if the layer is collapsed.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.blending_mode","title":"<code>blending_mode: george.BlendingMode</code>  <code>property</code> <code>writable</code>","text":"<p>Get the layer blending mode value.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.stencil","title":"<code>stencil: george.StencilMode</code>  <code>property</code> <code>writable</code>","text":"<p>Get the layer stencil mode value.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.thumbnails_visible","title":"<code>thumbnails_visible: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Returns True if thumbnails are shown on that layer.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.auto_break_instance","title":"<code>auto_break_instance: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Get the auto break instance value.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.auto_create_instance","title":"<code>auto_create_instance: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Get the auto create instance value.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.pre_behavior","title":"<code>pre_behavior: george.LayerBehavior</code>  <code>property</code> <code>writable</code>","text":"<p>Get the pre-behavior value.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.post_behavior","title":"<code>post_behavior: george.LayerBehavior</code>  <code>property</code> <code>writable</code>","text":"<p>Get the post-behavior value.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.is_position_locked","title":"<code>is_position_locked: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Returns True if the layer position is locked.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.preserve_transparency","title":"<code>preserve_transparency: george.LayerTransparency</code>  <code>property</code> <code>writable</code>","text":"<p>Get the preserve transparency value.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.is_anim_layer","title":"<code>is_anim_layer: bool</code>  <code>property</code>","text":"<p>Returns True if the layer is an animation layer.</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.marks","title":"<code>marks: Iterator[tuple[int, LayerColor]]</code>  <code>property</code>","text":"<p>Iterator over the layer marks including the frame and the color.</p> <p>Yields:</p> Name Type Description <code>frame</code> <code>int</code> <p>the mark frame</p> <code>color</code> <code>pytvpaint.layer.LayerColor</code> <p>the mark color</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.selected_frames","title":"<code>selected_frames: list[int]</code>  <code>property</code>","text":"<p>Get the list of selected frames.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>Array of selected frame numbers</p>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.refresh","title":"<code>refresh() -&gt; None</code>","text":"<p>Refreshes the layer data.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the layer data.\"\"\"\n    super().refresh()\n    if not self.refresh_on_call and self._data:\n        return\n    try:\n        self._data = george.tv_layer_info(self._id)\n    except GeorgeError:\n        self.mark_removed()\n        self.refresh()\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.name","title":"<code>name(value: str) -&gt; None</code>","text":"<p>Set the layer name.</p> Note <p>it uses <code>get_unique_name</code> to find a unique layer name across all the layers in the clip</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@name.setter\n@set_as_current\ndef name(self, value: str) -&gt; None:\n    \"\"\"Set the layer name.\n\n    Note:\n        it uses `get_unique_name` to find a unique layer name across all the layers in the clip\n    \"\"\"\n    if value == self.name:\n        return\n    value = utils.get_unique_name(self.clip.layer_names, value)\n    george.tv_layer_rename(self.id, value)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.layer_type","title":"<code>layer_type() -&gt; george.LayerType</code>","text":"<p>The layer type.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@refreshed_property\ndef layer_type(self) -&gt; george.LayerType:\n    \"\"\"The layer type.\"\"\"\n    return self._data.type\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.start","title":"<code>start() -&gt; int</code>","text":"<p>The layer start frame according to the project's start frame.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@refreshed_property\ndef start(self) -&gt; int:\n    \"\"\"The layer start frame according to the project's start frame.\"\"\"\n    return self._data.first_frame + self.project.start_frame\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.end","title":"<code>end() -&gt; int</code>","text":"<p>The layer end frame according to the project's start frame.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@refreshed_property\ndef end(self) -&gt; int:\n    \"\"\"The layer end frame according to the project's start frame.\"\"\"\n    return self._data.last_frame + self.project.start_frame\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.make_current","title":"<code>make_current() -&gt; None</code>","text":"<p>Make the layer current, it also makes the clip current.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def make_current(self) -&gt; None:\n    \"\"\"Make the layer current, it also makes the clip current.\"\"\"\n    if self.is_current:\n        return\n    if self.clip:\n        self.clip.make_current()\n    george.tv_layer_set(self.id)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.convert_to_anim_layer","title":"<code>convert_to_anim_layer() -&gt; None</code>","text":"<p>Converts the layer to an animation layer.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\ndef convert_to_anim_layer(self) -&gt; None:\n    \"\"\"Converts the layer to an animation layer.\"\"\"\n    george.tv_layer_anim(self.id)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.load_dependencies","title":"<code>load_dependencies() -&gt; None</code>","text":"<p>Load all dependencies of the layer in memory.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def load_dependencies(self) -&gt; None:\n    \"\"\"Load all dependencies of the layer in memory.\"\"\"\n    george.tv_layer_load_dependencies(self.id)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.current_layer_id","title":"<code>current_layer_id() -&gt; int</code>  <code>staticmethod</code>","text":"<p>Returns the current layer id.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@staticmethod\ndef current_layer_id() -&gt; int:\n    \"\"\"Returns the current layer id.\"\"\"\n    return george.tv_layer_current_id()\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.current_layer","title":"<code>current_layer() -&gt; Layer</code>  <code>classmethod</code>","text":"<p>Returns the current layer object.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@classmethod\ndef current_layer(cls) -&gt; Layer:\n    \"\"\"Returns the current layer object.\"\"\"\n    from pytvpaint.clip import Clip\n\n    return cls(layer_id=cls.current_layer_id(), clip=Clip.current_clip())\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.shift","title":"<code>shift(new_start: int) -&gt; None</code>","text":"<p>Move the layer to a new frame.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\ndef shift(self, new_start: int) -&gt; None:\n    \"\"\"Move the layer to a new frame.\"\"\"\n    george.tv_layer_shift(self.id, new_start - self.project.start_frame)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.merge","title":"<code>merge(layer: Layer, blending_mode: george.BlendingMode, stamp: bool = False, erase: bool = False, keep_color_grp: bool = True, keep_img_mark: bool = True, keep_instance_name: bool = True) -&gt; None</code>","text":"<p>Merge this layer with the given one.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>pytvpaint.layer.Layer</code> <p>the layer to merge with</p> required <code>blending_mode</code> <code>pytvpaint.george.BlendingMode</code> <p>the blending mode to use</p> required <code>stamp</code> <code>bool</code> <p>Use stamp mode</p> <code>False</code> <code>erase</code> <code>bool</code> <p>Remove the source layer</p> <code>False</code> <code>keep_color_grp</code> <code>bool</code> <p>Keep the color group</p> <code>True</code> <code>keep_img_mark</code> <code>bool</code> <p>Keep the image mark</p> <code>True</code> <code>keep_instance_name</code> <code>bool</code> <p>Keep the instance name</p> <code>True</code> Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\ndef merge(\n    self,\n    layer: Layer,\n    blending_mode: george.BlendingMode,\n    stamp: bool = False,\n    erase: bool = False,\n    keep_color_grp: bool = True,\n    keep_img_mark: bool = True,\n    keep_instance_name: bool = True,\n) -&gt; None:\n    \"\"\"Merge this layer with the given one.\n\n    Args:\n        layer: the layer to merge with\n        blending_mode: the blending mode to use\n        stamp: Use stamp mode\n        erase: Remove the source layer\n        keep_color_grp: Keep the color group\n        keep_img_mark: Keep the image mark\n        keep_instance_name: Keep the instance name\n    \"\"\"\n    george.tv_layer_merge(\n        layer.id,\n        blending_mode,\n        stamp,\n        erase,\n        keep_color_grp,\n        keep_img_mark,\n        keep_instance_name,\n    )\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.merge_all","title":"<code>merge_all(keep_color_grp: bool = True, keep_img_mark: bool = True, keep_instance_name: bool = True) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Merge all the layers in the stack.</p> <p>Parameters:</p> Name Type Description Default <code>keep_color_grp</code> <code>bool</code> <p>Keep the color group</p> <code>True</code> <code>keep_img_mark</code> <code>bool</code> <p>Keep the image mark</p> <code>True</code> <code>keep_instance_name</code> <code>bool</code> <p>Keep the instance name</p> <code>True</code> Source code in <code>pytvpaint/layer.py</code> <pre><code>@staticmethod\ndef merge_all(\n    keep_color_grp: bool = True,\n    keep_img_mark: bool = True,\n    keep_instance_name: bool = True,\n) -&gt; None:\n    \"\"\"Merge all the layers in the stack.\n\n    Args:\n        keep_color_grp: Keep the color group\n        keep_img_mark: Keep the image mark\n        keep_instance_name: Keep the instance name\n    \"\"\"\n    george.tv_layer_merge_all(keep_color_grp, keep_img_mark, keep_instance_name)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.new","title":"<code>new(name: str, clip: Clip | None = None, color: LayerColor | None = None) -&gt; Layer</code>  <code>staticmethod</code>","text":"<p>Create a new layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the new layer</p> required <code>clip</code> <code>pytvpaint.clip.Clip | None</code> <p>the parent clip</p> <code>None</code> <code>color</code> <code>pytvpaint.layer.LayerColor | None</code> <p>the layer color</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Layer</code> <code>pytvpaint.layer.Layer</code> <p>the new layer</p> Note <p>The layer name is checked against all other layers to have a unique name using <code>get_unique_name</code>. This can take a while if you have a lot of layers.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@staticmethod\n@george.undoable\ndef new(\n    name: str,\n    clip: Clip | None = None,\n    color: LayerColor | None = None,\n) -&gt; Layer:\n    \"\"\"Create a new layer.\n\n    Args:\n        name: the name of the new layer\n        clip: the parent clip\n        color: the layer color\n\n    Returns:\n        Layer: the new layer\n\n    Note:\n        The layer name is checked against all other layers to have a unique name using `get_unique_name`.\n        This can take a while if you have a lot of layers.\n    \"\"\"\n    from pytvpaint.clip import Clip\n\n    clip = clip or Clip.current_clip()\n    clip.make_current()\n\n    name = utils.get_unique_name(clip.layer_names, name)\n    layer_id = george.tv_layer_create(name)\n\n    layer = Layer(layer_id=layer_id, clip=clip)\n\n    if color:\n        layer.color = color\n\n    return layer\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.new_anim_layer","title":"<code>new_anim_layer(name: str, clip: Clip | None = None, color: LayerColor | None = None) -&gt; Layer</code>  <code>classmethod</code>","text":"<p>Create a new animation layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the new layer</p> required <code>clip</code> <code>pytvpaint.clip.Clip | None</code> <p>the parent clip</p> <code>None</code> <code>color</code> <code>pytvpaint.layer.LayerColor | None</code> <p>the layer color</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Layer</code> <code>pytvpaint.layer.Layer</code> <p>the new animation layer</p> Note <p>It activates the thumbnail visibility</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@classmethod\n@george.undoable\ndef new_anim_layer(\n    cls,\n    name: str,\n    clip: Clip | None = None,\n    color: LayerColor | None = None,\n) -&gt; Layer:\n    \"\"\"Create a new animation layer.\n\n    Args:\n        name: the name of the new layer\n        clip: the parent clip\n        color: the layer color\n\n    Returns:\n        Layer: the new animation layer\n\n    Note:\n        It activates the thumbnail visibility\n    \"\"\"\n    layer = cls.new(name, clip, color)\n    layer.convert_to_anim_layer()\n    layer.thumbnails_visible = True\n    return layer\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.new_background_layer","title":"<code>new_background_layer(name: str, clip: Clip | None = None, color: LayerColor | None = None, image: Path | str | None = None, stretch: bool = False) -&gt; Layer</code>  <code>classmethod</code>","text":"<p>Create a new background layer with hold as pre- and post-behavior.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the new layer</p> required <code>clip</code> <code>pytvpaint.clip.Clip | None</code> <p>the parent clip</p> <code>None</code> <code>color</code> <code>pytvpaint.layer.LayerColor | None</code> <p>the layer color</p> <code>None</code> <code>image</code> <code>pathlib.Path | str | None</code> <p>the background image to load</p> <code>None</code> <code>stretch</code> <code>bool</code> <p>whether to stretch the image to fit the view</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Layer</code> <code>pytvpaint.layer.Layer</code> <p>the new animation layer</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@classmethod\n@george.undoable\ndef new_background_layer(\n    cls,\n    name: str,\n    clip: Clip | None = None,\n    color: LayerColor | None = None,\n    image: Path | str | None = None,\n    stretch: bool = False,\n) -&gt; Layer:\n    \"\"\"Create a new background layer with hold as pre- and post-behavior.\n\n    Args:\n        name: the name of the new layer\n        clip: the parent clip\n        color: the layer color\n        image: the background image to load\n        stretch: whether to stretch the image to fit the view\n\n    Returns:\n        Layer: the new animation layer\n    \"\"\"\n    from pytvpaint.clip import Clip\n\n    clip = clip or Clip.current_clip()\n    layer = cls.new(name, clip, color)\n    layer.pre_behavior = george.LayerBehavior.HOLD\n    layer.post_behavior = george.LayerBehavior.HOLD\n    layer.thumbnails_visible = True\n\n    image = Path(image or \"\")\n    if image.is_file():\n        layer.convert_to_anim_layer()\n        layer.load_image(image, frame=clip.start, stretch=stretch)\n\n    return layer\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.duplicate","title":"<code>duplicate(name: str) -&gt; Layer</code>","text":"<p>Duplicate this layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the duplicated layer name</p> required <p>Returns:</p> Name Type Description <code>Layer</code> <code>pytvpaint.layer.Layer</code> <p>the duplicated layer</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\n@george.undoable\ndef duplicate(self, name: str) -&gt; Layer:\n    \"\"\"Duplicate this layer.\n\n    Args:\n        name: the duplicated layer name\n\n    Returns:\n        Layer: the duplicated layer\n    \"\"\"\n    name = utils.get_unique_name(self.clip.layer_names, name)\n    layer_id = george.tv_layer_duplicate(name)\n\n    return Layer(layer_id=layer_id, clip=self.clip)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.remove","title":"<code>remove() -&gt; None</code>","text":"<p>Remove the layer from the clip.</p> Warning <p>The current instance won't be usable after this call since it will be mark removed.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"Remove the layer from the clip.\n\n    Warning:\n        The current instance won't be usable after this call since it will be mark removed.\n    \"\"\"\n    self.clip.make_current()\n    self.is_locked = False\n    george.tv_layer_kill(self.id)\n    self.mark_removed()\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.render","title":"<code>render(output_path: Path | str | FileSequence, start: int | None = None, end: int | None = None, use_camera: bool = False, alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY, background_mode: george.BackgroundMode | None = None, format_opts: list[str] | None = None) -&gt; None</code>","text":"<p>Render the layer to a single frame or frame sequence or movie.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>pathlib.Path | str | fileseq.filesequence.FileSequence</code> <p>a single file or file sequence pattern</p> required <code>start</code> <code>int | None</code> <p>the start frame to render the layer's start if None. Defaults to None.</p> <code>None</code> <code>end</code> <code>int | None</code> <p>the end frame to render or the layer's end if None. Defaults to None.</p> <code>None</code> <code>use_camera</code> <code>bool</code> <p>use the camera for rendering, otherwise render the whole canvas. Defaults to False.</p> <code>False</code> <code>alpha_mode</code> <code>pytvpaint.george.AlphaSaveMode</code> <p>the alpha mode for rendering. Defaults to george.AlphaSaveMode.PREMULTIPLY.</p> <code>pytvpaint.george.AlphaSaveMode.PREMULTIPLY</code> <code>background_mode</code> <code>pytvpaint.george.BackgroundMode | None</code> <p>the background mode for rendering. Defaults to None.</p> <code>None</code> <code>format_opts</code> <code>list[str] | None</code> <p>custom format options. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if requested range (start-end) not in clip range/bounds</p> <code>ValueError</code> <p>if output is a movie</p> <code>FileNotFoundError</code> <p>if the render failed and no files were found on disk or missing frames</p> Note <p>This functions uses the layer's range as a basis (start-end). This  is different from a project range, which uses the project timeline. For more details on the differences in frame ranges and the timeline in TVPaint, please check the <code>Usage/Rendering</code> section of the documentation.</p> Warning <p>Even tough pytvpaint does a pretty good job of correcting the frame ranges for rendering, we're still encountering some weird edge cases where TVPaint will consider the range invalid for seemingly no reason.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\ndef render(\n    self,\n    output_path: Path | str | FileSequence,\n    start: int | None = None,\n    end: int | None = None,\n    use_camera: bool = False,\n    alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY,\n    background_mode: george.BackgroundMode | None = None,\n    format_opts: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Render the layer to a single frame or frame sequence or movie.\n\n    Args:\n        output_path: a single file or file sequence pattern\n        start: the start frame to render the layer's start if None. Defaults to None.\n        end: the end frame to render or the layer's end if None. Defaults to None.\n        use_camera: use the camera for rendering, otherwise render the whole canvas. Defaults to False.\n        alpha_mode: the alpha mode for rendering. Defaults to george.AlphaSaveMode.PREMULTIPLY.\n        background_mode: the background mode for rendering. Defaults to None.\n        format_opts: custom format options. Defaults to None.\n\n    Raises:\n        ValueError: if requested range (start-end) not in clip range/bounds\n        ValueError: if output is a movie\n        FileNotFoundError: if the render failed and no files were found on disk or missing frames\n\n    Note:\n        This functions uses the layer's range as a basis (start-end). This  is different from a project range, which\n        uses the project timeline. For more details on the differences in frame ranges and the timeline in TVPaint,\n        please check the `Usage/Rendering` section of the documentation.\n\n    Warning:\n        Even tough pytvpaint does a pretty good job of correcting the frame ranges for rendering, we're still\n        encountering some weird edge cases where TVPaint will consider the range invalid for seemingly no reason.\n    \"\"\"\n    start = self.start if start is None else start\n    end = self.end if end is None else end\n    self.clip.render(\n        output_path=output_path,\n        start=start,\n        end=end,\n        use_camera=use_camera,\n        layer_selection=[self],\n        alpha_mode=alpha_mode,\n        background_mode=background_mode,\n        format_opts=format_opts,\n    )\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.render_frame","title":"<code>render_frame(export_path: Path | str, frame: int | None = None, alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY, background_mode: george.BackgroundMode | None = george.BackgroundMode.NONE, format_opts: list[str] | None = None) -&gt; Path</code>","text":"<p>Render a frame from the layer.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>pathlib.Path | str</code> <p>the frame export path (the extension determines the output format)</p> required <code>frame</code> <code>int | None</code> <p>the frame to render or the current frame if None. Defaults to None.</p> <code>None</code> <code>alpha_mode</code> <code>pytvpaint.george.AlphaSaveMode</code> <p>the render alpha mode</p> <code>pytvpaint.george.AlphaSaveMode.PREMULTIPLY</code> <code>background_mode</code> <code>pytvpaint.george.BackgroundMode | None</code> <p>the render background mode</p> <code>pytvpaint.george.BackgroundMode.NONE</code> <code>format_opts</code> <code>list[str] | None</code> <p>custom output format options to pass when rendering</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the render failed or output not found on disk</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>pathlib.Path</code> <p>render output path</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\ndef render_frame(\n    self,\n    export_path: Path | str,\n    frame: int | None = None,\n    alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY,\n    background_mode: george.BackgroundMode | None = george.BackgroundMode.NONE,\n    format_opts: list[str] | None = None,\n) -&gt; Path:\n    \"\"\"Render a frame from the layer.\n\n    Args:\n        export_path: the frame export path (the extension determines the output format)\n        frame: the frame to render or the current frame if None. Defaults to None.\n        alpha_mode: the render alpha mode\n        background_mode: the render background mode\n        format_opts: custom output format options to pass when rendering\n\n    Raises:\n        FileNotFoundError: if the render failed or output not found on disk\n\n    Returns:\n        Path: render output path\n    \"\"\"\n    export_path = Path(export_path)\n    save_format = george.SaveFormat.from_extension(export_path.suffix)\n    export_path.parent.mkdir(parents=True, exist_ok=True)\n\n    frame = frame or self.clip.current_frame\n    self.clip.current_frame = frame\n\n    with utils.render_context(\n        alpha_mode,\n        background_mode,\n        save_format,\n        format_opts,\n        layer_selection=[self],\n    ):\n        george.tv_save_image(export_path)\n\n    if not export_path.exists():\n        raise FileNotFoundError(\n            f\"Could not find rendered image ({frame}) at : {export_path.as_posix()}\"\n        )\n\n    return export_path\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.render_instances","title":"<code>render_instances(export_path: Path | str | FileSequence, start: int | None = None, end: int | None = None, alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY, background_mode: george.BackgroundMode | None = None, format_opts: list[str] | None = None) -&gt; FileSequence</code>","text":"<p>Render all layer instances in the provided range for the current layer.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>pathlib.Path | str | fileseq.filesequence.FileSequence</code> <p>the export path (the extension determines the output format)</p> required <code>start</code> <code>int | None</code> <p>the start frame to render the layer's start if None. Defaults to None.</p> <code>None</code> <code>end</code> <code>int | None</code> <p>the end frame to render or the layer's end if None. Defaults to None.</p> <code>None</code> <code>alpha_mode</code> <code>pytvpaint.george.AlphaSaveMode</code> <p>the render alpha mode</p> <code>pytvpaint.george.AlphaSaveMode.PREMULTIPLY</code> <code>background_mode</code> <code>pytvpaint.george.BackgroundMode | None</code> <p>the render background mode</p> <code>None</code> <code>format_opts</code> <code>list[str] | None</code> <p>custom output format options to pass when rendering</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if requested range (start-end) not in layer range/bounds</p> <code>ValueError</code> <p>if output is a movie</p> <code>FileNotFoundError</code> <p>if the render failed or output not found on disk</p> <p>Returns:</p> Name Type Description <code>FileSequence</code> <code>fileseq.filesequence.FileSequence</code> <p>instances output sequence</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\ndef render_instances(\n    self,\n    export_path: Path | str | FileSequence,\n    start: int | None = None,\n    end: int | None = None,\n    alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY,\n    background_mode: george.BackgroundMode | None = None,\n    format_opts: list[str] | None = None,\n) -&gt; FileSequence:\n    \"\"\"Render all layer instances in the provided range for the current layer.\n\n    Args:\n        export_path: the export path (the extension determines the output format)\n        start: the start frame to render the layer's start if None. Defaults to None.\n        end: the end frame to render or the layer's end if None. Defaults to None.\n        alpha_mode: the render alpha mode\n        background_mode: the render background mode\n        format_opts: custom output format options to pass when rendering\n\n    Raises:\n        ValueError: if requested range (start-end) not in layer range/bounds\n        ValueError: if output is a movie\n        FileNotFoundError: if the render failed or output not found on disk\n\n    Returns:\n        FileSequence: instances output sequence\n    \"\"\"\n    file_sequence, start, end, is_sequence, is_image = utils.handle_output_range(\n        export_path, self.start, self.end, start, end\n    )\n\n    if start &lt; self.start or end &gt; self.end:\n        raise ValueError(\n            f\"Render ({start}-{end}) not in clip range ({(self.start, self.end)})\"\n        )\n    if not is_image:\n        raise ValueError(\n            f\"Video formats ({file_sequence.extension()}) are not supported for instance rendering !\"\n        )\n\n    # render to output\n    frames = []\n    for layer_instance in self.instances:\n        cur_frame = layer_instance.start\n        instance_output = Path(file_sequence.frame(cur_frame))\n        self.render_frame(\n            instance_output, cur_frame, alpha_mode, background_mode, format_opts\n        )\n        frames.append(str(cur_frame))\n\n    file_sequence.setFrameSet(FrameSet(\",\".join(frames)))\n    return file_sequence\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.load_image","title":"<code>load_image(image_path: str | Path, frame: int | None = None, stretch: bool = False) -&gt; None</code>","text":"<p>Load an image in the current layer at a given frame.</p> <p>Parameters:</p> Name Type Description Default <code>image_path</code> <code>str | pathlib.Path</code> <p>path to the image to load</p> required <code>frame</code> <code>int | None</code> <p>the frame where the image will be loaded, if none provided, image will be loaded at current frame</p> <code>None</code> <code>stretch</code> <code>bool</code> <p>whether to stretch the image to fit the view</p> <code>False</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the file doesn't exist at provided path</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\ndef load_image(\n    self, image_path: str | Path, frame: int | None = None, stretch: bool = False\n) -&gt; None:\n    \"\"\"Load an image in the current layer at a given frame.\n\n    Args:\n        image_path: path to the image to load\n        frame: the frame where the image will be loaded, if none provided, image will be loaded at current frame\n        stretch: whether to stretch the image to fit the view\n\n    Raises:\n        FileNotFoundError: if the file doesn't exist at provided path\n    \"\"\"\n    image_path = Path(image_path)\n    if not image_path.exists():\n        raise FileNotFoundError(f\"Image not found at : {image_path}\")\n\n    frame = frame or self.clip.current_frame\n    with utils.restore_current_frame(self.clip, frame):\n        # if no instance at the specified frame, then create a new one\n        if not self.get_instance(frame):\n            self.add_instance(frame)\n\n        george.tv_load_image(image_path.as_posix(), stretch)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.get_mark_color","title":"<code>get_mark_color(frame: int) -&gt; LayerColor | None</code>","text":"<p>Get the mark color at a specific frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>frame with a mark</p> required <p>Returns:</p> Type Description <code>pytvpaint.layer.LayerColor | None</code> <p>LayerColor | None: the layer color if there was a mark</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def get_mark_color(self, frame: int) -&gt; LayerColor | None:\n    \"\"\"Get the mark color at a specific frame.\n\n    Args:\n        frame: frame with a mark\n\n    Returns:\n        LayerColor | None: the layer color if there was a mark\n    \"\"\"\n    frame = frame - self.project.start_frame\n    color_index = george.tv_layer_mark_get(self.id, frame)\n    if not color_index:\n        return None\n\n    return self.clip.get_layer_color(by_index=color_index)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.add_mark","title":"<code>add_mark(frame: int, color: LayerColor) -&gt; None</code>","text":"<p>Add a mark to a frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>frame to put a mark on</p> required <code>color</code> <code>pytvpaint.layer.LayerColor</code> <p>the color index</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if the layer is not an animation layer</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def add_mark(self, frame: int, color: LayerColor) -&gt; None:\n    \"\"\"Add a mark to a frame.\n\n    Args:\n        frame: frame to put a mark on\n        color: the color index\n\n    Raises:\n        TypeError: if the layer is not an animation layer\n    \"\"\"\n    if not self.is_anim_layer:\n        raise TypeError(\n            f\"Can't add a mark because this is not an animation layer ({self})\"\n        )\n    frame = frame - self.project.start_frame\n    george.tv_layer_mark_set(self.id, frame, color.index)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.remove_mark","title":"<code>remove_mark(frame: int) -&gt; None</code>","text":"<p>Remove a mark.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>a frame number with a mark</p> required Source code in <code>pytvpaint/layer.py</code> <pre><code>def remove_mark(self, frame: int) -&gt; None:\n    \"\"\"Remove a mark.\n\n    Args:\n        frame: a frame number with a mark\n    \"\"\"\n    # Setting it at 0 clears the mark\n    self.add_mark(frame, LayerColor(0, self.clip))\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.clear_marks","title":"<code>clear_marks() -&gt; None</code>","text":"<p>Clear all the marks in the layer.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def clear_marks(self) -&gt; None:\n    \"\"\"Clear all the marks in the layer.\"\"\"\n    for frame, _ in self.marks:\n        self.remove_mark(frame)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.select_frames","title":"<code>select_frames(start: int, end: int) -&gt; None</code>","text":"<p>Select the frames from a start and count.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>the selection start frame</p> required <code>end</code> <code>int</code> <p>the selected end frame</p> required Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\ndef select_frames(self, start: int, end: int) -&gt; None:\n    \"\"\"Select the frames from a start and count.\n\n    Args:\n        start: the selection start frame\n        end: the selected end frame\n    \"\"\"\n    if not self.is_anim_layer:\n        log.warning(\n            \"Selection may display weird behaviour when applied to a non animation layer\"\n        )\n    frame_count = (end - start) + 1\n    george.tv_layer_select(start - self.clip.start, frame_count)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.select_all_frames","title":"<code>select_all_frames() -&gt; None</code>","text":"<p>Select all frames in the layer.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\ndef select_all_frames(self) -&gt; None:\n    \"\"\"Select all frames in the layer.\"\"\"\n    frame, frame_count = george.tv_layer_select_info(full=True)\n    george.tv_layer_select(frame, frame_count)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.clear_selection","title":"<code>clear_selection() -&gt; None</code>","text":"<p>Clear frame selection in the layer.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\ndef clear_selection(self) -&gt; None:\n    \"\"\"Clear frame selection in the layer.\"\"\"\n    # selecting frames after the layer's end frame will result in a empty selection, thereby clearing the selection\n    george.tv_layer_select(self.end + 1, 0)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.cut_selection","title":"<code>cut_selection() -&gt; None</code>","text":"<p>Cut the selected instances.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\ndef cut_selection(self) -&gt; None:\n    \"\"\"Cut the selected instances.\"\"\"\n    george.tv_layer_cut()\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.copy_selection","title":"<code>copy_selection() -&gt; None</code>","text":"<p>Copy the selected instances.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\ndef copy_selection(self) -&gt; None:\n    \"\"\"Copy the selected instances.\"\"\"\n    george.tv_layer_copy()\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.paste_selection","title":"<code>paste_selection() -&gt; None</code>","text":"<p>Paste the previously copied instances.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@set_as_current\ndef paste_selection(self) -&gt; None:\n    \"\"\"Paste the previously copied instances.\"\"\"\n    george.tv_layer_paste()\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.instances","title":"<code>instances() -&gt; Iterator[LayerInstance]</code>","text":"<p>Iterates over the layer instances.</p> <p>Yields:</p> Type Description <code>pytvpaint.layer.LayerInstance</code> <p>each LayerInstance present in the layer</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@refreshed_property\n@set_as_current\ndef instances(self) -&gt; Iterator[LayerInstance]:\n    \"\"\"Iterates over the layer instances.\n\n    Yields:\n        each LayerInstance present in the layer\n    \"\"\"\n    # instances start at layer start\n    current_instance = LayerInstance(self, self.start)\n\n    while True:\n        yield current_instance\n\n        nex_instance = current_instance.next\n        if nex_instance is None:\n            break\n\n        current_instance = nex_instance\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.get_instance","title":"<code>get_instance(frame: int, strict: bool = False) -&gt; LayerInstance | None</code>","text":"<p>Get the instance at that frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>the instance frame</p> required <code>strict</code> <code>bool</code> <p>True will only return Instance if the given frame is the start of the instance. Default is False</p> <code>False</code> <p>Returns:</p> Type Description <code>pytvpaint.layer.LayerInstance | None</code> <p>the instance if found else None</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def get_instance(self, frame: int, strict: bool = False) -&gt; LayerInstance | None:\n    \"\"\"Get the instance at that frame.\n\n    Args:\n        frame: the instance frame\n        strict: True will only return Instance if the given frame is the start of the instance. Default is False\n\n    Returns:\n        the instance if found else None\n    \"\"\"\n    for layer_instance in self.instances:\n        if strict:\n            if layer_instance.start != frame:\n                continue\n            return layer_instance\n\n        if not (layer_instance.start &lt;= frame &lt;= layer_instance.end):\n            continue\n        return layer_instance\n\n    return None\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.get_instances","title":"<code>get_instances(from_frame: int, to_frame: int) -&gt; Iterator[LayerInstance]</code>","text":"<p>Iterates over the layer instances and returns the one in the range (from_frame-to_frame).</p> <p>Yields:</p> Type Description <code>pytvpaint.layer.LayerInstance</code> <p>each LayerInstance in the range (from_frame-to_frame)</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def get_instances(self, from_frame: int, to_frame: int) -&gt; Iterator[LayerInstance]:\n    \"\"\"Iterates over the layer instances and returns the one in the range (from_frame-to_frame).\n\n    Yields:\n        each LayerInstance in the range (from_frame-to_frame)\n    \"\"\"\n    for layer_instance in self.instances:\n        if layer_instance.end &lt; from_frame:\n            continue\n        if from_frame &lt;= layer_instance.start &lt;= to_frame:\n            yield layer_instance\n        if layer_instance.start &gt; to_frame:\n            break\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.add_instance","title":"<code>add_instance(start: int | None = None, nb_frames: int = 1, direction: george.InsertDirection | None = None, split: bool = False) -&gt; LayerInstance</code>","text":"<p>Crates a new instance.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int | None</code> <p>start frame. Defaults to clip current frame if none provided</p> <code>None</code> <code>nb_frames</code> <code>int</code> <p>number of frames in the new instance. Default is 1, this is the total number of frames created.</p> <code>1</code> <code>direction</code> <code>pytvpaint.george.InsertDirection | None</code> <p>direction where new frames will be added/inserted</p> <code>None</code> <code>split</code> <code>bool</code> <p>True to make each added frame a new image</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if the layer is not an animation layer</p> <code>ValueError</code> <p>if the number of frames <code>nb_frames</code> is inferior or equal to 0</p> <code>ValueError</code> <p>if an instance already exists at the given range (start + nb_frames)</p> <p>Returns:</p> Name Type Description <code>LayerInstance</code> <code>pytvpaint.layer.LayerInstance</code> <p>new layer instance</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def add_instance(\n    self,\n    start: int | None = None,\n    nb_frames: int = 1,\n    direction: george.InsertDirection | None = None,\n    split: bool = False,\n) -&gt; LayerInstance:\n    \"\"\"Crates a new instance.\n\n    Args:\n        start: start frame. Defaults to clip current frame if none provided\n        nb_frames: number of frames in the new instance. Default is 1, this is the total number of frames created.\n        direction: direction where new frames will be added/inserted\n        split: True to make each added frame a new image\n\n    Raises:\n        TypeError: if the layer is not an animation layer\n        ValueError: if the number of frames `nb_frames` is inferior or equal to 0\n        ValueError: if an instance already exists at the given range (start + nb_frames)\n\n    Returns:\n        LayerInstance: new layer instance\n    \"\"\"\n    if not self.is_anim_layer:\n        raise TypeError(\"The layer needs to be an animation layer\")\n\n    if nb_frames &lt;= 0:\n        raise ValueError(\"Instance number of frames must be at least 1\")\n\n    if start and self.get_instance(start):\n        raise ValueError(\n            \"An instance already exists at the designated frame range. \"\n            \"Edit or delete it before adding a new one.\"\n        )\n\n    start = start if start is not None else self.clip.current_frame\n    self.clip.make_current()\n\n    temp_layer = Layer.new_anim_layer(str(uuid4()))\n    temp_layer.make_current()\n\n    with utils.restore_current_frame(self.clip, 1):\n        if nb_frames &gt; 1:\n            if split:\n                george.tv_layer_insert_image(count=nb_frames, direction=direction)\n            else:\n                layer_instance = next(temp_layer.instances)\n                layer_instance.length = nb_frames\n\n        temp_layer.select_all_frames()\n        temp_layer.copy_selection()\n        self.clip.current_frame = start\n        self.make_current()\n        self.paste_selection()\n        temp_layer.remove()\n\n    return LayerInstance(self, start)\n</code></pre>"},{"location":"api/objects/layer/#pytvpaint.layer.Layer.rename_instances","title":"<code>rename_instances(mode: george.InstanceNamingMode, prefix: str | None = None, suffix: str | None = None, process: george.InstanceNamingProcess | None = None) -&gt; None</code>","text":"<p>Rename all the instances.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>pytvpaint.george.InstanceNamingMode</code> <p>the instance renaming mode</p> required <code>prefix</code> <code>str | None</code> <p>the prefix to add to each name</p> <code>None</code> <code>suffix</code> <code>str | None</code> <p>the suffix to add to each name</p> <code>None</code> <code>process</code> <code>pytvpaint.george.InstanceNamingProcess | None</code> <p>the instance naming process</p> <code>None</code> Source code in <code>pytvpaint/layer.py</code> <pre><code>def rename_instances(\n    self,\n    mode: george.InstanceNamingMode,\n    prefix: str | None = None,\n    suffix: str | None = None,\n    process: george.InstanceNamingProcess | None = None,\n) -&gt; None:\n    \"\"\"Rename all the instances.\n\n    Args:\n        mode: the instance renaming mode\n        prefix: the prefix to add to each name\n        suffix: the suffix to add to each name\n        process: the instance naming process\n    \"\"\"\n    george.tv_instance_name(self.id, mode, prefix, suffix, process)\n</code></pre>"},{"location":"api/objects/layer_color/","title":"LayerColor class","text":"<p>             Bases: <code>pytvpaint.utils.Refreshable</code></p> <p>The color of a layer identified by an index. Layer colors are specific to a clip.</p> <p>Construct a LayerColor from an index and a clip (if None it gets the current clip).</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def __init__(\n    self,\n    color_index: int,\n    clip: Clip | None = None,\n) -&gt; None:\n    \"\"\"Construct a LayerColor from an index and a clip (if None it gets the current clip).\"\"\"\n    from pytvpaint.clip import Clip\n\n    super().__init__()\n    self._index = color_index\n    self._clip = clip or Clip.current_clip()\n    self._data = george.tv_layer_color_get_color(self.clip.id, self._index)\n</code></pre>"},{"location":"api/objects/layer_color/#pytvpaint.layer.LayerColor.index","title":"<code>index: int</code>  <code>property</code>","text":"<p>The layer color index.</p>"},{"location":"api/objects/layer_color/#pytvpaint.layer.LayerColor.clip","title":"<code>clip: Clip</code>  <code>property</code>","text":"<p>The layer color clip.</p>"},{"location":"api/objects/layer_color/#pytvpaint.layer.LayerColor.is_visible","title":"<code>is_visible: bool</code>  <code>property</code>","text":"<p>Get the visibility of the color index.</p>"},{"location":"api/objects/layer_color/#pytvpaint.layer.LayerColor.refresh","title":"<code>refresh() -&gt; None</code>","text":"<p>Refreshes the layer color data.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the layer color data.\"\"\"\n    if not self.refresh_on_call and self._data:\n        return\n    self._data = george.tv_layer_color_get_color(self._clip.id, self._index)\n</code></pre>"},{"location":"api/objects/layer_color/#pytvpaint.layer.LayerColor.name","title":"<code>name(value: str) -&gt; None</code>","text":"<p>Set the name of the color.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@name.setter\ndef name(self, value: str) -&gt; None:\n    \"\"\"Set the name of the color.\"\"\"\n    clip_layer_color_names = (color.name for color in self.clip.layer_colors)\n    value = utils.get_unique_name(clip_layer_color_names, value)\n    george.tv_layer_color_set_color(self.clip.id, self.index, self.color, value)\n</code></pre>"},{"location":"api/objects/layer_color/#pytvpaint.layer.LayerColor.color","title":"<code>color(value: george.RGBColor) -&gt; None</code>","text":"<p>Set the color value.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>@color.setter\ndef color(self, value: george.RGBColor) -&gt; None:\n    \"\"\"Set the color value.\"\"\"\n    george.tv_layer_color_set_color(self.clip.id, self.index, value)\n</code></pre>"},{"location":"api/objects/layer_color/#pytvpaint.layer.LayerColor.lock_layers","title":"<code>lock_layers(lock: bool) -&gt; None</code>","text":"<p>Lock or unlock all layers with this color.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def lock_layers(self, lock: bool) -&gt; None:\n    \"\"\"Lock or unlock all layers with this color.\"\"\"\n    self.clip.make_current()\n    if lock:\n        george.tv_layer_color_lock(self.index)\n    else:\n        george.tv_layer_color_unlock(self.index)\n</code></pre>"},{"location":"api/objects/layer_color/#pytvpaint.layer.LayerColor.show_layers","title":"<code>show_layers(show: bool, mode: george.LayerColorDisplayOpt = george.LayerColorDisplayOpt.DISPLAY) -&gt; None</code>","text":"<p>Show or hide layers with this color.</p> <p>Parameters:</p> Name Type Description Default <code>show</code> <code>bool</code> <p>whether to show the layers using this color or not</p> required <code>mode</code> <code>pytvpaint.george.LayerColorDisplayOpt</code> <p>the display mode. Defaults to george.LayerColorDisplayOpt.DISPLAY.</p> <code>pytvpaint.george.LayerColorDisplayOpt.DISPLAY</code> Source code in <code>pytvpaint/layer.py</code> <pre><code>def show_layers(\n    self,\n    show: bool,\n    mode: george.LayerColorDisplayOpt = george.LayerColorDisplayOpt.DISPLAY,\n) -&gt; None:\n    \"\"\"Show or hide layers with this color.\n\n    Args:\n        show: whether to show the layers using this color or not\n        mode: the display mode. Defaults to george.LayerColorDisplayOpt.DISPLAY.\n    \"\"\"\n    self.clip.make_current()\n    if show:\n        george.tv_layer_color_show(mode, self.index)\n    else:\n        george.tv_layer_color_hide(mode, self.index)\n</code></pre>"},{"location":"api/objects/layer_color/#pytvpaint.layer.LayerColor.select_layers","title":"<code>select_layers(select: bool) -&gt; None</code>","text":"<p>Select or unselect layers with this color.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def select_layers(self, select: bool) -&gt; None:\n    \"\"\"Select or unselect layers with this color.\"\"\"\n    self.clip.make_current()\n    if select:\n        george.tv_layer_color_select(self.index)\n    else:\n        george.tv_layer_color_unselect(self.index)\n</code></pre>"},{"location":"api/objects/layer_instance/","title":"LayerInstance class","text":"<p>A layer instance is a frame where there is a drawing. It only has a start frame.</p> Note <p><code>LayerInstance</code> is special because we can't track their position, meaning that if the user move an instance the Python object values won't match.</p>"},{"location":"api/objects/layer_instance/#pytvpaint.layer.LayerInstance.name","title":"<code>name: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the instance name.</p>"},{"location":"api/objects/layer_instance/#pytvpaint.layer.LayerInstance.length","title":"<code>length: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the instance's number of frames or length.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length provided is inferior to 1</p>"},{"location":"api/objects/layer_instance/#pytvpaint.layer.LayerInstance.end","title":"<code>end: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the instance's end frame.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the end frame provided is inferior to the instance's start frame</p>"},{"location":"api/objects/layer_instance/#pytvpaint.layer.LayerInstance.next","title":"<code>next: LayerInstance | None</code>  <code>property</code>","text":"<p>Returns the next instance.</p> <p>Returns:</p> Type Description <code>pytvpaint.layer.LayerInstance | None</code> <p>the next instance or None if at the end of the layer</p>"},{"location":"api/objects/layer_instance/#pytvpaint.layer.LayerInstance.previous","title":"<code>previous: LayerInstance | None</code>  <code>property</code>","text":"<p>Get the previous instance.</p> <p>Returns:</p> Type Description <code>pytvpaint.layer.LayerInstance | None</code> <p>the previous instance, None if there isn't</p>"},{"location":"api/objects/layer_instance/#pytvpaint.layer.LayerInstance.split","title":"<code>split(at_frame: int) -&gt; LayerInstance</code>","text":"<p>Split the instance into two instances at the given frame.</p> <p>Parameters:</p> Name Type Description Default <code>at_frame</code> <code>int</code> <p>the frame where the split will occur</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>at_frame</code> is superior to the instance's end frame</p> <p>Returns:</p> Name Type Description <code>LayerInstance</code> <code>pytvpaint.layer.LayerInstance</code> <p>the new layer instance</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def split(self, at_frame: int) -&gt; LayerInstance:\n    \"\"\"Split the instance into two instances at the given frame.\n\n    Args:\n        at_frame: the frame where the split will occur\n\n    Raises:\n        ValueError: If `at_frame` is superior to the instance's end frame\n\n    Returns:\n        LayerInstance: the new layer instance\n    \"\"\"\n    if at_frame &gt; self.end:\n        raise ValueError(\n            f\"`at_frame` must be in range of the instance's start-end ({self.start}-{self.end})\"\n        )\n\n    self.layer.make_current()\n    real_frame = at_frame - self.layer.project.start_frame\n    george.tv_exposure_break(real_frame)\n\n    return LayerInstance(self.layer, at_frame)\n</code></pre>"},{"location":"api/objects/layer_instance/#pytvpaint.layer.LayerInstance.duplicate","title":"<code>duplicate(direction: george.InsertDirection = george.InsertDirection.AFTER) -&gt; None</code>","text":"<p>Duplicate the instance and insert it in the given direction.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def duplicate(\n    self, direction: george.InsertDirection = george.InsertDirection.AFTER\n) -&gt; None:\n    \"\"\"Duplicate the instance and insert it in the given direction.\"\"\"\n    self.layer.make_current()\n\n    # tvp won't insert images if the insert frame is the same as the instance start, let's move it\n    move_frame = self.layer.clip.current_frame\n    if move_frame == self.start and self.layer.start != self.start:\n        move_frame = self.layer.start\n    else:\n        move_frame = self.layer.end + 1\n\n    with utils.restore_current_frame(self.layer.clip, move_frame):\n        self.copy()\n        at_frame = (\n            self.end if direction == george.InsertDirection.AFTER else self.start\n        )\n        self.paste(at_frame=at_frame)\n</code></pre>"},{"location":"api/objects/layer_instance/#pytvpaint.layer.LayerInstance.cut","title":"<code>cut() -&gt; None</code>","text":"<p>Cut all the frames/images/exposures of the instance and store them in the image buffer.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def cut(self) -&gt; None:\n    \"\"\"Cut all the frames/images/exposures of the instance and store them in the image buffer.\"\"\"\n    self.layer.make_current()\n    self.select()\n    self.layer.cut_selection()\n</code></pre>"},{"location":"api/objects/layer_instance/#pytvpaint.layer.LayerInstance.copy","title":"<code>copy() -&gt; None</code>","text":"<p>Copy all the frames/images/exposures of the instance and store them in the image buffer.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def copy(self) -&gt; None:\n    \"\"\"Copy all the frames/images/exposures of the instance and store them in the image buffer.\"\"\"\n    self.layer.make_current()\n    self.select()\n    self.layer.copy_selection()\n</code></pre>"},{"location":"api/objects/layer_instance/#pytvpaint.layer.LayerInstance.paste","title":"<code>paste(at_frame: int | None) -&gt; None</code>","text":"<p>Paste all the frames/images/exposures stored in the image buffer to the current instance at the given frame.</p> <p>Parameters:</p> Name Type Description Default <code>at_frame</code> <code>int | None</code> <p>the frame where the stored frames will be pasted. Default is the current frame</p> required Source code in <code>pytvpaint/layer.py</code> <pre><code>def paste(self, at_frame: int | None) -&gt; None:\n    \"\"\"Paste all the frames/images/exposures stored in the image buffer to the current instance at the given frame.\n\n    Args:\n        at_frame: the frame where the stored frames will be pasted. Default is the current frame\n    \"\"\"\n    at_frame = at_frame if at_frame is not None else self.layer.clip.current_frame\n\n    self.layer.make_current()\n    with utils.restore_current_frame(self.layer.clip, at_frame):\n        self.layer.paste_selection()\n</code></pre>"},{"location":"api/objects/layer_instance/#pytvpaint.layer.LayerInstance.select","title":"<code>select() -&gt; None</code>","text":"<p>Select all frames in this instance.</p> Source code in <code>pytvpaint/layer.py</code> <pre><code>def select(self) -&gt; None:\n    \"\"\"Select all frames in this instance.\"\"\"\n    self.layer.select_frames(self.start, (self.length - 1))\n</code></pre>"},{"location":"api/objects/project/","title":"Project class","text":"<p>Project class.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project","title":"<code>Project(project_id: str)</code>","text":"<p>             Bases: <code>pytvpaint.utils.Refreshable</code>, <code>pytvpaint.utils.Renderable</code></p> <p>A TVPaint project is the highest object that contains everything in the data hierarchy.</p> <p>It looks like this: Project -&gt; Scene -&gt; Clip -&gt; Layer -&gt; LayerInstance</p> Source code in <code>pytvpaint/project.py</code> <pre><code>def __init__(self, project_id: str) -&gt; None:\n    super().__init__()\n    self._id = project_id\n    self._is_closed = False\n    self._data = george.tv_project_info(self._id)\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.id","title":"<code>id: str</code>  <code>property</code>","text":"<p>The project id.</p> Note <p>the id is persistent on project load/close.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.position","title":"<code>position: int</code>  <code>property</code>","text":"<p>The project's position in the project tabs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if project cannot be found in open projects</p> Note <p>the indices go from right to left in the UI</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.is_closed","title":"<code>is_closed: bool</code>  <code>property</code>","text":"<p>Returns <code>True</code> if the project is closed.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.exists","title":"<code>exists: bool</code>  <code>property</code>","text":"<p>Checks if the project exists on disk.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.is_current","title":"<code>is_current: bool</code>  <code>property</code>","text":"<p>Returns <code>True</code> if the project is the current selected one in the UI.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The name of the project which is the filename without the extension.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.width","title":"<code>width: int</code>  <code>property</code>","text":"<p>The width of the canvas.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.height","title":"<code>height: int</code>  <code>property</code>","text":"<p>The height of the canvas.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.fps","title":"<code>fps: float</code>  <code>property</code>","text":"<p>The project's framerate.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.playback_fps","title":"<code>playback_fps: float</code>  <code>property</code>","text":"<p>The project's playback framerate.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.field_order","title":"<code>field_order: george.FieldOrder</code>  <code>property</code>","text":"<p>The field order.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.start_frame","title":"<code>start_frame: int</code>  <code>property</code> <code>writable</code>","text":"<p>The project's start frame.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.end_frame","title":"<code>end_frame: int</code>  <code>property</code>","text":"<p>The project's end frame, meaning the last frame of the last clip in the project's timeline.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.current_frame","title":"<code>current_frame: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current frame relative to the timeline.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.background_mode","title":"<code>background_mode: george.BackgroundMode</code>  <code>property</code> <code>writable</code>","text":"<p>Get/Set the background mode.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.background_colors","title":"<code>background_colors: tuple[george.RGBColor, george.RGBColor] | george.RGBColor | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get/Set the background color(s).</p> <p>Returns:</p> Type Description <code>tuple[pytvpaint.george.RGBColor, pytvpaint.george.RGBColor] | pytvpaint.george.RGBColor | None</code> <p>a tuple of two colors if checker, a single color if solid or None if empty</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.header_info","title":"<code>header_info: str</code>  <code>property</code> <code>writable</code>","text":"<p>The project's header info.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.author","title":"<code>author: str</code>  <code>property</code> <code>writable</code>","text":"<p>The project's author info.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.notes","title":"<code>notes: str</code>  <code>property</code> <code>writable</code>","text":"<p>The project's notes text.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.current_scene","title":"<code>current_scene: Scene</code>  <code>property</code>","text":"<p>Get the current scene of the project.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if scene cannot be found in project</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.scenes","title":"<code>scenes: Iterator[Scene]</code>  <code>property</code>","text":"<p>Yields the project's scenes.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.current_clip","title":"<code>current_clip: Clip</code>  <code>property</code>","text":"<p>Returns the project's current clip.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.clips","title":"<code>clips: Iterator[Clip]</code>  <code>property</code>","text":"<p>Iterates over all the clips in the project's scenes.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.clip_names","title":"<code>clip_names: Iterator[str]</code>  <code>property</code>","text":"<p>Optimized way to get the clip names. Useful for <code>get_unique_name</code>.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.sounds","title":"<code>sounds: Iterator[ProjectSound]</code>  <code>property</code>","text":"<p>Iterator over the project sounds.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.mark_in","title":"<code>mark_in: int | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get the project mark in or None if no mark in set.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.mark_out","title":"<code>mark_out: int | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get the project mark out or None if no mark out set.</p>"},{"location":"api/objects/project/#pytvpaint.project.Project.refresh","title":"<code>refresh() -&gt; None</code>","text":"<p>Refreshed the project data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if project has been closed</p> Source code in <code>pytvpaint/project.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshed the project data.\n\n    Raises:\n        ValueError: if project has been closed\n    \"\"\"\n    if self._is_closed:\n        msg = \"Project already closed, load the project again to get data\"\n        raise ValueError(msg)\n    if not self.refresh_on_call and self._data:\n        return\n\n    self._data = george.tv_project_info(self._id)\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.make_current","title":"<code>make_current() -&gt; None</code>","text":"<p>Make the project the current one.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>def make_current(self) -&gt; None:\n    \"\"\"Make the project the current one.\"\"\"\n    if self.is_current:\n        return\n    george.tv_project_select(self.id)\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.path","title":"<code>path() -&gt; Path</code>","text":"<p>The project path on disk.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@refreshed_property\ndef path(self) -&gt; Path:\n    \"\"\"The project path on disk.\"\"\"\n    return self._data.path\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.resize","title":"<code>resize(width: int, height: int, overwrite: bool = False, resize_opt: george.ResizeOption | None = None) -&gt; Project</code>","text":"<p>Resize the current project and returns a new one.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>the new width</p> required <code>height</code> <code>int</code> <p>the new height</p> required <code>overwrite</code> <code>bool</code> <p>overwrite the original project, default is to create a new project</p> <code>False</code> <code>resize_opt</code> <code>pytvpaint.george.ResizeOption | None</code> <p>how to resize the project</p> <code>None</code> <p>Returns:</p> Type Description <code>pytvpaint.project.Project</code> <p>the newly resized project</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@set_as_current\ndef resize(\n    self,\n    width: int,\n    height: int,\n    overwrite: bool = False,\n    resize_opt: george.ResizeOption | None = None,\n) -&gt; Project:\n    \"\"\"Resize the current project and returns a new one.\n\n    Args:\n        width: the new width\n        height: the new height\n        overwrite: overwrite the original project, default is to create a new project\n        resize_opt: how to resize the project\n\n    Returns:\n        the newly resized project\n    \"\"\"\n    if (width, height) == (self.width, self.height):\n        return self\n\n    origin_position = self.position\n    origin_path = self.path\n\n    if resize_opt:\n        george.tv_resize_page(width, height, resize_opt)\n    else:\n        george.tv_resize_project(width, height)\n\n    # The resized project is at the same position and replaced the original one\n    resized_id = george.tv_project_enum_id(origin_position)\n    resized_project = Project(resized_id)\n\n    if overwrite:\n        resized_project.save(origin_path)\n\n    return resized_project\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.set_fps","title":"<code>set_fps(fps: float, time_stretch: bool = False, preview: bool = False) -&gt; None</code>","text":"<p>Set the project's framerate.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@set_as_current\ndef set_fps(\n    self,\n    fps: float,\n    time_stretch: bool = False,\n    preview: bool = False,\n) -&gt; None:\n    \"\"\"Set the project's framerate.\"\"\"\n    george.tv_frame_rate_set(fps, time_stretch, preview)\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.pixel_aspect_ratio","title":"<code>pixel_aspect_ratio() -&gt; float</code>","text":"<p>The project's pixel aspect ratio.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@refreshed_property\n@set_as_current\ndef pixel_aspect_ratio(self) -&gt; float:\n    \"\"\"The project's pixel aspect ratio.\"\"\"\n    return self._data.pixel_aspect_ratio\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.clear_background","title":"<code>clear_background() -&gt; None</code>","text":"<p>Clear the background color and set it to None.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@set_as_current\ndef clear_background(self) -&gt; None:\n    \"\"\"Clear the background color and set it to None.\"\"\"\n    self.background_mode = george.BackgroundMode.NONE\n    self.background_colors = (\n        george.RGBColor(255, 255, 255),\n        george.RGBColor(0, 0, 0),\n    )\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.get_project","title":"<code>get_project(by_id: str | None = None, by_name: str | None = None) -&gt; Project | None</code>  <code>classmethod</code>","text":"<p>Find a project by id or by name.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@classmethod\ndef get_project(\n    cls,\n    by_id: str | None = None,\n    by_name: str | None = None,\n) -&gt; Project | None:\n    \"\"\"Find a project by id or by name.\"\"\"\n    for project in Project.open_projects():\n        if (by_id and project.id == by_id) or (by_name and project.name == by_name):\n            return project\n\n    return None\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.current_scene_ids","title":"<code>current_scene_ids() -&gt; Iterator[int]</code>  <code>staticmethod</code>","text":"<p>Yields the current project's scene ids.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@staticmethod\ndef current_scene_ids() -&gt; Iterator[int]:\n    \"\"\"Yields the current project's scene ids.\"\"\"\n    return utils.position_generator(lambda pos: george.tv_scene_enum_id(pos))\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.get_scene","title":"<code>get_scene(by_id: int | None = None, by_name: str | None = None) -&gt; Scene | None</code>","text":"<p>Find a scene in the project by id or name.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>def get_scene(\n    self,\n    by_id: int | None = None,\n    by_name: str | None = None,\n) -&gt; Scene | None:\n    \"\"\"Find a scene in the project by id or name.\"\"\"\n    for scene in self.scenes:\n        if (by_id and scene.id == by_id) or (by_name and scene.name == by_name):\n            return scene\n\n    return None\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.add_scene","title":"<code>add_scene() -&gt; Scene</code>","text":"<p>Add a new scene in the project.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@set_as_current\ndef add_scene(self) -&gt; Scene:\n    \"\"\"Add a new scene in the project.\"\"\"\n    from pytvpaint.scene import Scene\n\n    return Scene.new(project=self)\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.get_clip","title":"<code>get_clip(by_id: int | None = None, by_name: str | None = None, scene_id: int | None = None) -&gt; Clip | None</code>","text":"<p>Find a clip by id, name or scene_id.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>def get_clip(\n    self,\n    by_id: int | None = None,\n    by_name: str | None = None,\n    scene_id: int | None = None,\n) -&gt; Clip | None:\n    \"\"\"Find a clip by id, name or scene_id.\"\"\"\n    clips = self.clips\n    if scene_id:\n        selected_scene = self.get_scene(by_id=scene_id)\n        clips = selected_scene.clips if selected_scene else clips\n\n    for clip in clips:\n        if (by_id and clip.id == by_id) or (by_name and clip.name == by_name):\n            return clip\n\n    return None\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.add_clip","title":"<code>add_clip(clip_name: str, scene: Scene | None = None) -&gt; Clip</code>","text":"<p>Add a new clip in the given scene or the current one if no scene provided.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>def add_clip(self, clip_name: str, scene: Scene | None = None) -&gt; Clip:\n    \"\"\"Add a new clip in the given scene or the current one if no scene provided.\"\"\"\n    scene = scene or self.current_scene\n    return scene.add_clip(clip_name)\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.add_sound","title":"<code>add_sound(sound_path: Path | str) -&gt; ProjectSound</code>","text":"<p>Add a new sound clip to the project.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>def add_sound(self, sound_path: Path | str) -&gt; ProjectSound:\n    \"\"\"Add a new sound clip to the project.\"\"\"\n    return ProjectSound.new(sound_path, parent=self)\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.render","title":"<code>render(output_path: Path | str | FileSequence, start: int | None = None, end: int | None = None, use_camera: bool = False, alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY, background_mode: george.BackgroundMode | None = None, format_opts: list[str] | None = None) -&gt; None</code>","text":"<p>Render the project to a single frame or frame sequence or movie.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>pathlib.Path | str | fileseq.filesequence.FileSequence</code> <p>a single file or file sequence pattern</p> required <code>start</code> <code>int | None</code> <p>the start frame to render or the mark in or the project's start frame if None. Defaults to None.</p> <code>None</code> <code>end</code> <code>int | None</code> <p>the end frame to render or the mark out or the project's end frame if None. Defaults to None.</p> <code>None</code> <code>use_camera</code> <code>bool</code> <p>use the camera for rendering, otherwise render the whole canvas. Defaults to False.</p> <code>False</code> <code>alpha_mode</code> <code>pytvpaint.george.AlphaSaveMode</code> <p>the alpha mode for rendering. Defaults to george.AlphaSaveMode.PREMULTIPLY.</p> <code>pytvpaint.george.AlphaSaveMode.PREMULTIPLY</code> <code>background_mode</code> <code>pytvpaint.george.BackgroundMode | None</code> <p>the background mode for rendering. Defaults to george.BackgroundMode.NONE.</p> <code>None</code> <code>format_opts</code> <code>list[str] | None</code> <p>custom format options. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if requested range (start-end) not in project range/bounds</p> <code>ValueError</code> <p>if output is a movie, and it's duration is equal to 1 frame</p> <code>FileNotFoundError</code> <p>if the render failed and no files were found on disk or missing frames</p> Note <p>This functions uses the project's timeline as a basis for the range (start-end). This timeline includes all the project's clips and is different from a clip range. For more details on the differences in frame ranges and the timeline in TVPaint, please check the <code>Usage/Rendering</code> section of the documentation.</p> Warning <p>Even tough pytvpaint does a pretty good job of correcting the frame ranges for rendering, we're still encountering some weird edge cases where TVPaint will consider the range invalid for seemingly no reason.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@set_as_current\ndef render(\n    self,\n    output_path: Path | str | FileSequence,\n    start: int | None = None,\n    end: int | None = None,\n    use_camera: bool = False,\n    alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY,\n    background_mode: george.BackgroundMode | None = None,\n    format_opts: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Render the project to a single frame or frame sequence or movie.\n\n    Args:\n        output_path: a single file or file sequence pattern\n        start: the start frame to render or the mark in or the project's start frame if None. Defaults to None.\n        end: the end frame to render or the mark out or the project's end frame if None. Defaults to None.\n        use_camera: use the camera for rendering, otherwise render the whole canvas. Defaults to False.\n        alpha_mode: the alpha mode for rendering. Defaults to george.AlphaSaveMode.PREMULTIPLY.\n        background_mode: the background mode for rendering. Defaults to george.BackgroundMode.NONE.\n        format_opts: custom format options. Defaults to None.\n\n    Raises:\n        ValueError: if requested range (start-end) not in project range/bounds\n        ValueError: if output is a movie, and it's duration is equal to 1 frame\n        FileNotFoundError: if the render failed and no files were found on disk or missing frames\n\n    Note:\n        This functions uses the project's timeline as a basis for the range (start-end). This timeline includes all\n        the project's clips and is different from a clip range. For more details on the differences in frame ranges\n        and the timeline in TVPaint, please check the `Usage/Rendering` section of the documentation.\n\n    Warning:\n        Even tough pytvpaint does a pretty good job of correcting the frame ranges for rendering, we're still\n        encountering some weird edge cases where TVPaint will consider the range invalid for seemingly no reason.\n    \"\"\"\n    default_start = self.mark_in or self.start_frame\n    default_end = self.mark_out or self.end_frame\n\n    self._render(\n        output_path,\n        default_start,\n        default_end,\n        start,\n        end,\n        use_camera,\n        layer_selection=None,\n        alpha_mode=alpha_mode,\n        background_mode=background_mode,\n        format_opts=format_opts,\n    )\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.render_clips","title":"<code>render_clips(clips: list[Clip], output_path: Path | str | FileSequence, use_camera: bool = False, alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY, background_mode: george.BackgroundMode | None = None, format_opts: list[str] | None = None) -&gt; None</code>","text":"<p>Render sequential clips as a single output.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@set_as_current\ndef render_clips(\n    self,\n    clips: list[Clip],\n    output_path: Path | str | FileSequence,\n    use_camera: bool = False,\n    alpha_mode: george.AlphaSaveMode = george.AlphaSaveMode.PREMULTIPLY,\n    background_mode: george.BackgroundMode | None = None,\n    format_opts: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Render sequential clips as a single output.\"\"\"\n    clips = sorted(clips, key=lambda c: c.position)\n    start = clips[0].timeline_start\n    end = clips[-1].timeline_end\n    self.render(\n        output_path,\n        start,\n        end,\n        use_camera,\n        alpha_mode,\n        background_mode,\n        format_opts,\n    )\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.current_project_id","title":"<code>current_project_id() -&gt; str</code>  <code>staticmethod</code>","text":"<p>Returns the current project id.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@staticmethod\ndef current_project_id() -&gt; str:\n    \"\"\"Returns the current project id.\"\"\"\n    return george.tv_project_current_id()\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.current_project","title":"<code>current_project() -&gt; Project</code>  <code>staticmethod</code>","text":"<p>Returns the current project.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@staticmethod\ndef current_project() -&gt; Project:\n    \"\"\"Returns the current project.\"\"\"\n    return Project(project_id=Project.current_project_id())\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.open_projects_ids","title":"<code>open_projects_ids() -&gt; Iterator[str]</code>  <code>staticmethod</code>","text":"<p>Yields the ids of the currently open projects.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@staticmethod\ndef open_projects_ids() -&gt; Iterator[str]:\n    \"\"\"Yields the ids of the currently open projects.\"\"\"\n    return utils.position_generator(lambda pos: george.tv_project_enum_id(pos))\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.open_projects","title":"<code>open_projects() -&gt; Iterator[Project]</code>  <code>classmethod</code>","text":"<p>Iterator over the currently open projects.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@classmethod\ndef open_projects(cls) -&gt; Iterator[Project]:\n    \"\"\"Iterator over the currently open projects.\"\"\"\n    for project_id in Project.open_projects_ids():\n        yield Project(project_id)\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.new","title":"<code>new(project_path: Path | str, width: int = 1920, height: int = 1080, pixel_aspect_ratio: float = 1.0, frame_rate: float = 24.0, field_order: george.FieldOrder = george.FieldOrder.NONE, start_frame: int = 1) -&gt; Project</code>  <code>classmethod</code>","text":"<p>Create a new project.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    project_path: Path | str,\n    width: int = 1920,\n    height: int = 1080,\n    pixel_aspect_ratio: float = 1.0,\n    frame_rate: float = 24.0,\n    field_order: george.FieldOrder = george.FieldOrder.NONE,\n    start_frame: int = 1,\n) -&gt; Project:\n    \"\"\"Create a new project.\"\"\"\n    george.tv_project_new(\n        Path(project_path).resolve().as_posix(),\n        width,\n        height,\n        pixel_aspect_ratio,\n        frame_rate,\n        field_order,\n        start_frame,\n    )\n    return cls.current_project()\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.new_from_camera","title":"<code>new_from_camera(export_path: Path | str | None = None) -&gt; Project</code>","text":"<p>Create a new cropped project from the camera view.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@set_as_current\ndef new_from_camera(self, export_path: Path | str | None = None) -&gt; Project:\n    \"\"\"Create a new cropped project from the camera view.\"\"\"\n    cam_project_id = george.tv_project_render_camera(self.id)\n    cam_project = Project(cam_project_id)\n\n    if export_path:\n        export_path = Path(export_path)\n        export_path.mkdir(exist_ok=True, parents=True)\n        cam_project.save(export_path)\n\n    return cam_project\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.duplicate","title":"<code>duplicate() -&gt; Project</code>","text":"<p>Duplicate the project and return the new one.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@set_as_current\ndef duplicate(self) -&gt; Project:\n    \"\"\"Duplicate the project and return the new one.\"\"\"\n    george.tv_project_duplicate()\n    duplicated = Project.current_project()\n    self.make_current()\n    return duplicated\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.close","title":"<code>close() -&gt; None</code>","text":"<p>Closes the project.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Closes the project.\"\"\"\n    self._is_closed = True\n    george.tv_project_close(self._id)\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.close_all","title":"<code>close_all(close_tvp: bool = False) -&gt; None</code>  <code>classmethod</code>","text":"<p>Closes all open projects.</p> <p>Parameters:</p> Name Type Description Default <code>close_tvp</code> <code>bool</code> <p>close the TVPaint instance as well</p> <code>False</code> Source code in <code>pytvpaint/project.py</code> <pre><code>@classmethod\ndef close_all(cls, close_tvp: bool = False) -&gt; None:\n    \"\"\"Closes all open projects.\n\n    Args:\n        close_tvp: close the TVPaint instance as well\n    \"\"\"\n    for project in list(cls.open_projects()):\n        project.close()\n\n    if close_tvp:\n        george.tv_quit()\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.load","title":"<code>load(project_path: Path | str, silent: bool = True) -&gt; Project</code>  <code>classmethod</code>","text":"<p>Load an existing .tvpp/.tvp project or .tvpx file.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@classmethod\ndef load(cls, project_path: Path | str, silent: bool = True) -&gt; Project:\n    \"\"\"Load an existing .tvpp/.tvp project or .tvpx file.\"\"\"\n    project_path = Path(project_path)\n\n    # Check if project not already open, if so, return it\n    for project in cls.open_projects():\n        if project.path == project_path:\n            return project\n\n    george.tv_load_project(project_path, silent)\n    return cls.current_project()\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.save","title":"<code>save(save_path: Path | str | None = None) -&gt; None</code>","text":"<p>Saves the project on disk.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>def save(self, save_path: Path | str | None = None) -&gt; None:\n    \"\"\"Saves the project on disk.\"\"\"\n    save_path = Path(save_path or self.path).resolve()\n    george.tv_save_project(save_path.as_posix())\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.load_panel","title":"<code>load_panel(panel_path: Path | str) -&gt; None</code>","text":"<p>Load an external TVPaint panel.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@set_as_current\ndef load_panel(self, panel_path: Path | str) -&gt; None:\n    \"\"\"Load an external TVPaint panel.\"\"\"\n    george.tv_load_project(panel_path, silent=True)\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.load_palette","title":"<code>load_palette(palette_path: Path | str) -&gt; None</code>","text":"<p>Load a palette.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@set_as_current\ndef load_palette(self, palette_path: Path | str) -&gt; None:\n    \"\"\"Load a palette.\"\"\"\n    george.tv_save_palette(palette_path)\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.save_palette","title":"<code>save_palette(save_path: Path | str | None = None) -&gt; None</code>","text":"<p>Save a palette to the given path.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@set_as_current\ndef save_palette(self, save_path: Path | str | None = None) -&gt; None:\n    \"\"\"Save a palette to the given path.\"\"\"\n    save_path = Path(save_path or self.path)\n    george.tv_save_project(save_path)\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.save_video_dependencies","title":"<code>save_video_dependencies(on_save: bool = True, now: bool = True) -&gt; None</code>","text":"<p>Saves the video dependencies.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@set_as_current\ndef save_video_dependencies(self, on_save: bool = True, now: bool = True) -&gt; None:\n    \"\"\"Saves the video dependencies.\"\"\"\n    george.tv_project_save_video_dependencies(self.id, on_save, now)\n</code></pre>"},{"location":"api/objects/project/#pytvpaint.project.Project.save_audio_dependencies","title":"<code>save_audio_dependencies(on_save: bool = True) -&gt; None</code>","text":"<p>Saves audio dependencies.</p> Source code in <code>pytvpaint/project.py</code> <pre><code>@set_as_current\ndef save_audio_dependencies(self, on_save: bool = True) -&gt; None:\n    \"\"\"Saves audio dependencies.\"\"\"\n    george.tv_project_save_audio_dependencies(self.id, on_save)\n</code></pre>"},{"location":"api/objects/project_sound/","title":"ProjectSound class","text":"<p>             Bases: <code>pytvpaint.sound.BaseSound['Project']</code></p> <p>A Project sound.</p> Source code in <code>pytvpaint/sound.py</code> <pre><code>def __init__(\n    self,\n    track_index: int,\n    project: Project | None = None,\n) -&gt; None:\n    from pytvpaint.project import Project\n\n    project = project or Project.current_project()\n    super().__init__(track_index, project)\n</code></pre>"},{"location":"api/objects/project_sound/#pytvpaint.sound.ProjectSound.project","title":"<code>project: Project</code>  <code>property</code>","text":"<p>The sound's project.</p>"},{"location":"api/objects/project_sound/#pytvpaint.sound.ProjectSound.remove","title":"<code>remove() -&gt; None</code>","text":"<p>Remove the sound from the project.</p> Source code in <code>pytvpaint/sound.py</code> <pre><code>@set_as_current\ndef remove(self) -&gt; None:\n    \"\"\"Remove the sound from the project.\"\"\"\n    george.tv_sound_project_remove(self.track_index)\n    self.mark_removed()\n</code></pre>"},{"location":"api/objects/project_sound/#pytvpaint.sound.ProjectSound.reload","title":"<code>reload() -&gt; None</code>","text":"<p>Reload the sound from file.</p> Source code in <code>pytvpaint/sound.py</code> <pre><code>def reload(self) -&gt; None:\n    \"\"\"Reload the sound from file.\"\"\"\n    george.tv_sound_project_reload(self.project.id, self.track_index)\n</code></pre>"},{"location":"api/objects/project_sound/#pytvpaint.sound.ProjectSound.make_current","title":"<code>make_current() -&gt; None</code>","text":"<p>Makes the sound project current.</p> Source code in <code>pytvpaint/sound.py</code> <pre><code>def make_current(self) -&gt; None:\n    \"\"\"Makes the sound project current.\"\"\"\n    self.project.make_current()\n</code></pre>"},{"location":"api/objects/scene/","title":"Scene class","text":"<p>Scene class.</p>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene","title":"<code>Scene(scene_id: int, project: Project)</code>","text":"<p>             Bases: <code>pytvpaint.utils.Removable</code></p> <p>A Scene is a collection of clips. A Scene is inside a project.</p> Source code in <code>pytvpaint/scene.py</code> <pre><code>def __init__(self, scene_id: int, project: Project) -&gt; None:\n    super().__init__()\n    self._id: int = scene_id\n    self._project = project\n</code></pre>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.is_current","title":"<code>is_current: bool</code>  <code>property</code>","text":"<p>Returns <code>True</code> if the scene is the current one.</p>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.id","title":"<code>id: int</code>  <code>property</code>","text":"<p>The scene id.</p>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.project","title":"<code>project: Project</code>  <code>property</code>","text":"<p>The scene's project.</p>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.position","title":"<code>position: int</code>  <code>property</code> <code>writable</code>","text":"<p>The scene's position in the project.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if scene cannot be found in the project</p>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.clip_ids","title":"<code>clip_ids: Iterator[int]</code>  <code>property</code>","text":"<p>Returns an iterator over the clip ids.</p>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.clips","title":"<code>clips: Iterator[Clip]</code>  <code>property</code>","text":"<p>Yields the scene clips.</p>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.current_scene_id","title":"<code>current_scene_id() -&gt; int</code>  <code>staticmethod</code>","text":"<p>Returns the current scene id (the current clip's scene).</p> Source code in <code>pytvpaint/scene.py</code> <pre><code>@staticmethod\ndef current_scene_id() -&gt; int:\n    \"\"\"Returns the current scene id (the current clip's scene).\"\"\"\n    return george.tv_scene_current_id()\n</code></pre>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.current_scene","title":"<code>current_scene() -&gt; Scene</code>  <code>staticmethod</code>","text":"<p>Returns the current scene of the current project.</p> Source code in <code>pytvpaint/scene.py</code> <pre><code>@staticmethod\ndef current_scene() -&gt; Scene:\n    \"\"\"Returns the current scene of the current project.\"\"\"\n    return Scene(\n        scene_id=george.tv_scene_current_id(),\n        project=Project.current_project(),\n    )\n</code></pre>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.new","title":"<code>new(project: Project | None = None) -&gt; Scene</code>  <code>classmethod</code>","text":"<p>Creates a new scene in the provided project.</p> Source code in <code>pytvpaint/scene.py</code> <pre><code>@classmethod\ndef new(cls, project: Project | None = None) -&gt; Scene:\n    \"\"\"Creates a new scene in the provided project.\"\"\"\n    project = project or Project.current_project()\n    project.make_current()\n    george.tv_scene_new()\n    return cls.current_scene()\n</code></pre>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.make_current","title":"<code>make_current() -&gt; None</code>","text":"<p>Make this scene the current one.</p> Source code in <code>pytvpaint/scene.py</code> <pre><code>def make_current(self) -&gt; None:\n    \"\"\"Make this scene the current one.\"\"\"\n    if self.is_current:\n        return\n\n    # In order to select the scene, we select any child clip inside of it\n    first_clip_id = george.tv_clip_enum_id(self.id, 0)\n    george.tv_clip_select(first_clip_id)\n</code></pre>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.get_clip","title":"<code>get_clip(by_id: int | None = None, by_name: str | None = None) -&gt; Clip | None</code>","text":"<p>Find a clip by id or by name.</p> Source code in <code>pytvpaint/scene.py</code> <pre><code>def get_clip(\n    self,\n    by_id: int | None = None,\n    by_name: str | None = None,\n) -&gt; Clip | None:\n    \"\"\"Find a clip by id or by name.\"\"\"\n    for clip in self.clips:\n        if (by_id and clip.id == by_id) or (by_name and clip.name == by_name):\n            return clip\n\n    return None\n</code></pre>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.add_clip","title":"<code>add_clip(clip_name: str) -&gt; Clip</code>","text":"<p>Adds a new clip to the scene.</p> Source code in <code>pytvpaint/scene.py</code> <pre><code>@set_as_current\ndef add_clip(self, clip_name: str) -&gt; Clip:\n    \"\"\"Adds a new clip to the scene.\"\"\"\n    self.make_current()\n    return Clip.new(name=clip_name, project=self.project)\n</code></pre>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.duplicate","title":"<code>duplicate() -&gt; Scene</code>","text":"<p>Duplicate the scene and return it.</p> Source code in <code>pytvpaint/scene.py</code> <pre><code>def duplicate(self) -&gt; Scene:\n    \"\"\"Duplicate the scene and return it.\"\"\"\n    self.project.make_current()\n    george.tv_scene_duplicate(self.id)\n    dup_pos = self.position + 1\n    dup_id = george.tv_scene_enum_id(dup_pos)\n    return Scene(dup_id, self.project)\n</code></pre>"},{"location":"api/objects/scene/#pytvpaint.scene.Scene.remove","title":"<code>remove() -&gt; None</code>","text":"<p>Remove the scene and all the clips inside.</p> Warning <p>All <code>Clip</code> instances will be invalid after removing the scene. There's no protection mechanism to prevent accessing clip data that doesn't exist anymore.</p> Source code in <code>pytvpaint/scene.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"Remove the scene and all the clips inside.\n\n    Warning:\n        All `Clip` instances will be invalid after removing the scene.\n        There's no protection mechanism to prevent accessing clip data that doesn't exist anymore.\n    \"\"\"\n    george.tv_scene_close(self._id)\n    self.mark_removed()\n</code></pre>"},{"location":"contributing/developer_setup/","title":"Developer setup","text":"<p>This guide will explain how to set up your environment in order to contribute to PyTVPaint.</p>"},{"location":"contributing/developer_setup/#requirements","title":"Requirements","text":"<ul> <li> <p>Python 3.9 or greater are the supported versions for PyTVPaint.</p> </li> <li> <p>We use Poetry which is the packaging and dependency management tool. It handles your dev virtualenv with your working dependencies.</p> </li> </ul>"},{"location":"contributing/developer_setup/#pytvpaint","title":"PyTVPaint","text":"<p>First clone the repository:</p> <pre><code>\u276f git clone https://github.com/brunchstudio/pytvpaint.git\n\n# or if you use SSH auth\n\u276f git clone git@github.com:brunchstudio/pytvpaint.git\n</code></pre> <p>Then install the dependencies in a virtualenv with Poetry:</p> <pre><code>\u276f poetry install\n</code></pre> <p>Note that this will only install the library dependency. To install optional dependency groups (to build the documentation, run tests, etc...) you can use the <code>--with</code> parameter:</p> <pre><code>\u276f poetry install --with dev,docs,test\n</code></pre>"},{"location":"contributing/developer_setup/#code-formatting","title":"Code formatting","text":"<p>We use Black to ensure that the code format is always the same. Black has strong defaults and is easy to use:</p> <pre><code># Will format all the .py files in the current directory\n(venv) \u276f black .\n\n# To only check if the format is correct\n(venv) \u276f black --check .\n</code></pre> <p>Tip</p> <p>Use <code>poetry shell</code> to enter a new shell in the virtualenv. In this page commands marked <code>(venv) \u276f</code> can also be run with <code>poetry run &lt;command&gt;</code></p>"},{"location":"contributing/developer_setup/#linting","title":"Linting","text":"<p>We also use Ruff as a linter. It combines a lot of rules from other projects like Flake8, pyupgrade, pydocstyle, isort, etc...</p> <pre><code>(venv) \u276f ruff .\n\n# Will apply autofixes\n(venv) \u276f ruff --fix .\n</code></pre>"},{"location":"contributing/developer_setup/#type-checking","title":"Type checking","text":"<p>Mypy is the go-to static type checker for Python. It ensures that variables and functions are used correctly and can catch refactor errors when editing the codebase.</p> <pre><code>(venv) \u276f mypy .\n</code></pre> <p>Info</p> <p>We currently exclude untyped calls for Fileseq and websocket-client  in <code>pyproject.toml</code> with <code>untyped_calls_exclude</code></p>"},{"location":"contributing/developer_setup/#documentation","title":"Documentation","text":"<p>The documentation is built using MkDocs which is a static site generator that uses Markdown as the source format.</p> <p>On top of that we use Material for MkDocs which provides the Material look as well as some other nice features.</p> <p>You can either run the development server or build the entire documentation:</p> <pre><code># Will serve the doc on http://127.0.0.1:8000 with hot reload\n(venv) \u276f mkdocs serve\n\n# Build the doc as static files\n(venv) \u276f mkdocs build\n</code></pre> <p>The Python API documentation is auto-generated from the docstrings in the code by using mkdocstrings. We use the Google style for docstrings.</p> <p>For example:</p> <pre><code>def tv_request(msg: str, confirm_text: str = \"Yes\", cancel_text: str = \"No\") -&gt; bool:\n    \"\"\"Open a confirmation prompt with a message.\n\n    Args:\n        msg: the message to display\n        confirm_text: the confirm button text. Defaults to \"Yes\".\n        cancel_text: the cancel button text. Defaults to \"No\".\n\n    Returns:\n        bool: True if clicked on \"Yes\"\n    \"\"\"\n    return bool(int(send_cmd(\"tv_Request\", msg, confirm_text, cancel_text)))\n</code></pre>"},{"location":"contributing/developer_setup/#unit-tests","title":"Unit tests","text":"<p>For the unit tests, we use Pytest. Fixtures are located in the <code>conftest.py</code> file.</p> <p>To run the tests you'll need an open TVPaint instance with the tvpaint-rpc plugin installed.</p> <p>To run them, use the following commands:</p> <pre><code># Will run all the tests\n(venv) \u276f pytest\n\n# Run with verbosity enabled (use PYTVPAINT_LOG_LEVEL to DEBUG) to see George commands\n(venv) \u276f pytest -v -s\n\n# Only run specific tests with pattern matching\n(venv) \u276f pytest -k test_tv_clip\n\n# See the coverage statistics with pytest-cov\n(venv) \u276f pytest --cov=pytvpaint\n</code></pre>"},{"location":"contributing/internals/","title":"How it works internally","text":"<p>The following diagram shows how each processes interact to make PyTVPaint work:</p> <pre><code>sequenceDiagram\n    participant PyTVPaint\n    participant TVPaint RPC server\n    participant TVPaint\n\n    PyTVPaint-&gt;&gt;TVPaint RPC server: {\"jsonrpc\": \"2.0\", \"method\": \"execute_george\", \"params\": [\"tv_version\"], \"id\": 45}\n    TVPaint RPC server-&gt;&gt;TVPaint: TVSendCmd(_, \"tv_Version\", buf)\n    TVPaint-&gt;&gt;TVPaint RPC server: '\"TVP Animation 11 Pro\" 11.7.1 en'\n    TVPaint RPC server-&gt;&gt;PyTVPaint: {'id': 45, 'jsonrpc': '2.0', 'result': '\"TVP Animation 11 Pro\" 11.7.1 en'}</code></pre> <ol> <li>The end user calls <code>tv_version()</code> from <code>pytvpaint.george</code> in Python.</li> <li>It calls <code>send_cmd(\"tv_Version\")</code> which is the low level function that sends george commands</li> <li>It then calls <code>rpc_client.execute_remote(\"execute_george\", [\"tv_version\"])</code></li> <li>The JSON-RPC client sends the serialized JSON payload to the server <code>self.ws_handle.send(json.dumps(payload))</code></li> <li>The C++ plugin receives the message and store it in the George commands queue.</li> <li>George commands are executed in the main thread, so at each plugin tick we check if we have commands to execute, execute them with the C++ SDK function <code>TVSendCmd</code> and send back the result.</li> <li>We get back the result in PyTVPaint and use the <code>tv_parse_list</code> function to parse the resulting string from George and return a tuple from <code>tv_version</code>.</li> </ol>"},{"location":"contributing/modify_objects/","title":"Modifying high-level classes","text":"<p>This guide explains how to create/modify the high-level Python API with classes like <code>Project</code>, <code>Clip</code> or <code>Layer</code>.</p> <p>Classes are object oriented wrappers around the raw data from TVPaint (as dataclasses).</p> <p>For example the <code>Project</code> class has a <code>_data</code> attribute which is the main state of the object:</p> <pre><code># pytvpaint/project.py\n\nclass Project(Refreshable):\n    def __init__(self, project_id: str) -&gt; None:\n        super().__init__()\n        # ...\n        self._data: TVPProject = george.tv_project_info(self._id)\n</code></pre> <p>The type of the internal <code>_data</code> attribute is <code>TVPProject</code> which is the dataclass containing the data returned by TVPaint and parsed by our API.</p>"},{"location":"contributing/modify_objects/#properties","title":"Properties","text":"<p>We use properties to expose the attributes of the object while controlling which one can be get or set by the end user.</p> <p>For example this is the <code>id</code> property of the Project class, it can be read but not written (project ids are persistent across sessions):</p> <pre><code>@property\ndef id(self) -&gt; str:\n    \"\"\"The project id.\n\n    Note:\n        the id is persistent on project load/close.\n    \"\"\"\n    return self._id\n</code></pre>"},{"location":"contributing/modify_objects/#refreshable-properties","title":"Refreshable properties","text":"<p>Some properties can be changed after the object instance is created in Python. This means that the state of the Python object is different from the state of the real object in TVPaint. Since the data is fetched only at init, we need a mechanism to refresh the data at each property call.</p> <p>Here is an example with the <code>refreshed_property</code> decorator:</p> <pre><code>@refreshed_property\ndef path(self) -&gt; Path:\n    \"\"\"The project path on disk.\"\"\"\n    return self._data.path\n</code></pre> <p>It calls the object's overriden <code>self.refresh()</code> method before returning the internal value. This ensure that the value you are getting is always the right one at call time.</p>"},{"location":"contributing/modify_objects/#make-the-object-current","title":"Make the object current","text":"<p>Some George functions only apply to the \"current\" object in the TVPaint instance.</p> <p>To do that in an elegant way, we use the <code>set_as_current</code> decorator for all the methods and properties that require that object to be the current:</p> <pre><code>@property\n@set_as_current\ndef width(self) -&gt; int:\n    \"\"\"The width of the canvas.\"\"\"\n    return george.tv_get_width() # (1)!\n</code></pre> <ol> <li>Here we use a more specific George function to get the data instead of using the <code>tv_project_info</code> function which is more expensive. We don't need <code>refreshed_property</code> neither.</li> </ol> <p>It calls the object's <code>self.make_current()</code> method.</p>"},{"location":"contributing/modify_objects/#get-access-to-children-objects","title":"Get access to children objects","text":"<p>For the <code>Project</code> class, we want to give access to the scenes inside it. To do that we make a property that is a generator over <code>Scene</code> objects.</p> <pre><code>@property\n@set_as_current\ndef scenes(self) -&gt; Iterator[Scene]:\n    \"\"\"Yields the project scenes.\"\"\"\n    from pytvpaint.scene import Scene # (1)!\n\n    for scene_id in self.current_scene_ids():\n        yield Scene(scene_id, self) # (2)!\n</code></pre> <ol> <li>We use the <code>from &lt;mod&gt; import ...</code> statement in the method because the <code>Scene</code> and <code>Project</code> classes have a circular dependency.</li> <li>We pass <code>self</code> as the second argument to have a reference of the project in the Scene object.</li> </ol> <p>Tip</p> <p>Most of the <code>Iterator</code> in PyTVPaint are generators which mean it will only get the data (and send requests to TVPaint) if you want the next element.</p> <p>So you can stop whenever you want:</p> <pre><code>for scene in project.scenes:\n    if scene.id == 787:\n        print(scene)\n        break\n</code></pre>"},{"location":"contributing/wrap_george/","title":"Wrapping George commands","text":"<p>This guide explains how to wrap a George command. The first step is to look at the George command documentation and pick the one you want to implement.</p>"},{"location":"contributing/wrap_george/#simple-command-without-arguments","title":"Simple command without arguments","text":"<p>This one is simple because we don't have any arguments and return value:</p> <p>Example</p> <pre><code>tv_lockuser\n\nDisable interaction of the user with the interface\n</code></pre> <p>Use the <code>send_cmd</code> function to send a George command:</p> <pre><code>from pytvpaint import send_cmd\n\ndef tv_lock_user() -&gt; None: # (1)!\n    send_cmd(\"tv_LockUser\") # (2)!\n</code></pre> <ol> <li>We use Camel case for functions so we break words in George commands. So <code>tv_lockuser</code> becomes <code>tv_lock_user</code>.</li> <li>We use Pascal case for the George command strings because it's case insensitive and has better readability than <code>tv_lockuser</code>.</li> </ol>"},{"location":"contributing/wrap_george/#command-with-arguments","title":"Command with arguments","text":"<p>Example</p> <pre><code>tv_libraryimagecopy\n\nCopy an object\n\n[PARAMETERS]\n\"id\" iId    string    The id\n\n[RETURN]\n0    int    Object copied\n\n[ERROR]\n-2    int    No project/no library\n-3    int    No param/invalid param\n</code></pre> <pre><code>from pytvpaint import send_cmd\n\ndef tv_library_image_copy(image_id: str) -&gt; None:\n    send_cmd(\"tv_LibraryImageCopy\", image_id, error_values=[-2, -3]) # (1)!\n</code></pre> <ol> <li>Note that we provide the error values that George returns. If <code>send_cmd</code> get those values it raises a <code>GeorgeError</code> exception.</li> </ol> <p>Notes:</p> <ul> <li><code>send_cmd</code> accepts any number of arguments to send to the George command.</li> <li>You can provide custom values for the error that should be raised.</li> </ul>"},{"location":"contributing/wrap_george/#command-with-complex-arguments-and-return-values","title":"Command with complex arguments and return values","text":"<p>This command is more tricky. It has:</p> <ul> <li>Multiple arguments</li> <li>Optional arguments (more than one sometimes)</li> <li>A dict-like return string value</li> </ul> <p>Example</p> <pre><code>tv_pegholesset [\"w\" iWidth] [\"h\" iHeight] [\"c1\" iCenterX1 iCenterY1] [\"c2\" iCenterX2 iCenterY2] [\"sw\" iWidth] [\"sh\" iHeight] [\"so1\" iOffsetX1 iOffsetY1] [\"so2\" iOffsetX2 iOffsetY2]\n\nManage pegholes\n\n[PARAMETERS]\n\"w\" iWidth                   int              The width of boxes\n\"h\" iHeight                  int              The height of boxes\n\"c1\" iCenterX1 iCenterY1     double double    The center of box 1\n\"c2\" iCenterX2 iCenterY2     double double    The center of box 2\n\"sw\" iWidth                  int              The additional width of for search boxes (added in 11.0.8)\n\"sh\" iHeight                 int              The additional height of for search boxes (added in 11.0.8)\n\"so1\" iOffsetX1 iOffsetY1    double double    The offset of search box 1 (added in 11.0.8)\n\"so2\" iOffsetX2 iOffsetY2    double double    The offset of search box 2 (added in 11.0.8)\n\n[RETURN]\n\"w\" oWidth \"h\" oHeight \"c1\" oCenterX1 oCenterY1 \"c2\" oCenterX2 oCenterY2 \"sw\" oWidth \"sh\" oHeight \"so1\" oOffsetX1 oOffsetY1 \"so2\" oOffsetX2 oOffsetY2\n\n\"w\" oWidth                   int              The current/previous width of boxes\n\"h\" oHeight                  int              The current/previous height of boxes\n\"c1\" oCenterX1 oCenterY1     double double    The current/previous center of box 1\n\"c2\" oCenterX2 oCenterY2     double double    The current/previous center of box 2\n\"sw\" oWidth                  int              The current/previous additional width of for search boxes (added in 11.0.8)\n\"sh\" oHeight                 int              The current/previous additional height of for search boxes (added in 11.0.8)\n\"so1\" oOffsetX1 oOffsetY1    double double    The current/previous offset of search box 1 (added in 11.0.8)\n\"so2\" oOffsetX2 oOffsetY2    double double    The current/previous offset of search box 2 (added in 11.0.8)\n\n[ERROR]\n\"ERROR\"    string    No peghole\n</code></pre> <pre><code>from dataclasses import dataclass\n\nfrom pytvpaint import send_cmd\nfrom pytvpaint.george.client.parse import args_dict_to_list, tv_parse_dict\n\n\n@dataclass(frozen=True) # (1)!\nclass PegHole:\n    w: int\n    h: int\n    c1: tuple[float, float]\n    c2: tuple[float, float]\n    sw: int\n    sh: int\n    so1: tuple[float, float]\n    so2: tuple[float, float]\n\n\ndef tv_peg_hole_set(\n    w: int | None = None,\n    h: int | None = None,\n    c1: tuple[float, float] | None = None,\n    c2: tuple[float, float] | None = None,\n    sw: int | None = None,\n    sh: int | None = None,\n    so1: tuple[float, float] | None = None,\n    so2: tuple[float, float] | None = None,\n) -&gt; PegHole:\n    params_dict = {\n        \"w\": w,\n        \"h\": h,\n        \"c1\": c1,\n        \"c2\": c2,\n        \"sw\": sw,\n        \"sh\": sh,\n        \"so1\": so1,\n        \"so2\": so2,\n    }\n\n    args = args_dict_to_list(params_dict)\n\n    result = send_cmd(\"tv_PegHolesSet\", *args)\n    result_dict = tv_parse_dict(result, with_fields=PegHole)\n\n    return PegHole(**result_dict)\n</code></pre> <ol> <li>Use <code>frozen=True</code> to prevent the dataclass attributes from being modified. Since the state of our objects in Python is not directly synchronized with TVPaint's state, we constrain the potentiel bugs.</li> </ol> <p>Notes:</p> <ul> <li> <p>We use dataclasses to describe the data types of complex objects return from TVPaint. It's similar to Pydantic's models. We then use <code>tv_parse_dict</code> to parse the key/value list of values returned from TVPaint to the dataclass types.</p> </li> <li> <p>In the George documentation, optional arguments are written with brackets around them like <code>[\"w\" iWidth] [\"h\" iHeight]</code>. In this function all the arguments are optional so we make them optional with <code>None</code> as a default value.</p> </li> <li> <p>We use <code>args_dict_to_list</code> to get a list of key/value pair arguments that only include non <code>None</code> values, since it's not necessary to send them to George. For example:   <pre><code>args_dict_to_list({ \"w\": 5, \"h\": None, \"m\": \"t\" }) == [\"w\", 5, \"m\", \"t\"]\n</code></pre></p> </li> </ul> <p>Success</p> <p>Everything is now correctly type-hinted and easy to use!</p> <pre><code>print(tv_peg_hole_set(w=50, h=100))\n# =&gt; PegHole(w=50, h=100, c1=(25.0, 200.0), c2=(25.0, 200.0), sw=10, sh=10, so1=(5.0, 5.0), so2=(5.0, 3.0))\n</code></pre>"},{"location":"contributing/wrap_george/#command-that-get-and-set-a-value","title":"Command that get and set a value","text":"<p>Some George commands are a getter and a setter at the same time. In PyTVPaint, we split the command in two separate functions with <code>_get</code> and <code>_set</code> suffix.</p> <p>Example</p> <pre><code>tv_notelock [0|1|\"on\"|\"off\"|\"lock\"|\"unlock\"|\"toggle\"]\n\nManage lock state of timeline note\n\n[PARAMETERS]\n0|1|\"on\"|\"off\"|\"lock\"|\"unlock\"|\"toggle\"    enum    The new lock state\n\n[RETURN]\n\"on\"|\"off\"    enum    The previous/current lock state\n</code></pre> <pre><code>from pytvpaint.george.client import send_cmd\n\n\ndef tv_note_lock_get() -&gt; bool:\n    return send_cmd(\"tv_NoteLock\") == \"on\"\n\n\ndef tv_note_lock_set(state: bool) -&gt; None:\n    send_cmd(\"tv_NoteLock\", int(state))\n</code></pre>"},{"location":"contributing/wrap_george/#handling-strings-in-command-arguments","title":"Handling strings in command arguments","text":"<p>Some George commands accept string arguments but the tricky part is when the input string has spaces. Since George arguments are separated by spaces, commands that have multiple arguments need a way to separate those.</p> <p>We need to wrap string arguments that have spaces with double quotes:</p> <pre><code>tv_LayerRename 7141 \"another layer\"\n</code></pre> <p>whereas commands that have a single argument don't need quotes otherwise they are parsed as part of the input string:</p> <pre><code>tv_LayerCreate this is a layer\n</code></pre> <p>You can specify the behavior when using <code>send_cmd</code> with the <code>handle_string</code> parameter:</p> <pre><code>def tv_layer_create(name: str) -&gt; int:\n    \"\"\"Create a new image layer with the given name.\"\"\"\n    return int(send_cmd(\"tv_LayerCreate\", name, handle_string=False))\n</code></pre>"},{"location":"cpp/","title":"PyTVPaint's C++ plugin","text":"<p>To communicate with TVPaint, we developed a TVPaint plugin using C++ and their SDK.</p> <p>It's a JSON-RPC over WebSocket server that offers an endpoint to send George commands.</p> <p>By default it listens on port <code>3000</code> but you can set the <code>PYTVPAINT_WS_HOST</code> environment variable to set another port at startup.</p> <p>Here is an example of JSON messages and responses:</p> <pre><code>--&gt; {\"jsonrpc\": \"2.0\", \"method\": \"execute_george\", \"params\": [\"tv_version\"], \"id\": 0}\n&lt;-- {'id': 0, 'jsonrpc': '2.0', 'result': '\"TVP Animation 11 Pro\" 11.5.3 fr'}\n\n--&gt; {\"jsonrpc\": \"2.0\", \"method\": \"unknown_method\", \"params\": [], \"id\": 0}\n&lt;-- {'error': {'code': -32601, 'message': 'Method not found'}, 'id': 0, 'jsonrpc': '2.0'}\n</code></pre> <p>Abstract</p> <p>The plugin was adapted from the open source Ynput/Avalon TVPaint plugin.</p>"},{"location":"cpp/building/","title":"Building the plugin","text":"<p>Note</p> <p>The C++ plugin is currently Windows only.</p>"},{"location":"cpp/building/#setup","title":"Setup","text":"<p>To install the build dependencies, we use Conan which is a C/C++ package manager.</p> <p>To install it, use the virtualenv provided by Poetry:</p> <pre><code>\u276f poetry install # Installs Conan\n\u276f poetry shell # Enter a new venv shell\n</code></pre> <p>Then configure your Conan compilation profile:</p> <pre><code>(venv) \u276f conan profile detect\n</code></pre>"},{"location":"cpp/building/#windows","title":"Windows","text":"<p>To compile the project with MSVC, an example configuration would be:</p> <pre><code># C:\\Users\\$USER\\.conan2\\profiles\\default\n\n[settings]\narch=x86_64\nbuild_type=Release\ncompiler=msvc\ncompiler.cppstd=17\ncompiler.runtime=static\ncompiler.version=193\nos=Windows\n</code></pre> <ul> <li>On MSVC, to check your <code>compiler.version</code>, run the command <code>cl</code> in a Developer Command Prompt for VS and check the <code>C/C++ Optimizing Compiler Version</code> for example <code>19.35.32215</code></li> </ul> <p>To check if your profile is correct, use:</p> <pre><code>(venv) \u276f conan profile show\n</code></pre>"},{"location":"cpp/building/#install-the-c-dependencies","title":"Install the C++ dependencies","text":"<p>Install the dependencies specified in <code>conanfile.txt</code>:</p> <pre><code>(venv) \u276f conan install . --output-folder=build --build=missing\n</code></pre> <p>The above command generates CMake build files that helps finding those libraries.</p>"},{"location":"cpp/building/#build","title":"Build","text":"<p>You first need to download the TVPaint C/C++ SDK in a local folder.</p> <p>Configure the project with CMake and Conan by going into the <code>build</code> folder:</p> <pre><code>\u276f cd build\n\u276f cmake .. -G \"Visual Studio 17 2022\" -DCMAKE_TOOLCHAIN_FILE=\"conan_toolchain.cmake\" -DTVPAINT_SDK_FOLDER=\"/path/to/TVPaint_SDK\"\n</code></pre> <p>(the above command assumes you are using <code>Visual Studio 17</code>, if not match that with your Conan profile)</p> <p>Build the project in release mode:</p> <pre><code>\u276f cmake --build . --config Release\n</code></pre>"},{"location":"usage/rendering/","title":"Rendering","text":""},{"location":"usage/rendering/#rendering-in-pytvpaint","title":"Rendering in PyTVPaint","text":"<p>PyTVPaint can render a clip or a Project using the <code>render</code> functions, here is a basic example of how to use it</p> <pre><code>from pytvpaint.project import Project\nfrom pytvpaint.clip import Clip\n\n# to render a project\nproject = Project.current_project()\nproject.render(\"./out.#.png\", start=0, end=67)\n\n# to render a clip\nclip = Clip.current_clip()\nclip.render(\"./out.#.png\", start=10, end=22)\n</code></pre> <p>Warning</p> <p>For more details on how we handle frame ranges in the projects and clips, please check the sections below, which go into detail about how TVPaint handles ranges and how we changed it to fit our needs.</p>"},{"location":"usage/rendering/#sequence-parsing-with-fileseq","title":"Sequence parsing with Fileseq","text":"<p>When providing an output path to our functions, we use the handy Python library Fileseq for parsing and handling the expected frame ranges, which means you can use frame range expressions when rendering a clip or a project.</p> <p>For example, you can use:</p> <pre><code>from pytvpaint.clip import Clip\n\nclip = Clip.current_clip()\nclip.render(\"./out.10-22#.png\")\n# This will render a sequence of (10-22) like so out.0010.png, out.0011.png, ..., out.0022.png\n\n# This is the same as doing\nclip.render(\"./out.#.png\", start=10, end=22)\n</code></pre>"},{"location":"usage/rendering/#understanding-tvpaints-frame-ranges-and-timelines","title":"Understanding TVPaint's frame ranges and timelines","text":"<p>Handling frame ranges in TVPaint can be difficult, depending on the object (Project, Clip, Layer) and on the mark in/out, range values tend to change and are seemingly handled differently between the UI and the code.</p> <p>PyTVPaint handles frames differently in an effort to have a similar behaviour to the other industry software we're familiar with (Premiere, Maya, etc...). Meaning that the ranges provided to the API will have to be formatted a certain way, with the API handling all the appropriate range conversion behind the scenes.</p> <p>To explain how this works we first need to review how TVPaint handles ranges (grab a cup coffee, this might take a while...).</p> <p>Info</p> <p>Since the George documentation can be sometimes lacking in detail, all the explanations below are infered from our tests and might be wrong in some aspects, please take this all with a grain of salt.</p> <p>First let's start by reviewing the two main functions used for rendering in TVPaint.</p> <p>For the sake of brevity, we will ignore the other rendering functions like <code>tv_SaveDisplay</code> as these have no range selection options. We will also ignore all the clip export functions (JSON, Flix, etc...) as these behave in the same way as <code>tv_SaveSequence</code> (which we will review below) when handling ranges.</p> Method Description Can Render Camera <code>tv_ProjectSaveSequence</code> Renders a project True <code>tv_SaveSequence</code> Renders a clip False"},{"location":"usage/rendering/#setup","title":"Setup","text":"<p>Let's start with a simple example. A Project that contains a single clip which in turn contains a single Layer. The layer has a single instance with a length of 10 frames and starts at the clip start. Finally, let's also set the project start frame at 0</p> <p> figure 1</p> <p> figure 2</p> <p>Let's also switch to the timeline view in the project</p> <p> figure 3</p> <p>We now have a project with a range of <code>(0-10)</code>, a clip <code>clip1</code> with a range of <code>(0-10)</code> and finally a layer <code>layer1</code> also with a range of <code>(0-10)</code>. So far so good.</p> <p>Note</p> <p>We're ignoring the Scene objects in these examples since they do not really impact the frame range.</p>"},{"location":"usage/rendering/#testing-and-rendering-examples","title":"Testing and rendering examples","text":"<p>If we want to render <code>clip1</code> we could do this :</p> <pre><code>from pytvpaint import george\n\n# render the clip\ngeorge.tv_save_sequence('out.#.png', 0, 10)\n\n# or render the project\ngeorge.tv_project_save_sequence('out.#.png', start=0, end=10)\n</code></pre> <p>These will all work and render our sequence of <code>(0-10)</code> frames. Let's go a bit further now and change the start frame to <code>53</code> (figure 4). Our project timeline and clip range are shown as starting at 53 in the UI, (see figures 5 and 6).</p> <p> figure 4</p> <p> figure 5</p> <p> figure 6</p> <p>You would assume that rendering our sequence again would mean us using our new range <code>(53-62)</code> like this :</p> <pre><code># render clip new range\ngeorge.tv_save_sequence('out.#.png', 53, 62)\n\n# or render the project\ngeorge.tv_project_save_sequence('out.#.png', start=53, end=62)\n</code></pre> <p>this works...kind of, we'll get back to this later. For now, we do end up with a sequence of 10 frames <code>(53-62)</code>.</p> <p>Again, let's go further and move the first image in the layer one frame to the right. Let's also add a mark in and out to our clip at <code>(55, 60)</code> like shown below.</p> <p> figure 7</p> <p>So now our project still has one clip but with a range <code>(53-63)</code> and one layer with a new range as well <code>(54-63)</code> since we moved it one frame to the left.</p> <p>If we render this again just like we did above, we start to see some inconsistencies.</p> <pre><code>george.tv_save_sequence('out.#.png', 53, 63)\n# =&gt; renders a sequence of 11 frames with a range of (53-63)\n\ngeorge.tv_project_save_sequence('out.#.png', start=53, end=63)\n# ERROR : only renders 6 frames\n</code></pre> <p>It seems rendering the project yields only 6 frames instead of our new range of 11 frames <code>(53-63)</code>. No matter, rendering the clip seems to work, so let's just only use <code>tv_save_sequence</code> from now on !...Well, it turns out rendering the clip doesn't work either. We do end up with the number of frames we asked for, but we've actually been rendering the wrong frames ever since we changed the project's start frame to <code>53</code>. So let's set the project's start frame back to <code>0</code> and try to render again, like so :</p> <pre><code># reset the project start frame\np.start_frame = 0\n\ngeorge.tv_save_sequence('out.#.png', 0, 11)\n# =&gt; renders a sequence of 11 frames with our updated range of (0-11)\n\ngeorge.tv_project_save_sequence('out.#.png', start=53, end=63)\n# ERROR : only renders 6 frames\n</code></pre> <p>Somehow we still end up with missing frames even tough we reverted to the previous project start frame, so what's happening ?</p>"},{"location":"usage/rendering/#understanding-tvpaints-timeline","title":"Understanding TVPaint's timeline","text":"<p>To understand what's happening we need to understand how TVPaint handles its timeline...and the answer is that it doesn't really handle a timeline. TVPaint's elements are handled more like lists than anything else, so all elements start at <code>0</code> and have a range of <code>(0 to N)</code>, however there are really two lists; projects have their timeline/list and clips also have their own timeline/list that is connected to the project's timeline. So to recap:</p> <ul> <li>Clip: a clip's timeline always starts at 0 and goes to N, N being the last image in the \"longest\" layer in the clip.</li> <li>Project: a project's timeline always starts at 0 and goes to N, N being the last frame in the last clip of the project.</li> <li>Layer : layers use the same timeline as their parent clip.</li> </ul> <p>Many things can affect these timelines and change the way we have to provide the rendering range to TVPaint. In the sections below, we will go over these timeline changing elements.</p>"},{"location":"usage/rendering/#project-start-frame","title":"Project Start Frame","text":"<p>Changing the project's start frame actually doesn't change the previously mentioned lists, they still start at 0, it's just the TVPaint UI showing the timeline with an added 53 (again figures 4 and 5 in sections above), which can be pretty misleading (as seen in the example above).</p> <p>So this explains why the images we rendered in our very first example were correct but not the ones after we changed the project's start frame. So to correct our second example, we'd need to subtract the project's start frame from the range we want to render, like so :</p> <pre><code>p_start = 53\nstart, end = (53, 63)\n# clean range before render\nstart = (start - p_start)  # 0\nend = (end - p_start)  # 10\n\ngeorge.tv_save_sequence('out.#.png', start, end)\n# =&gt; renders a correct sequence of 11 frames with a range of (53-63) (as seen in the timeline in the Clip's UI)\n\ngeorge.tv_project_save_sequence('out.#.png', start=start, end=end)\n# ERROR : only renders 6 frames corresponding to the range (53-58) (as seen in the timeline in the Project's UI)\n</code></pre> <p>Except we kind of tried this already when we reverted the project start frame to 0, and it still doesn't work, with <code>tv_project_save_sequence</code> only rendering 6 frames.</p>"},{"location":"usage/rendering/#mark-inout","title":"Mark IN/OUT","text":"<p>The reason the project has only been rendering 6 frames is because we set a mark IN and OUT on the clip at <code>(55-60)</code>. This means that the project now only sees the frames between the mark IN and OUT (see figures 8 and 9 below). If we had only set the mark IN but not the mark OUT, the project would see all the frames between the mark IN and the clip's end frame and vice versa.</p> <p> figure 8 - No Mark IN/OUT</p> <p> figure 7 again - Clip Timeline with Mark IN/OUT at 55/60</p> <p> figure 9 - Project Timeline with same clip Mark IN/OUT at 55/60</p> <p>So this explains why we only had 6 frames rendered, since the duration of the range <code>(55-60)</code> is equal to 6 frames. You probably noticed that there is still an issue. The project now says it's range is <code>(53-59)</code> (figure 9 above) while the clip says it's range (when taking the Mark IN/OUT into account) is at <code>(55-60)</code> and it's full range is (without mark IN/OUT) is <code>(53-63)</code> (figure 7 above)</p> <p>This is not a bug, when you take into account the fact that the project's timeline is separate from the clip timeline and ignores the frames outside the Mark IN/OUT it starts to make sense.</p> <p>We know the project start frame is ignored by the George rendering functions (as mentioned above) and all timelines (project and clip) really start a 0. So our project would only see 6 frames in the clip (the one between Mark IN <code>55</code> and the Mark OUT <code>60</code>), the project's timeline is really <code>(0-5)</code> + the project start frame <code>53</code> and we get <code>(53-58)</code>.</p> <p>So to fix our previous example and render our clip from the project we would need to do this</p> <pre><code>p_start = 53\n\nstart, end = (53, 63)\n# clean range before render\nstart = (start - p_start)  # 0\nend = (end - p_start)  # 10\n\nmark_in, mark_out = (55, 60)\n# clean mark IN/OUT range before render\nmark_in = (mark_in - p_start)  # 2\nmark_out = (mark_out - p_start)  # 7\n\ngeorge.tv_save_sequence('out.#.png', start, end)\n# =&gt; renders a correct sequence of 11 frames with a range of (53-63) (as seen in the timeline in the Clip's UI)\n\ngeorge.tv_save_sequence('out.#.png', mark_in, mark_out)\n# =&gt; renders a correct sequence of 6 frames with a range of (55-50) (as seen in the timeline in the Clip's UI)\n\nrender_duration = (mark_in - mark_out) + 1  # 6\ngeorge.tv_project_save_sequence('out.#.png', start=0, end=render_duration)\n# =&gt; renders a correct sequence of 6 frames with a range of (53-58) (as seen in the timeline in the Project's UI)\n</code></pre> <p>Note</p> <p>Just like Clips, Projects can also have a Mark IN/OUT separate from the clip's, however the project's Mark IN/OUT do not affect the timeline, so we can ignore them.</p> <p>Tip</p> <p>This is also the way you set the Mark IN/OUT, current frame, JSON exports, etc... in Clips and Project</p> <p>We now have a correct way to render our clip from the clip and the project, great ! But we're not done yet, what if we have multiple clips.</p>"},{"location":"usage/rendering/#multiple-clips","title":"Multiple Clips","text":"<p>We figured out how to handle ranges when rendering a clip using <code>tv_save_sequence</code>. We also figured out how to render a project with one clip correctly.</p> <p>Now let's add another clip to the project, we'll place it after our first clip and call it <code>clip2</code>. Add a single layer <code>layer2</code> to it with 5 frames so a range of <code>(0-4)</code> for the clip and layer or <code>(53-57)</code> as shown in the UI (see figure 10 below)</p> <p> figure 10 - New Clip/Layer with 5 frames</p> <p>From our tests earlier, we know that the new clip should show up in the project's timeline after the first one so at <code>(59-63)</code> as shown in the UI (see figure 11 below) or more accurately at <code>(6-10)</code> if we see them as list indices. And that's exactly what we're getting.</p> <p> figure 11 - New Clip/Layer in the project</p> <p>So if we want to render the new clip we would do :</p> <pre><code># rendering from the clip, using the clip's timeline\ngeorge.tv_save_sequence('out.#.png', 0, 4)\n# =&gt; renders a correct sequence of 5 frames with a range of (53-57) (as seen in the timeline in the Clip's UI)\n\n# rendering from the project, using the project's timeline\ngeorge.tv_project_save_sequence('out.#.png', start=6, end=10)\n# =&gt; renders a correct sequence of 6 frames with a range of (59-63) (as seen in the timeline in the Project's UI)\n</code></pre>"},{"location":"usage/rendering/#rendering-the-camera","title":"Rendering the camera","text":"<p>Tip</p> <p>Rendering the camera does not affect the timeline, however only <code>tv_project_save_sequence</code> has an option to render the camera. So you'll have to use the project and it's range to render any frames with the camera.</p>"},{"location":"usage/rendering/#invalid-ranges","title":"Invalid Ranges","text":"<p>An invalid range can be provided to both functions and instead of raising an error, both will render some frames. Here we will try to describe the observed behavior when encountering an invalid range.</p> <p>Info</p> <p>A rendering range is considered invalid if it starts before the Project's or Clip's start frame and ends after the Project's or Clip's end frame</p> <p>For a project using <code>tv_project_save_sequence</code></p> Range Error Renders range starts before the project's start frame Renders all images in the project range ends after the project's end frame Renders all images in the project <p>For a clip using <code>tv_save_sequence</code></p> Range Error Renders range starts before the clip's start frame Renders all images, images will be empty if outside of clip range range ends after the clip's end frame Renders all images, images will be empty if outside of clip range range start is equal to clip's start frame but range ends after the clip's end frame Renders the clip's range only, anything outside the clip's range is not rendered range start is different from clip's start frame and range ends before, at or after the clip's end frame Renders the clip's range only, images will be empty if outside of clip range range start and end are both inferior to clip's start frame Renders the clip's range only, anything outside the clip's range is not rendered"},{"location":"usage/rendering/#how-pytvpaint-handles-a-frame-range","title":"How PyTVPaint handles a frame range","text":"<p>We it comes to our API, we take a very <code>what you see is what you get</code> approach when handling the timeline. Basically if timeline in the UI says that your clip's range is <code>(55-60)</code> (as seen in the examples above) then that is what you should provide to our functions. PyTVPaint will handle the range conversion behind the scenes.</p> <pre><code>from pytvpaint.clip import Clip\n\nc = Clip.current_clip()\n\nc.render('out.#.png', 55, 60)\n# or render using the camera\nc.render('out.#.png', 55, 60, use_camera=True)\n# or when using FileSequence expressions\nc.render('out.55-60#.png', use_camera=True)\n# =&gt; renders a correct sequence of 6 frames with a range of (55, 60) (as seen in the timeline in the Clip's UI)\n\n# we could also do this\nc.render('out.#.png', c.start, c.end)\n</code></pre> <p>For the second clip, and it's range of <code>(53-57)</code>, we would render it this way:</p> <pre><code>from pytvpaint.clip import Clip\n\nc2 = Clip.current_clip()\n\nc2.render('out.#.png', 53, 57)\n# or when using FileSequence expressions\nc2.render('out.53-57#.png')\n# =&gt; renders a correct sequence of 5 frames with a range of (53, 57) (as seen in the timeline in the Clip's UI)\n</code></pre> <p>if we need to render the project, or part of it, let's say the second clip, which has a range of <code>(59-63)</code> in the project's timeline (see figure 11 above)</p> <pre><code>from pytvpaint.project import Project\n\np = Project.current_project()\n\np.render('out.#.png', 59, 63)\n# or render using the camera\np.render('out.#.png', 59, 63, use_camera=True)\n# =&gt; renders a correct sequence of 5 frames with a range of (59, 63) (as seen in the timeline in the project's UI)\n\n# we can also use the clip's properties to get its range in the project's timeline\nc2 = p.get_clip(by_name=\"clip2\")\nprint(c2.timeline_start)  # =&gt; 59\nprint(c2.timeline_end)  # =&gt; 63\n</code></pre> <p>Success</p> <p>This is also the way you provide ranges and frames to all our API's functions. So when setting the current frame, the Mark IN/OUT etc... remember to base your range on the UI.</p> <p>Warning</p> <p>PyTVPaint uses <code>tv_project_save_sequence</code> to render frames for the project and the clips, this means that when rendering a clip, it will consider any range outside the clip's Mark IN/OUT (if they have been set) as invalid.</p> <p>Warning</p> <p>Unlike TVPaint, PyTVPaint will raise a ValueError when provided with an invalid range. If you'd like to render an invalid range anyways, then consider using these wrapped functions directly (<code>george.tv_project_save_sequence</code> , <code>george.tv_save_sequence</code>). This also means that you will have to do the range conversions yourself, as shown in the examples above.</p> <p>Warning</p> <p>Even tough pytvpaint does a pretty good job of correcting the frame ranges for rendering, we're still encountering some weird edge cases where TVPaint will consider the range invalid for seemingly no reason.</p>"},{"location":"usage/usage/","title":"Usage","text":"<p>PyTVPaint offers two ways to interact with TVPaint.</p> <p>The recommended one is to use the object-oriented API which handles all the nitty-gritty details of George and provides an extra layer of features. The classes can be imported from <code>pytvpaint.*</code></p> <p>The other way is to use the wrapped George functions in Python which behave almost exactly as their George counterparts. These can be imported from <code>pytvpaint.george.*</code>.</p>"},{"location":"usage/usage/#environment-variables","title":"Environment variables","text":"<p>PyTVPaint can be configured using these variables:</p> Name Default value Description <code>PYTVPAINT_LOG_LEVEL</code> <code>INFO</code> Changes the log level of PyTVPaint. Use the <code>DEBUG</code> value to see the RPC requests and responses for debugging George commands. <code>PYTVPAINT_WS_HOST</code> <code>ws://localhost</code> The hostname of the RPC over WebSocket server (tvpaint-rpc plugin). <code>PYTVPAINT_WS_PORT</code> <code>3000</code> The port of the RPC over WebSocket server (tvpaint-rpc plugin). <code>PYTVPAINT_WS_STARTUP_CONNECT</code> <code>1</code> Whether or not PyTVPaint should automatically connect to the WebSocket server at startup (module import). Accepts 0 or 1. <code>PYTVPAINT_WS_TIMEOUT</code> <code>60</code> seconds The timeout after which we stop reconnecting at startup or if the connection was lost."},{"location":"usage/usage/#automatic-client-connection","title":"Automatic client connection","text":"<p>When you first import <code>pytvpaint</code>, a WebSocket client is automatically created and tries to connect to the server run by the C++ plugin you installed.</p> <p>For example in an interactive Python shell:</p> <pre><code>&gt;&gt;&gt; from pytvpaint.layer import Layer\n[2024-02-26 12:39:00,634] pytvpaint / INFO -- Connected to TVPaint on port 3000\n</code></pre> <p>Tip</p> <p>Set the <code>PYTVPAINT_LOG_LEVEL</code> environment variable to <code>INFO</code> to see the log above.</p> <p>Tip</p> <p>You can disable this automatic behavior by setting the <code>PYTVPAINT_WS_STARTUP_CONNECT</code> variable to <code>0</code>.</p>"},{"location":"usage/usage/#object-oriented-api","title":"Object-oriented API","text":"<p>PyTVPaint provides an object-oriented API that handles the George calls behind the scenes. Most objects in TVPaint have their own implementation (<code>Project</code>, <code>Scene</code>, <code>Clip</code>, <code>Layer</code>...).</p>"},{"location":"usage/usage/#getting-the-current-data-in-tvpaint","title":"Getting the current data in TVPaint","text":"<p>Most of the classes provide a way to get the current element in TVPaint because the current state of the open TVPaint instance matters when querying data from TVPaint.</p> <p>For example to get the current clip:</p> <pre><code>from pytvpaint.clip import Clip\n\nclip = Clip.current_clip()\n\n# You can also get the current layer\nlayer = clip.current_layer\n</code></pre>"},{"location":"usage/usage/#structure","title":"Structure","text":"<p>The API follows the structure of TVPaint projects in this order: <code>Project -&gt; Scene -&gt; Clip -&gt; Layer</code>.</p> <p>In practice you can do this:</p> <pre><code>from pytvpaint import Project\n\nproject = Project.current_project()\n\nfor scene in project.scenes:\n    for clip in scene.clips:\n        for layer in clip.layers:\n            print(layer)\n</code></pre>"},{"location":"usage/usage/#generators","title":"Generators","text":"<p>Since George commands are time expensive to run, most of the properties that returns objects are in fact generators of objects.</p> <p>For example:</p> <pre><code>for layer in clip.layers:\n    # Do something with layer, consumes it\n\n# To get the list of layers you need to consume the whole generator\nlayers = list(clip.layers)\n</code></pre>"},{"location":"usage/usage/#data-refreshing","title":"Data refreshing","text":"<p>To keep an up-to-date state of the objects in TVPaint (since changes can happen through both the code and the UI), The library \"refreshes\" the objects any time a property or method is called by querying TVPaint before running some commands. This sometime means jumping from element to element (projects, clips, etc...) in the UI.</p> <p>For example getting the project path:</p> <pre><code>from pytvpaint import Layer\n\nlayer = Layer.current_layer()\n\n# Gets the layer name\nlayer_name = layer.name\n\n# The user changes the layer name in the interface...\n\n# The name property gives the right value\nrefreshed_name = layer.name\n</code></pre>"},{"location":"usage/usage/#invalid-and-removable-objects","title":"Invalid and removable objects","text":"<p>Another issue we are facing is that if you have a Python object instance representing a layer and you remove that layer in TVPaint, then the Python object is no longer valid. Another issue we are facing is objet deletions. Let's say you have a Python <code>Layer</code> object, and you remove it in the TVPaint UI, that the Python object is no longer valid.</p> <p>There's two ways an object can be considered invalid:</p> <ol> <li>The programmer explicitly removed the object by calling the <code>.remove()</code> method.</li> <li>The object itself was removed from the TVPaint interface.</li> </ol> <p>In this example we remove a layer and try to access it afterward:</p> <pre><code>from pytvpaint import Layer\n\nlayer = Layer.current_layer()\nlayer.remove()\n\n# Will raise a ValueError: Layer has been removed!\nprint(layer.name)\n</code></pre> <p>This is the same if we close the project containing the layer:</p> <pre><code>from pytvpaint import Project\n\nproject = Project.current_project()\nlayer = project.current_clip.current_layer\n\nproject.close()\n\n# Will raise an error when we try to access properties\nprint(layer.name)\n</code></pre>"},{"location":"usage/usage/#utilities","title":"Utilities","text":""},{"location":"usage/usage/#undoable","title":"Undoable","text":"<p>In George, you can manage the undo/redo stack with the <code>tv_undoopenstack</code> and <code>tv_undoclosestack</code> functions.</p> <p>In order to facilitate this process, we provide :</p> <ul> <li>the <code>undoable</code> decorator</li> <li>the <code>undoable_stack</code> context manager.</li> </ul> <p>Undo a whole function:</p> <pre><code>from pytvpaint import george\n\n\n@george.undoable\ndef some_george_actions():\n    george.tv_bookmark_clear(5)\n    george.tv_background_set(george.BackgroundMode.NONE)\n</code></pre> <p>Or only register some operations:</p> <pre><code>from pytvpaint import george\nfrom pytvpaint.project import Project\n\n\ndef some_george_actions():\n    with george.undoable_stack():\n        p = Project.new(\"./project.tvpp\")\n        p.start_frame = 67\n\n    p.add_sound(\"test.wav\")\n</code></pre>"},{"location":"usage/usage/#rendering-contexts","title":"Rendering Contexts","text":"<p>TVPaint's rendering functions do not provided an easy way to set render settings, you are expected to set these yourself and restore them to their previous values when done. PyTVPaint provides two helpful context functions to make this easier:</p> <ul> <li>the <code>render_context</code> context manager.</li> <li>the <code>restore_current_frame</code> context manager.</li> </ul> <p>Note</p> <p>Our <code>Clip.render</code> and <code>Project.render</code> functions already use these contexts so you don't have to.</p>"},{"location":"usage/usage/#render_context","title":"<code>render_context</code>","text":"<p>Using <code>render_context</code> will :</p> <ul> <li>Set the alpha mode and save format (with custom options)</li> <li>Hide / Show the given layers (some render functions only render by visibility)</li> <li>Restore the previous values after rendering</li> </ul> <pre><code>from pytvpaint.utils import render_context\n\nwith render_context(\n    alpha_mode,\n    background_mode,\n    save_format,\n    format_opts,\n    layer_selection=[my_layer],\n):\n    george.tv_save_image(export_path)\n</code></pre>"},{"location":"usage/usage/#restore_current_frame","title":"<code>restore_current_frame</code>","text":"<p>Context that temporarily changes the current frame to the one provided and restores it when done.</p> <pre><code>from pytvpaint.utils import restore_current_frame\n\nwith restore_current_frame(my_clip, my_render_frame):\n    george.tv_save_display(export_path)\n</code></pre>"},{"location":"usage/usage/#george-functions","title":"George functions","text":"<p>The George functions are implemented in the <code>pytvpaint.george</code> module, sorted by the type of TVPaint element they operate on.</p> <p>The idea is to map these closely the real George functions documented here (parameters, return types, enum values...).</p> <p>Note</p> <p>Not all George functions are implemented in the library for now. Some are quite complicated to \"translate\" but others are trivial. For now we only implemented the functions that suit our needs in our pipeline. Feel free to make a PR or write an issue on Github if you want to contribute !</p> <p>Here is an example of how you can use the basic/wrapped George functions:</p> <pre><code># Handy because you have access to all the functions within a single module\nfrom pytvpaint import george\n\ncurrent_layer_id = george.tv_layer_current_id()\ngeorge.tv_layer_anim(current_layer_id)\n\n# All the _info functions return a dataclass containing the returned values (here TVPLayer)\nname = george.tv_layer_info(current_layer_id).name\n\ngeorge.tv_layer_rename(current_layer_id, f\"{name}_anim_layer\")\n</code></pre> <p>Success</p> <p>And that's it! No more <code>PARSE result</code> in George and everything is type-hinted and documented! We still recommend using the high level API though, if you found that something is missing, please open an issue!</p>"}]}